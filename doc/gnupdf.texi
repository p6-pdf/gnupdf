\input texinfo
@comment $Id: gnupdf.texi,v 1.79 2008/07/07 20:22:31 jemarch Exp $
@comment %**start of header
@setfilename gnupdf.info
@settitle GNU PDF Library Reference
@comment %**end of header

@set EDITION first
@set VERSION 0.1

@copying 
This is the @strong{@value{EDITION}} edition of the @cite{GNU PDF Library
Reference}, updated for @strong{libgnupdf} version @strong{@value{VERSION}}.

Copyright @copyright{} 2007, 2008 Free Software Foundation, Inc.

@quotation
Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.2 or
any later version published by the Free Software Foundation; with no
Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts. A
copy of the license is included in the section entitled ``GNU Free
Documentation License''.
@end quotation
@end copying

@dircategory Software libraries
@direntry
* gnupdf: (gnupdf).             The GNU PDF Library reference.
@end direntry

@titlepage
@sp 6
@center @titlefont{GNU PDF Library Reference}
@sp 4
@center @value{EDITION} Edition, Updated for version @value{VERSION}.
@sp 5
@center Free Software Foundation
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@contents

@ifnottex
@node Top
@top GNU PDF Library Reference

GNU PDF Library Reference

@insertcopying
@end ifnottex

@menu
* Overview::            The GNU PDF library in brief.
* Base Layer::          Base library facilities.
* Object Layer::        Editing the object structure of a PDF file.
* Document Layer::      Editing the document-level structure of a PDF
                          file.
* Page Contents Layer::  Editing the contents of pages.
* GNU Free Documentation License::  Distribution terms of this manual.

Indices

* Global variable index::       
* Data type index::             
* Function index::              
@end menu

@node Overview
@chapter Overview

@node Base Layer
@chapter Base Layer

@menu
* Base Layer Overview::
* Error Management::
* Memory Allocation::
* Basic Types::
* Hash Tables::
* Lists::
* Filtered Streams::
* Floating Point Maths::
* Encoded Text::
* Time Management::
* The Filesystem Module::
* Encryption::
@end menu

@node Base Layer Overview
@section Overview

The base layer of the GNU PDF Library provide system-independent
access to several facilities.

The implemented facilities are organized into modules. Each module
export an API to be used by the client application or other layers of
the library. Some modules make use of the facilities implemented in
other modules (such as allocation or error functions).

@node Error Management
@section Error Management


The Error module provides procedures for error reporting to the
client as well as for error tracing (via debug messages) to
developers. Here we also define status types returned by most
procedures (there are exceptions though).

@menu
* Status types::
* Error Reporting procedures::
* Debugging procedures::
@end menu

@node Status types
@subsection Status types

@deftp {Data Type} pdf_status_t
A status variable. This type of variable is returned by many library
functions in order to communicate the status of the performed
operation.
@end deftp

The following constants defines the valid values to be hold in a
@code{pdf_status_t} variable:

@deftp {Constant} PDF_OK
Success
@end deftp

@deftp {Constant} PDF_ERROR
A serious error
@end deftp

@deftp {Constant} PDF_EBADDATA
Invalid or bad arguments
@end deftp

@deftp {Constant} PDF_ENOMEM
Insufficient memory
@end deftp

@deftp {Constant} PDF_EEOF
End of file
@end deftp

@deftp {Constant} PDF_EDIVBYZERO
Divison by zero
@end deftp

@deftp {Constant} PDF_ENONODE
No node found
@end deftp

@deftp {Constant} PDF_EINVRANGE
Invalid range
@end deftp

@deftp {Constant} PDF_ETEXTENC
Error in text encoding
@end deftp

@deftp {Constant} PDF_ENOMATCH 
No matching found
@end deftp

This list will grow as we get closer to a mature state of development.


@node Error Reporting procedures
@subsection Error Reporting procedures

@deftypefun void pdf_perror (const pdf_status_t @var{status}, const char *@var{str})

Prints the message corresponding to @var{status} to stderr followed by @var{str}.

@table @strong
@item Parameters
@table @var
@item status
status code
@item str
a user-defined message
@end table
@item Returns
nothing
@item Usage example
@example
pdf_status_t st;

st = pdf_i64_add (dest, addend_1, addend_2);

if (st != PDF_OK)
@{
        pdf_perror (st, "Couldn't do i64 addition");
@}
@end example
@end table
@end deftypefun

@deftypefun void pdf_error (const pdf_status_t @var{status}, FILE *@var{fd}, const char *@var{format}, @var{...})

Prints a message with `fprintf (@var{fd}, @var{format}, ...)'; 
if @var{status} is nonzero, also prints the corresponding message.

@table @strong
@item Parameters
@table @var
@item status
status code
@item fd
file descriptor open for writing
@item format
string format for the message
@item ...
format's arguments
@end table
@item Returns
nothing
@item Usage example
@example
pdf_status_t st;

st = pdf_i64_add (dest, addend_1, addend_2);

if (st != PDF_OK)
@{
        pdf_error (st, logfd, "Couldn't do i64 addition");
@}
@end example
@end table
@end deftypefun

@node Debugging procedures
@subsection Debugging procedures

For each layer there is a macro procedure defined. The file name and
the line number at which the error ocurred is printed to stderr
followed by @var{message}.

@defmac PDF_DEBUG_BASE (message, ...)
@end defmac
@defmac PDF_DEBUG_OBJECT (message, ...)
@end defmac
@defmac PDF_DEBUG_DOCUMENT (message, ...)
@end defmac
@defmac PDF_DEBUG_PAGE (message, ...)
@end defmac

@table @strong
@item Parameters
@table @var
@item message
a 'const char*' string
@item ...
message's arguments
@end table
@item Returns
nothing
@item Usage example
@example
PDF_DEBUG_BASE("Testing macro '%s' '%d' '%lf'", "string", 7, 10.1);
@end example
@end table

@subheading Output format
The output format for these macros is,

GNU PDF:***DEBUG <layer>***:<file-name>:<line-number>: <message>.

For example,

GNU PDF:***DEBUG BASE***:pdf-memory.c:344: insufficient memory.

@node Memory Allocation
@section Memory Allocation

The memory allocation module provides system-independent heap memory
allocation and deallocation. The usual malloc/free/realloc schema is
used to provide this service.

@deftypefun void* pdf_alloc (const pdf_size_t @var{size})

Allocates heap memory.

@table @strong
@item Parameters

@table @var
@item size
The requested number of octects to allocate.
@end table

@item Returns
A pointer to the newly allocated memory. 

If there is not enough available memory to satisfy the petition then
@code{NULL} is returned.
@item Usage example
@example
int *p;

p = (int *) pdf_alloc (sizeof(int));
*p = 666;
@end example
@end table
@end deftypefun

@deftypefun void pdf_dealloc (const void *@var{pointer})

Deallocates heap memory.

@table @strong
@item Parameters

@table @var
@item pointer
A pointer pointing to the memory we want to deallocate. The memory to
deallocate should have been previously allocated using
@code{pdf_alloc}.
@end table

@item Returns
None.
@item Usage Example

@example
char *p;

p = (char *) pdf_alloc (21);
pdf_dealloc (p);
@end example
@end table
@end deftypefun

@deftypefun void* pdf_realloc (const void *@var{pointer}, const pdf_size_t @var{size})

Reallocates memory.

@table @strong
@item Parameters

@table @var
@item pointer
A pointer to previously allocated memory. 

The memory to reallocate should have been allocated using
@code{pdf_alloc} or @code{pdf_realloc}.
@item size
The new size of the allocated memory chunk. 

If the requested size is shorter than the original size of the
allocated memory then it is truncated. Any previous contents in the
memory will be lost.

If the requested size is larger or equal than the original size of the
allocated memory then the previous contents of the allocated memory
remains. The contents of newly allocated memory are undetermined.

If there is not enough available memory to satisfy the petition a
fatal error is signaled killing the current process. An error status
is returned to the operating system.
@end table

@item Returns
A pointer to the reallocated memory.
@item Usage Example
@example
char *p;

p = (char *) pdf_alloc (4);
strncpy (p, "abcd", 4);

/* p now points to "abcd" */

p = (char *) pdf_realloc (5);
p[4] = 'e';

/* p now points to "abcde" */

p = (char *) pdf_realloc (4);

/* p now points to "abcd" */

pdf_dealloc (p);
@end example
@end table
@end deftypefun

@node Basic Types
@section Basic Types

@menu
* Boolean Types::
* Numeric Types::
* Big Numbers::
@end menu

@node Boolean Types
@subsection Boolean Types

@deftp {Data Type} pdf_bool_t
A boolean value.
@end deftp

The following constants defines the valid values to be hold in a
@code{pdf_bool_t} variable:

@deftp {Constant} PDF_TRUE
Logical true.
@end deftp

@deftp {Constant} PDF_FALSE
Logical false.
@end deftp

@node Numeric Types
@subsection Numeric Types

@deftp {Data Type} pdf_i32_t
Signed 32 bits integer.
@end deftp

@deftp {Data Type} pdf_u32_t
Unsigned 32 bits integer.
@end deftp

The following constants are defined in order to define the valid value
ranges for these data types:

@deftp {Constant} PDF_I32_MAX
Maximum value able to be stored in a @code{pdf_i32_t} variable.
@end deftp

@deftp {Constant} PDF_I32_MIN
Minimum value able to be stored in a @code{pdf_i32_t} variable.
@end deftp

@deftp {Constant} PDF_U32_MAX
Maximum value able to be stored in a @code{pdf_u32_t} variable.
@end deftp

@deftp {Constant} PDF_U32_MIN
Minimum value able to be stored in a @code{pdf_u32_t} variable.
@end deftp

@node Big Numbers
@subsection Big Numbers

An implementation of Big numbers (64 bit) is also provided. These
bignums can be used in machines not providing true 64 bit integers.

@deftp {Data Type} pdf_i64_t
A variable of type pdf_i64_t is capabable of representing 64 bit signed integers.
@end deftp

@deftypefun pdf_i64_t  pdf_i64_new (const pdf_i32_t @var{high}, const pdf_u32_t @var{low})

Create a new i64 variable from one 32 bit signed integer and a 32 bit unsigned integer.

@table @strong
@item Parameters
@table @var
@item high
The high (signed) part of the 64 bit integer.
@item low
The low (unsigned) part of the 64 bit integer.
@end table
@item Returns
The newly created i64 object.
@item Usage example
@example
pdf_i64_t bignum;

bignum = pdf_i64_new((32 << 1),10); /*bignum is now -10*/
@end example
@end table
@end deftypefun

@deftypefun void pdf_i64_assign (pdf_i64_t *@var{bignum}, const pdf_i32_t @var{high}, const pdf_u32_t @var{low}, pdf_status_t *@var{p_status})

Assign a value coming from one 32 bit signed integer and a 32 bit unsigned integer to a  i64 integer.

@table @strong
@item Parameters
@table @var
@item high
The high (signed) part of the 64 bit integer.
@item low
The low (unsigned) part of the 64 bit integer.
@item bignum
Variable that stores 64 bit integer
@end table
@item Returns
A pdf status value:
@table @code
@item PDF_OK
Operation successful
@end table
@item Usage example
@example
pdf_i64_t *bignum;
pdf_i64_t result;
pdf_status_t *p_status;
result = pdf_i64_new(0, 0);
bignum = &result;

pdf_i64_assign(bignum, (32 << 1), 10, p_status);
if (*p_status != PDF_OK) /*bignum is now -10*/
@{
   /* Error code */
@}
@end example
@end table
@end deftypefun

@deftypefun void pdf_i64_assign_quick (pdf_i64_t *@var{bignum}, const pdf_i32_t @var{value}, pdf_status_t *@var{p_status})

Assign a value coming from one 32 bit signed integer to a  i64 integer.

@table @strong
@item Parameters
@table @var
@item value
A signed 32 bit integer
@item bignum
Variable that stores 64 bit integer
@end table
@item Returns
A pdf status value:
@table @code
@item PDF_OK
Operation successful
@end table
@item Usage example
@example
pdf_i64_t *bignum;
pdf_i64_t result;
pdf_status_t *p_status;
result = pdf_i64_new(0, 0);
bignum = &result;
pdf_i64_assign_quick(bignum, -10, p_status);
if (*p_status != PDF_OK) /*bignum is now -10*/
@{
   /* Error code */
@}
@end example
@end table
@end deftypefun	

@deftypefun void pdf_i64_copy (const pdf_i64_t @var{orig}, pdf_i64_t *@var{copy}, pdf_status_t *@var{p_status})

Copies the data from orig to copy.

@table @strong
@item Parameters
@table @var
@item orig
Original variable whose data is to be copied.
@item copy
Variable where data is copied to.
@end table
@item Returns
A pdf status value:
@table @code
@item PDF_OK
Operation successful
@end table
@item Usage example
@example
pdf_i64_t orig;
pdf_i64_t *copy;
pdf_status_t *p_status;
orig = pdf_i64_new(0, 10);
pdf_i64_copy(orig, copy,p_status)
if ( *p_status != PDF_OK) /*Now copy is also 10*/
@{
   /* Error code */
@}
@end example
@end table
@end deftypefun

@deftypefun void pdf_i64_add (pdf_i64_t *@var{dest}, const pdf_i64_t @var{addend1}, const pdf_i64_t @var{addend2}, pdf_status_t *@var{p_status})

Adds two 64 bit numbers

@table @strong
@item Parameters
@table @var
@item addend1
First addend of the sum
@item addend2
Second addend of the sum
@item dest
Where 64 bit result is stored
@end table
@item Returns
A pdf status value:
@table @code
@item PDF_OK
Operation successful
@end table
@item Usage example
@example
pdf_i64_t *dest;
pdf_i64_t result;
pdf_i64_t addend_1;
pdf_i64_t addend_2;
pdf_status_t *p_status;
addend_1 = pdf_i64_new(0, 25);
addend_2 = pdf_i64_new(0, 35);
result = pdf_i64_new(0, 0);
dest = &result;
pdf_i64_add (dest, addend_1, addend_2,p_status);
if (*p_status != PDF_OK) /* Now dest is 60 */
@{
   /* Error code */
@}
@end example
@end table
@end deftypefun

@deftypefun void pdf_i64_add_i32 (pdf_i64_t *@var{dest}, const pdf_i64_t @var{addend1}, const pdf_i32_t @var{addend2}, pdf_status_t *@var{p_status})

Adds a 64bit number and a 32bit number.

@table @strong
@item Parameters
@table @var
@item addend1
First addend of the sum (64bit type)
@item addend2
Second addend of the sum (32 bit)
@item dest
Where 64 bit result is stored
@end table
@item Returns
A pdf status value:
@table @code
@item PDF_OK
Operation successful
@end table
@item Usage example
@example
pdf_i64_t *dest;
pdf_i64_t result;
pdf_i64_t addend_1;
pdf_status_t *p_status;
addend_1 = pdf_i64_new(0, 25);
result = pdf_i64_new(0, 0);
dest = &result;
pdf_i64_add (dest, addend_1, 35,p_status)
if (*p_status != PDF_OK) /* Now dest is 60 */
@{
   /* Error code */
@}
@end example
@end table
@end deftypefun


@deftypefun void pdf_i64_subtraction (pdf_i64_t *@var{dest}, const pdf_i64_t @var{minuend}, const pdf_i64_t @var{subtrahend}, pdf_status_t *@var{p_status})

Finds the difference between two 64 bit numbers

@table @strong
@item Parameters
@table @var
@item minuend
The minuend of the subtraction
@item subtrahend
The subtrahend of the subtraction
@item dest
Where 64 bit result is stored
@end table
@item Returns
A pdf status value:
@table @code
@item PDF_OK
Operation successful
@end table
@item Usage example
@example
pdf_i64_t *dest;
pdf_i64_t result;
pdf_i64_t minuend;
pdf_i64_t subtrahend;
pdf_status_t *p_status;
minuend = pdf_i64_new(0, 25);
subtrahend = pdf_i64_new(0, 35);
result = pdf_i64_new(0, 0);
dest = &result;
pdf_i64_subtraction (dest, minuend, subtrahend,p_status)
if (*p_status != PDF_OK) /* Now dest is -10 */
@{
  /* Error code */
@}
@end example
@end table
@end deftypefun

@deftypefun void pdf_i64_subtraction_i32_min (pdf_i64_t *@var{dest}, const pdf_i32_t @var{minuend}, const pdf_i64_t @var{subtrahend}, pdf_status_t *@var{p_status})

Finds the difference between a 32bit number and a 64bit number

@table @strong
@item Parameters
@table @var
@item minuend
The minuend of the subtraction (32 bits)
@item subtrahend
The subtrahend of the subtraction (64 bits type)
@item dest
Where 64 bit result is stored
@end table
@item Returns
A pdf status value:
@table @code
@item PDF_OK
Operation successful
@end table
@item Usage example
@example
pdf_i64_t *dest;
pdf_i64_t result;
pdf_i64_t subtrahend;
pdf_status_t *p_status;
subtrahend = pdf_i64_new(0, 35);
result = pdf_i64_new(0, 0);
dest = &result;
pdf_i64_subtraction (dest, 25, subtrahend,p_status)
if (*p_status != PDF_OK) /* Now dest is -10 */
@{
  /* Error code */
@}
@end example
@end table
@end deftypefun


@deftypefun void pdf_i64_subtraction_i32_sub (pdf_i64_t *@var{dest}, const pdf_i64_t @var{minuend}, const pdf_i32_t @var{subtrahend}, pdf_status_t *@var{p_status})

Finds the difference between a 64bit number and a 32bit number

@table @strong
@item Parameters
@table @var
@item minuend
The minuend of the subtraction (64 bits type)
@item subtrahend
The subtrahend of the subtraction (32 bits)
@item dest
Where 64 bit result is stored
@end table
@item Returns
A pdf status value:
@table @code
@item PDF_OK
Operation successful
@end table
@item Usage example
@example
pdf_i64_t *dest;
pdf_i64_t result;
pdf_i64_t minuend;
pdf_status_t *p_status;
minuend = pdf_i64_new(0, 25);
result = pdf_i64_new(0, 0);
dest = &result;
pdf_i64_subtraction (dest, minuend, 35,p_status);
if ( != PDF_OK) /* Now dest is -10 */
@{
  /* Error code */
@}
@end example
@end table
@end deftypefun


@deftypefun void pdf_i64_mult (pdf_i64_t *@var{dest}, const pdf_i64_t @var{factor_1}, const pdf_i64_t @var{factor_2}, pdf_status_t *@var{p_status})

Multiplication of two 64 bit numbers

@table @strong
@item Parameters
@table @var
@item factor_1
First factor in the multiplication
@item factor_2
Second factor in the multiplication
@item dest
Where 64 bit result is stored
@end table
@item Returns
A pdf status value:
@table @code
@item PDF_OK
Operation successful
@end table
@item Usage example
@example
pdf_i64_t *dest;
pdf_i64_t result;
pdf_i64_t factor_1;
pdf_i64_t factor_2;
pdf_status_t *p_status;
factor_1 = pdf_i64_new (0, 10);
factor_2 = pdf_i64_new (0, 100);
result = pdf_i64_new (0, 0);
dest = &result;
pdf_i64_mult (dest, factor_1, factor_2,p_status);
if ( *p_status != PDF_OK) /* Now dest is 1000 */
@{
   /* Error code */
@}
@end example
@end table
@end deftypefun

@deftypefun void pdf_i64_mult_i32 (pdf_i64_t *@var{dest}, const pdf_i64_t @var{factor_1}, const pdf_i32_t @var{factor_2}, pdf_status_t *@var{p_status})

Multiplication of a 64bit number and a 32bit number

@table @strong
@item Parameters
@table @var
@item factor_1
First factor in the multiplication (64 bits)
@item factor_2
Second factor in the multiplication (32bits)
@item dest
Where 64 bit result is stored
@end table
@item Returns
A pdf status value:
@table @code
@item PDF_OK
Operation successful
@end table
@item Usage example
@example
pdf_i64_t *dest;
pdf_i64_t result;
pdf_i64_t factor_1;

factor_1 = pdf_i64_new (0, 10);
result = pdf_i64_new (0, 0);
dest = &result;
pdf_i64_mult (dest, factor_1, 100,p_status)
if (*p_status != PDF_OK) /* Now dest is 1000 */
@{
   /* Error code */
@}
@end example
@end table
@end deftypefun

@deftypefun void pdf_i64_div (pdf_i64_t *@var{dest}, const pdf_i64_t @var{dividend}, const pdf_i64_t @var{divisor}, pdf_status_t *@var{p_status})

Division of two 64 bit numbers

@table @strong
@item Parameters
@table @var
@item dividend
The dividend in the division
@item divisor
The divisor in the division
@item dest
Where 64 bit result is stored
@end table
@item Returns
PDF_OK	Operation successful
@item Usage example
@example
pdf_i64_t *dest;
pdf_i64_t result;
pdf_i64_t dividend;
pdf_i64_t divisor;

dividend = pdf_i64_new(0, 200);
divisor = pdf_i64_new(0, 10);
result = pdf_i64_new(0, 0);
dest = &result;
pdf_i64_div (dest, dividend, divisor,p_status);
if(*p_status  != PDF_OK) /* Now dest is 20 */
@{
   /* Error code */
@}
@end example
@end table
@end deftypefun

@deftypefun void pdf_i64_div_i32_dividend (pdf_i64_t *@var{dest}, const pdf_i32_t @var{dividend}, const pdf_i64_t @var{divisor}, pdf_status_t *@var{p_status})

Division of a 32bit number and a 64bit number

@table @strong
@item Parameters
@table @var
@item dividend
The dividend in the division (64 bits)
@item divisor
The divisor in the division (32 bits)
@item dest
Where 64 bit result is stored
@end table
@item Returns
PDF_OK	Operation successful
@item Usage example
@example
pdf_i64_t *dest;
pdf_i64_t result;
pdf_i64_t divisor;

divisor = pdf_i64_new(0, 10);
result = pdf_i64_new(0, 0);
dest = &result;

if (pdf_i64_div (dest, 200, divisor) != PDF_OK) /* Now dest is 20 */
@{
   /* Error code */
@}
@end example
@end table
@end deftypefun

@deftypefun void pdf_i64_div_i32_divisor (pdf_i64_t *@var{dest}, const pdf_i64_t @var{dividend}, const pdf_i32_t @var{divisor}, pdf_status_t *@var{p_status})

Division of a 64bit number and a 32bit number

@table @strong
@item Parameters
@table @var
@item dividend
The dividend in the division (64 bits)
@item divisor
The divisor in the division (32 bits)
@item dest
Where 64 bit result is stored
@end table
@item Returns
PDF_OK	Operation successful
@item Usage example
@example
pdf_i64_t *dest;
pdf_i64_t result;
pdf_i64_t dividend;

dividend = pdf_i64_new(0, 200);
result = pdf_i64_new(0, 0);
dest = &result;

if (pdf_i64_div (dest, dividend, 10) != PDF_OK) /* Now dest is 20 */
@{
   /* Error code */
@}
@end example
@end table
@end deftypefun


@deftypefun void pdf_i64_mod (pdf_i64_t *@var{dest}, const pdf_i64_t @var{dividend}, const pdf_i64_t @var{divisor}, pdf_status_t *@var{p_status})

Returns the remainder of the division between two 64 bit numbers

@table @strong
@item Parameters
@table @var
@item dividend
The dividend in the division
@item divisor
The divisor in the division
@item dest
Where 64 bit result is stored
@end table
@item Returns
A pdf status value:
@table @code
@item PDF_OK
Operation successful
@end table
@item Usage example
@example
pdf_i64_t *dest;
pdf_i64_t result;
pdf_i64_t dividend;
pdf_i64_t divisor;
pdf_status_t *p_status;
dividend = pdf_i64_new(0, 105);
divisor = pdf_i64_new(0, 10);
result = pdf_i64_new(0, 0);
dest = &result;
pdf_i64_mod (dest, dividend, divisor,p_status);
if ( *p_status != PDF_OK) /* Now dest is 5 */
@{
   /* Error code */
@}	
@end example
@end table
@end deftypefun

@deftypefun void pdf_i64_mod_i32_dividend (pdf_i64_t *@var{dest}, const pdf_i32_t @var{dividend}, const pdf_i64_t @var{divisor}, pdf_status_t *@var{p_status})

Returns the remainder of the division between a 32bit number and a 64bit number

@table @strong
@item Parameters
@table @var
@item dividend
The dividend in the division (32bits)
@item divisor
The divisor in the division (64bits)
@item dest
Where 64 bit result is stored
@end table
@item Returns
A pdf status value:
@table @code
@item PDF_OK
Operation successful
@end table
@item Usage example
@example
pdf_i64_t *dest;
pdf_i64_t result;
pdf_i64_t divisor;

divisor = pdf_i64_new(0, 10);
result = pdf_i64_new(0, 0);
dest = &result;

if (pdf_i64_mod (dest, 105, divisor) != PDF_OK) /* Now dest is 5 */
@{
   /* Error code */
@}	
@end example
@end table
@end deftypefun

@deftypefun void pdf_i64_mod_i32_divisor (pdf_i64_t *@var{dest}, const pdf_i64_t @var{dividend}, const pdf_i32_t @var{divisor}, pdf_status_t *@var{p_status})

Returns the remainder of the division between a 64bit number and a 32bit number

@table @strong
@item Parameters
@table @var
@item dividend
The dividend in the division (64 bits)
@item divisor
The divisor in the division (32 bits)
@item dest
Where 64 bit result is stored
@end table
@item Returns
A pdf status value:
@table @code
@item PDF_OK
Operation successful
@end table
@item Usage example
@example
pdf_i64_t *dest;
pdf_i64_t result;
pdf_i64_t dividend;

dividend = pdf_i64_new(0, 105);
result = pdf_i64_new(0, 0);
dest = &result;

if (pdf_i64_mod (dest, dividend, 10) != PDF_OK) /* Now dest is 5 */
@{
   /* Error code */
@}	
@end example
@end table
@end deftypefun

@deftypefun void pdf_i64_abs (pdf_i64_t *@var{dest}, const pdf_i64_t @var{number}, pdf_status_t *@var{p_status})

Returns the absolute value

@table @strong
@item Parameters
@table @var
@item number
pdf_i64_t type variable
@item dest
Where 64 bit result is stored
@end table
@item Returns
A pdf status value:
@table @code
@item PDF_OK
Operation successful
@end table
@item Usage example
@example
pdf_i64_t *dest;
pdf_i65_t result;
pdf_i64_t number;
pdf_status_t *p_status;
number = pdf_i64_new ((32 << 1), 105); /*number is -105*/
result = pdf_i64_new (0, 0);
dest = &result;
pdf_i64_abs (dest, number,p_status)
if ( *p_status != PDF_OK) /* now dest stores 105 */
@{
   /* Error code */
@}
@end example
@end table
@end deftypefun

@deftypefun int pdf_i64_cmp (const pdf_i64_t @var{number_1}, const pdf_i64_t @var{number_2})

Compares two 64 bit integers

@table @strong
@item Parameters
@table @var
@item number_1
pdf_i64_t type variable
@item number_2
pdf_i64_t type variable
@end table
@item Returns
An integer:
@table @code
@item 0
If numbers are equal
@item 1
If @var{number_1} is greater than @var{number_2}
@item -1
If @var{number_2} is greater than @var{number_1}
@end table
@item Usage example
@example
pdf_i65_t number_1;
pdf_i64_t number_2;
int result;

number_1 = pdf_i64_new ((32 << 1), 10); /* number_1 is -10 */
number_2 = pdf_i64_new (0, 10); /* number_2 is 10 */
result = pdf_i64_cmp (number_1, number_2); /* Now result is -1 */
@end example
@end table
@end deftypefun

@deftypefun int pdf_i64_cmp_i32 (const pdf_i64_t @var{number_1}, const pdf_i32_t @var{number_2})

Compares a 64bit number and a 32bit number

@table @strong
@item Parameters
@table @var
@item number_1
pdf_i64_t type variable
@item number_2
pdf_i32_t type variable
@end table
@item Returns
An integer:
@table @code
@item 0
If numbers are equal
@item 1
If @var{number_1} is greater than @var{number_2}
@item -1
If @var{number_2} is greater than @var{number_1}
@end table
@item Usage example
@example
pdf_i65_t number_1;
int result;

number_1 = pdf_i64_new ((32 << 1), 10); /* number_1 is -10 */
result = pdf_i64_cmp (number_1, 10); /* Now result is -1 */
@end example
@end table
@end deftypefun

@deftypefun void pdf_i64_neg (pdf_i64_t *@var{dest}, const pdf_i64_t @var{number}, pdf_status_t *@var{p_status})

Changes sign of 64 bit integer

@table @strong
@item Parameters
@table @var
@item number
pdf_i64_t type variable
@end table
@item Returns
A pdf status value:
@table @code
@item PDF_OK
Operation successful
@end table
@item Usage example
@example
pdf_i64_t *dest;
pdf_i65_t result;
pdf_i64_t number;
pdf_status_t *p_status;
number = pdf_i64_new (0, 10);
result = pdf_i64_new (0, 0);
dest = &result;
pdf_i64_neg (dest, number,p_status)
if ( *p_status != PDF_OK) /* now dest stores -10 */
@{
   /* Error code */
@}
@end example
@end table
@end deftypefun

@deftypefun pdf_i32_t pdf_i64_to_i32 (const pdf_i64_t @var{bignum})

Converts a pdf_i64_t to a 32bit value. If number can't be represented in 32 bits
the result is undefined, so should be used with caution.

@table @strong
@item Parameters
@table @var
@item bignum
pdf_i64_t type variable
@end table
@item Returns
A pdf status value:
@table @code
@item PDF_OK
Operation successful
@end table
@item Usage example
@example
pdf_i32_t num;
pdf_i64_t bignum;

bignum = pdf_i64_new (0, 10);

num = pdf_i64_to_i32(bignum);

@end example
@end table
@end deftypefun

@node Hash Tables
@section Hash Tables

@menu
* Hash Table Types::
* Creating and Destroying Hash Tables::
* Hash Table properties::
* Working with keys::
* Adding and removing elements::
* Searching elements::
* Working with iterators::
* Basic dispose functions::
* Hash helper functions::
@end menu

@node Hash Table Types
@subsection Hash Table Types

@deftp {Data Type} pdf_hash_t

A Hash Table able to store key/value pairs. A key may be any
NULL-terminated string.
@end deftp

@deftp {Data Type} pdf_hash_iterator_t

An iterator over the keys of a Hash Table.
@end deftp

@deftp {Data Type} void (*pdf_hash_element_dispose_fn_t) (const void *elt)
A function type for disposing hash elements.
@end deftp

@deftp {Data Type} void (*pdf_hash_key_dispose_fn_t) (const void *key)
A function type for disposing hash keys.
@end deftp

@node Creating and Destroying Hash Tables
@subsection Creating and Destroying Hash Tables

@deftypefun pdf_status_t pdf_hash_new (pdf_hash_key_dispose_fn_t @var{dispose_key_fn}, pdf_hash_t @var{*table})

Create a new empty hash table. When some element is removed @var{dispose_key_fn} are called, can be NULL.

@table @strong
@item Parameters
@table @var
@item dispose_key_fn
A pointer to a hash table element key dispose function or NULL.
@item table
A pointer to a hash table.
@end table
@item Returns
A pdf status value:
@table @code
@item PDF_OK
The operation succeeded.
@item PDF_ENOMEM
Not enough memory.
@item PDF_EBADDATA
Invalid @var{table} pointer.
@end table
@item Usage example
@example
pdf_hash_t hash;

/* Create an instance of a hash without a disposal function */
if (pdf_hash_new (NULL, &hash) != PDF_OK)
   @{
      /* Error creating the hash table */
   @}
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_hash_destroy (pdf_hash_t @var{table})

Destroy a hash table. The elements of the table are disposed first.

@table @strong
@item Parameters
@table @var
@item table
A hash table.
@end table
@item Returns
A pdf status value:
@table @code
@item PDF_OK
The operation succeeded.
@end table
@item Usage example
@example
pdf_hash_t hash;

if (pdf_hash_new (NULL, &hash) == PDF_OK)
   @{
      /* Destroy the hash */
      pdf_hash_destroy (hash);
   @}
else
   @{
      /* Error creating the hash table */
   @}
@end example
@end table
@end deftypefun

@node Hash Table properties
@subsection Hash Table properties

@deftypefun pdf_size_t pdf_hash_size (const pdf_hash_t @var{table})

Returns the number of entries in @var{table}.

@table @strong
@item Parameters
@table @var
@item table
A hash table.
@end table
@item Returns
The number of entries.
@item Usage example
@example
pdf_hash_t hash;

/* Create a new hash */
if (pdf_hash_new (NULL, &hash) == PDF_OK)
   @{
      /* Add some elements to the hash */
      pdf_hash_add (hash, "first-key", "first-value", NULL);
      pdf_hash_add (hash, "second-key", "second-value", NULL);
      pdf_hash_add (hash, "third-key", "third-key", NULL);

      /* This call should return 3 */
      pdf_hash_size (hash);
   @}
@end example
@end table
@end deftypefun

@node Working with keys
@subsection Working with keys

@deftypefun pdf_bool_t pdf_hash_key_p (const pdf_hash_t @var{table}, const char *@var{key})

Returns a boolean value indicating whether an element with key @var{key} exists in @var{table}.

@table @strong
@item Parameters
@table @var
@item table
A hash table.
@item key
A valid key string.
@end table
@item Returns
A pdf boolean value:
@table @code
@item PDF_TRUE
An element associated with @var{key} exists.
@item PDF_FALSE
There is no element associated with @var{key}.
@end table
@item Usage example
@example
pdf_hash_t hash;

/* Create a new hash */
if (pdf_hash_new (NULL, &hash) == PDF_OK)
   @{
      /* Add some elements to the hash */
      pdf_hash_add (hash, "a-key", "a-value", NULL);

      if (pdf_hash_key_p (hash, "a-key"))
         @{
            /* The program enters here */
         @}
      if (pdf_hash_key_p (hash, "x-key"))
         @{
            /* The program doesnt reach this */
         @}
   @}
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_hash_rename (pdf_hash_t @var{table}, const char @var{*key}, const char @var{*new_key})

Renames the key @var{key} to @var{new_key} in @var{table}.

@table @strong
@item Parameters
@table @var
@item table
A hash table.
@item key
A valid key string.
@item new_key
A valid key string.
@end table
@item Returns
A pdf status value:
@table @code
@item PDF_OK
The operation succeded.
@item PDF_ERROR
The @var{key} is not associated with any element in @var{table}.
@item PDF_EBADDATA
Either @var{table} or a key string is invalid or NULL.
@end table
@item Usage example
@example
pdf_hash_t hash;

/* Create a new hash */
if (pdf_hash_new (NULL, &hash) == PDF_OK)
   @{
      /* Add an element to the hash */
      pdf_hash_add (hash, "a-key", "a-value", NULL);

      if (pdf_hash_key_p (hash, "a-key"))
         @{
            /* The program enters here */
         @}

      /* Rename the key */
      pdf_hash_rename (hash, "a-key", "b-key");

      if (pdf_hash_key_p (hash, "a-key"))
         @{
            /* The program doesnt enter here */
         @}

      if (pdf_hash_key_p (hash, "b-key"))
         @{
            /* The program enters here */
         @}
   @}
@end example
@end table
@end deftypefun

@node Adding and removing elements
@subsection Adding and removing elements

@deftypefun pdf_status_t pdf_hash_add (pdf_hash_t @var{table}, const char @var{*key}, const void @var{*element}, pdf_hash_element_dispose_fn_t @var{disp_fn} ) 

Adds the element @var{element} with the associated key @var{key} to @var{table}. If @var{key} already exists nothing is done.

@table @strong
@item Parameters
@table @var
@item table
A hash table.
@item key
A valid key string.
@item element
A pointer to the element being added.
@item disp_fn
A function called when @var{element} is removed. If NULL is given nothing is done.
@end table
@item Returns
A pdf status value:
@table @code
@item PDF_OK
The operation succeeded.
@item PDF_ENOMEM
Not enough memory.
@item PDF_EBADDATA
Either @var{table}, @var{key} or @var{element} is invalid.
@end table
@item Usage example
@example
pdf_hash_t hash;

/* Create a new hash */
if (pdf_hash_new (NULL, &hash) == PDF_OK)
   @{
      /* Add some elements to the hash */
      pdf_hash_add (hash, "first-key", "first-value", NULL);
      pdf_hash_add (hash, "second-key", "second-value", NULL);
      pdf_hash_add (hash, "third-key", "third-key", NULL);
   @}
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_hash_remove (pdf_hash_t @var{table}, const char @var{*key})

Removes the element associated with @var{key} from @var{table}. The element is disposed first.

@table @strong
@item Parameters
@table @var
@item table
A hash table.
@item key
A valid key string.
@end table
@item Returns
A pdf status value:
@table @code
@item PDF_OK
The operation succeeded.
@item PDF_EBADDATA
Invalid @var{table} or @var{key}.
@item PDF_ERROR
The @var{key} wasn't found.
@end table
@item Usage example
@example
pdf_hash_t hash;

/* Create a new hash */
if (pdf_hash_new (NULL, &hash) == PDF_OK)
   @{
      /* Add an element to the hash... */
      pdf_hash_add (hash, "a-key", "a-value", NULL);

      /* And remove it */
      pdf_hash_remove (hash, "a-key");
   @}
@end example
@end table
@end deftypefun

@node Searching elements
@subsection Searching elements

@deftypefun pdf_status_t pdf_hash_search (const pdf_hash_t @var{table}, const char @var{*key}, const void **@var{elem_pointer})

Searches for the element associated with the given @var{key} in @var{table} and store it in @var{elem_pointer}.

@table @strong
@item Parameters
@table @var
@item table
A hash table.
@item key
A valid null-terminated string key.
@item elem_pointer
A pointer where to store the element.
@end table
@item Returns
A pdf status value:
@table @code
@item PDF_OK
The operation succeeded.
@item PDF_EBADDATA
Either @var{elem_pointer} is NULL, @var{key} or the @var{table} is invalid.
@item PDF_ERROR
The @var{key} wasn't found.
@end table
@item Usage example
@example
pdf_hash_t hash;
char *elem;

/* Create a new hash */
if (pdf_hash_new (NULL, &hash) == PDF_OK)
   @{
      /* Add an element to the hash... */
      pdf_hash_add (hash, "a-key", "a-value", NULL);

      /* Get the element from the hash */
      pdf_hash_search (hash, "a-key", (void **) &elem);
   @}
@end example
@end table
@end deftypefun

@node Working with iterators
@subsection Working with iterators

@deftypefun pdf_status_t pdf_hash_iterator_new (const pdf_hash_t @var{table}, pdf_hash_iterator_t @var{*iterator})

Creates an iterator over the keys of @var{table} and saves it in @var{iterator}. Keys composed only by numbers are returned first followed by keys in the order imposed by the ``strcmp()'' function.

@table @strong
@item Parameters
@table @var
@item table
A hash table.
@item iterator
A pointer to an iterator.
@end table
@item Returns
A pdf status value:
@table @code
@item PDF_OK
The operation succeeded.
@item PDF_ENOMEM
Not enough memory.
@item PDF_EBADDATA
Either @var{iterator} is NULL or @var{table} is invalid.
@end table
@item Usage example
@example
pdf_hash_t hash;
pdf_hash_iterator_t hash_iter;

/* Create a new hash */
if (pdf_hash_new (NULL, &hash) == PDF_OK)
   @{
      /* Add some elements to the hash */
      pdf_hash_add (hash, "first-key", "first-value", NULL);
      pdf_hash_add (hash, "second-key", "second-value", NULL);
      pdf_hash_add (hash, "third-key", "third-key", NULL);

      /* Get an iterator to the first element of the hash */
      pdf_hash_iterator_new (hash, &hash_iter);
   @}
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_hash_iterator_next (pdf_hash_iterator_t @var{iterator}, const char **@var{key})

Retrieves the next key from @var{iterator}.

@table @strong
@item Parameters
@table @var
@item iterator
A Hash Table iterator pointer.
@item key
A pointer where to save the key.
@end table
@item Returns
A pdf status value:
@table @code
@item PDF_OK
The operation succeeded.
@item PDF_EBADDATA
Either @var{iterator} is invalid or @var{key} is NULL.
@item PDF_ERROR
There are no more keys to traverse over.
@end table
@item Usage example
@example
pdf_hash_t hash;
pdf_hash_iterator_t hash_iter;
pdf_char_t *key;

/* Create a new hash */
if (pdf_hash_new (NULL, &hash) == PDF_OK)
   @{
      /* Add some elements to the hash */
      pdf_hash_add (hash, "first-key", "first-value", NULL);
      pdf_hash_add (hash, "second-key", "second-value", NULL);
      pdf_hash_add (hash, "third-key", "third-key", NULL);

     /* Traverse all the values of the hash with an iterator */
     pdf_hash_iterator_new (hash, &hash_iter);
     while (pdf_hash_iterator_next (hash_iter, &key) != PDF_ERROR)
      @{
         /* key contains the next key */
      @}
   @}
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_hash_iterator_destroy (pdf_hash_iterator_t @var{iterator})

Free all resources used by @var{iterator}. 

@table @strong
@item Parameters
@table @var
@item iterator
A Hash Table iterator pointer.
@end table
@item Returns
A pdf status value:
@table @code
@item PDF_OK
The operation succeeded.
@end table
@item Usage example
@example
pdf_hash_t hash;
pdf_hash_iterator_t hash_iter;

/* Create a new hash */
if (pdf_hash_new (NULL, &hash) == PDF_OK)
   @{
      /* Add some elements to the hash */
      pdf_hash_add (hash, "first-key", "first-value", NULL);
      pdf_hash_add (hash, "second-key", "second-value", NULL);
      pdf_hash_add (hash, "third-key", "third-key", NULL);

      /* Get an iterator to the first element of the hash */
      pdf_hash_iterator_new (hash, &hash_iter);

      /* Destroy the iterator */
      pdf_hash_iterator_destroy (hash_iter);
   @}
@end example
@end table
@end deftypefun

@node Basic dispose functions
@subsection Basic dispose functions

These are the basic function implementations to free elements and
keys. They should only be used if you allocated elements/keys with
pdf_alloc() and don't need to free any other resource.

@deftypefun void pdf_hash_element_dealloc_fn (const void * @var{elt})

Deallocates @var{elt} with pdf_dealloc(). 

@table @strong
@item Parameters
@table @var
@item elt
A pointer to the element being freed.
@end table
@item Returns
Nothing.
@item Usage example
@example
pdf_hash_t hash;
pdf_char_t *elem;

/* Create a new hash */
if (pdf_hash_new (NULL, &hash) == PDF_OK)
   @{
      /* Allocate memory for a value to be inserted into the hash */
      elem = pdf_alloc (sizeof(pdf_char_t) * 4);
      strcpy ((char *) elem, "abc");

      /* Add an element to the hash, specifying
         pdf_hash_element_dealloc_fn as its disposal 
         function */
      pdf_hash_add (hash,
                    "a-key",
                    (void *) elem,
                    pdf_hash_element_dealloc_fn);

      /* Destroy the hash (the disposal function invokes pdf_dealloc
         in the allocated string */
      pdf_hash_destroy (hash);
   @}
@end example
@end table
@end deftypefun

@deftypefun void pdf_hash_key_dealloc_fn (const void * @var{elt})

Deallocates @var{elt} with pdf_dealloc(). 

@table @strong
@item Parameters
@table @var
@item elt
A pointer to the element being freed.
@end table
@item Returns
Nothing.
@item Usage example
@example
pdf_hash_t hash;
pdf_char_t *key;

/* Create a new hash */
if (pdf_hash_new (pdf_hash_key_dealloc_fn, &hash) == PDF_OK)
   @{
      /* Allocate memory for a key to be used into the hash */
      key = pdf_alloc (sizeof(pdf_char_t) * 4);
      strcpy ((char *) elem, "abc");

      /* Add an element to the hash, using the key */
      pdf_hash_add (hash, key, "abc", NULL); 

      /* Destroy the hash (the key disposal function invokes pdf_dealloc
         in the allocated string */
      pdf_hash_destroy (hash);
   @}
@end example
@end table
@end deftypefun

@node Hash helper functions
@subsection Hash helper functions

These are specific functions for adding different types of elements
(types defined by the library). They guarantee that when an element of
one of these types is removed from a hash table the correct disposal
function is called.

NOTE: If you are going to use the element after the table containing
the element is destroyed, in that case don't use these functions.

@deftypefun pdf_status_t pdf_hash_add_text (pdf_hash_t @var{table}, const char @var{*key}, const pdf_text_t @var{*elt})

Adds the text @var{elt} with the associated key @var{key} to @var{table}. If @var{key} already exists nothing is done.

@table @strong
@item Parameters
@table @var
@item table
A hash table.
@item key
A valid key string.
@item elt
A pointer to the element being added.
@end table
@item Returns
A pdf status value:
@table @code
@item PDF_OK
The operation succeeded.
@item PDF_ENOMEM
Not enough memory.
@item PDF_EBADDATA
Either @var{table}, @var{key} or @var{elt} is invalid.
@end table
@item Usage example
@example
pdf_hash_t hash;
pdf_text_t elem;

/* Create a new hash */
if (pdf_hash_new (NULL, &hash) == PDF_OK)
   @{
      /* Create the element for the hash */
      pdf_text_new_from_unicode ("abc", 3,
                                 PDF_TEXT_UTF8,
                                 &hash);
      
      /* Add an element to the hash, specifying
         pdf_hash_element_dealloc_fn as its disposal 
         function */
      pdf_hash_add_text (hash, "a-key", &elem);

      /* Destroy the hash */
      pdf_hash_destroy (hash);
   @}
@end example
@end table
@end deftypefun


@deftypefun pdf_status_t pdf_hash_add_time (pdf_hash_t @var{table}, const char @var{*key}, const pdf_time_t @var{*elt})

Adds the time @var{elt} with the associated key @var{key} to @var{table}. If @var{key} already exists nothing is done.

@table @strong
@item Parameters
@table @var
@item table
A hash table.
@item key
A valid key string.
@item elt
A pointer to the element being added.
@end table
@item Returns
A pdf status value:
@table @code
@item PDF_OK
The operation succeeded.
@item PDF_ENOMEM
Not enough memory.
@item PDF_EBADDATA
Either @var{table}, @var{key} or @var{elt} is invalid.
@end table
@item Usage example
@example
pdf_hash_t hash;
pdf_time_t elem;

/* Create a new hash */
if (pdf_hash_new (NULL, &hash) == PDF_OK)
   @{
      /* Create the element for the hash */
      pdf_time_new (&elem);
      
      /* Add an element to the hash */
      pdf_hash_add_time (hash, "a-key", &elem);

      /* Destroy the hash */
      pdf_hash_destroy (hash);
   @}
@end example
@end table
@end deftypefun



@deftypefun pdf_status_t pdf_hash_add_list (pdf_hash_t @var{table}, const char @var{*key}, const pdf_list_t @var{*elt})

Adds the list @var{elt} with the associated key @var{key} to @var{table}. If @var{key} already exists nothing is done.

@table @strong
@item Parameters
@table @var
@item table
A hash table.
@item key
A valid key string.
@item elt
A pointer to the element being added.
@end table
@item Returns
A pdf status value:
@table @code
@item PDF_OK
The operation succeeded.
@item PDF_ENOMEM
Not enough memory.
@item PDF_EBADDATA
Either @var{table}, @var{key} or @var{elt} is invalid.
@end table
@item Usage example
@example
pdf_hash_t hash;
pdf_list_t elem;

/* Create a new hash */
if (pdf_hash_new (NULL, &hash) == PDF_OK)
   @{
      /* Create the element for the hash */
      pdf_list_new (&elem);
      
      /* Add an element to the hash */
      pdf_hash_add_list (hash, "a-key", &elem);

      /* Destroy the hash */
      pdf_hash_destroy (hash);
   @}
@end example
@end table
@end deftypefun


@deftypefun pdf_status_t pdf_hash_add_hash (pdf_hash_t @var{table}, const char @var{*key}, const pdf_hash_t @var{*elt})

Adds the hash table @var{elt} with the associated key @var{key} to @var{table}. If @var{key} already exists nothing is done.

@table @strong
@item Parameters
@table @var
@item table
A hash table.
@item key
A valid key string.
@item elt
A pointer to the element being added.
@end table
@item Returns
A pdf status value:
@table @code
@item PDF_OK
The operation succeeded.
@item PDF_ENOMEM
Not enough memory.
@item PDF_EBADDATA
Either @var{table}, @var{key} or @var{elt} is invalid.
@end table
@item Usage example
@example
pdf_hash_t hash;
pdf_hash_t elem;

/* Create a new hash */
if (pdf_hash_new (NULL, &hash) == PDF_OK)
   @{
      /* Create the element for the hash */
      pdf_hash_new (&elem);
      
      /* Add an element to the hash */
      pdf_hash_add_hash (hash, "a-key", &elem);

      /* Destroy the hash */
      pdf_hash_destroy (hash);
   @}
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_hash_add_stm (pdf_hash_t @var{table}, const char @var{*key}, const pdf_stm_t @var{*elt})

Adds the stream @var{elt} with the associated key @var{key} to @var{table}. If @var{key} already exists nothing is done.

@table @strong
@item Parameters
@table @var
@item table
A hash table.
@item key
A valid key string.
@item elt
A pointer to the element being added.
@end table
@item Returns
A pdf status value:
@table @code
@item PDF_OK
The operation succeeded.
@item PDF_ENOMEM
Not enough memory.
@item PDF_EBADDATA
Either @var{table}, @var{key} or @var{elt} is invalid.
@end table
@item Usage example
@example
pdf_hash_t hash;
pdf_stm_t elem;
pdf_char_t *buf;

/* Create a new hash */
if (pdf_hash_new (NULL, &hash) == PDF_OK)
   @{
      /* Create the element for the hash */
      buf = pdf_alloc (10);
      pdf_stm_mem_new (buf,
                       10,
                       0, /* Use default cache size */
                       PDF_STM_READ,
                       &stm);

      /* Add the element to the hash */
      pdf_hash_add_hash (hash, "a-key", &elem);

      /* Destroy the hash */
      pdf_hash_destroy (hash);

      /* Destroy the memory buffer */
      pdf_dealloc (buf);
   @}
@end example
@end table
@end deftypefun



@node Lists
@section Lists

This section describes how to work with unsorted and sorted lists. In case you're going to work with a sorted list, you should use the sorted version of each function if it's available. @xref{Working with sorted lists}.

@menu
* List Data Types::
* Creating and Destroying Lists::
* Managing List Properties::
* Searching for List Elements::
* Setting and Getting List Elements::
* Adding and Removing List Elements::
* Working with sorted lists::
* Working with Iterators::
@end menu

@node List Data Types
@subsection List Data Types

@deftp {Data Type} pdf_list_t
A list composed by zero or more nodes.
@end deftp

@deftp {Data Type} pdf_list_node_t
A list node. Each node is able to contain a data structure via a void
npointer.
@end deftp

@deftp {Data Type} pdf_list_iterator_t
A list iterator.
@end deftp

@deftp {Data Type} bool (*pdf_list_element_equals_fn_t) (const void *elt1, const void *elt2)
A function type for comparing list elements equality. Should return PDF_TRUE in case they are equal and PDF_FALSE otherwise.
@end deftp

@deftp {Data Type} void (*pdf_list_element_dispose_fn_t) (const void *elt)
A function type for disposing list elements.
@end deftp

@deftp {Data Type} int (*pdf_list_element_compar_fn_t) (const void *elt1, const void *elt2)
A function type for comparing list elements. Should return an integer less than, equal to, or greater than zero corresponding to whether the first element is considered less than, equal to, or greater than the second element.
@end deftp

@deftp {Data Type} pdf_size_t (*pdf_list_element_hashcode_fn_t) (const void *elt)
A function type for calculating a Hash code given a list element. Should return the corresponding hash code.
@end deftp


@node Creating and Destroying Lists
@subsection Creating and Destroying Lists

@deftypefun pdf_status_t pdf_list_new (pdf_list_element_equals_fn_t @var{equals_fn}, pdf_list_element_dispose_fn_t @var{dispose_fn}, const pdf_bool_t @var{allow_duplicates}, pdf_list_t @var{*list})

Create a new list containing no elements.

@table @strong
@item Parameters
@table @var
@item equals_fn
A function to compare list elements. 
It is used in sort operations.
@item dispose_fn
A function to dispose list elements.
It is used when destroying list elements.
@item allow_duplicates
This parameter indicate if the list is allowed to contain duplicate
elements (elements for which @var{equals_fn} evaluate to
@code{PDF_TRUE}). 
@item list
A pointer to a list where the new one will be saved.
@end table
@item Returns
A status variable:
@table @code
@item PDF_OK
@var{list} contains a new empty list.
@item PDF_EBADDATA
@var{list} points to NULL.
@item PDF_ERROR
An unexpected error or no memory available.
@end table
@item Usage example
@example
pdf_list_t mylist;

if (pdf_list_new (list_element_equal_p, list_element_destroy,  PDF_FALSE,
    &mylist) != PDF_OK)
  @{
    /* manage the error... */
  @}
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_list_destroy (pdf_list_t @var{list})

Destroy a list freeing all used resources. 
The elements of the list are disposed first.

@table @strong
@item Parameters
@table @var
@item list
The list to be destroyed.
@end table
@item Returns
A pdf status value:
@table @code
@item PDF_OK
The operation succeeded.
@end table
@item Usage example
@example
pdf_list_t mylist;

/* ...create `mylist'... */

pdf_list_destroy (mylist);
@end example
@end table
@end deftypefun

@node Managing List Properties
@subsection Managing List Properties

@deftypefun pdf_size_t pdf_list_size (const pdf_list_t @var{list})

Get the number of elements contained into a given list.

@table @strong
@item Parameters
@table @var
@item list
A list.
@end table
@item Returns
The number of elements inside @var{list}.
@item Usage example
@example
pdf_list_t mylist;
pdf_size_t num_elm;

/* ...insert some elements into `mylist'... */
num_elm = pdf_list_size (mylist);
@end example
@end table
@end deftypefun

@node Searching for List Elements
@subsection Searching for List Elements

@deftypefun pdf_status_t pdf_list_search (const pdf_list_t @var{list}, const void* @var{element}, pdf_list_node_t @var{*node})

Search whether an element is already in the list.

@table @strong
@item Parameters
@table @var
@item list
A list.
@item element
The element to search for.
@item node
The searched node if it was found.
@end table
@item Returns
A pdf status value:
@table @code
@item PDF_OK
The operation succeeded.
@item PDF_ENONODE
@var{element} not found.
@item PDF_EBADDATA
Invalid @var{node} pointer.
@end table
@item Usage example
@example
pdf_list_t list;
pdf_list_node_t node;
int elem;

/* Create the list */
if (pdf_list_new (list_element_equal_p,
                  list_element_destroy,
                  PDF_FALSE,  /* Allow duplicates */
                  &list) == PDF_OK)
   @{
      /* Insert an element into the list */
      pdf_list_add_first (list, (void *) &elem, NULL);

      /* Search for that element into the list */
      if (pdf_list_search (list, (void *) &elem, &node) == PDF_OK)
         @{
            /* The program should reach this place */
         @}
   @}
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_list_search_from (const pdf_list_t @var{list}, const pdf_size_t @var{start_index}, const void* @var{element}, pdf_list_node_t @var{*node})

Search whether an element is already in the list, at a position >= @var{start_index}.

@table @strong
@item Parameters
@table @var
@item list
A list.
@item start_index
Index indicating the begin of the search.
@item node
The searched node if it was found.
@end table
@item Returns
A pdf status value:
@table @code
@item PDF_OK
The operation succeeded.
@item PDF_ENONODE
@var{element} not found.
@item PDF_EBADDATA
Invalid @var{node} pointer.
@item PDF_EINVRANGE
@var{start_index} is greater than the list size or less than 0.
@end table
@item Usage example
@example
pdf_list_t list;
pdf_list_node_t node;
int elem1;
int elem2;
int elem3;

if (pdf_list_new (list_element_equal_p,
                  list_element_destroy,
                  PDF_FALSE,  /* Allow duplicates */
                  &list) == PDF_OK)
   @{
      /* Insert several elements into the list */
      pdf_list_add_last (list, (void *) &elem1, NULL);
      pdf_list_add_last (list, (void *) &elem2, NULL);
      pdf_list_add_last (list, (void *) &elem3, NULL);


      /* Search for an element into the list */
      if (pdf_list_search_from (list,
                                (void *) &elem1,
                                1,
                                &node) == PDF_OK)
         @{
            /* The program should never reach this place, since 
               elem1 occupies the first position (0) in the list */
         @}
   @}
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_list_search_from_to (const pdf_list_t @var{list}, const pdf_size_t @var{start_index}, const pdf_size_t @var{end_index}, const void* @var{element}, pdf_list_node_t @var{*node})

Search whether an element is already in the list, at a position >=
@var{start_index} and < @var{end_index}.

@table @strong
@item Parameters
@table @var
@item list
A list.
@item start_index
Index to the first list position to be searched.
@item end_index
Index to the last list position to be searched.
@item element
The element to search for.
@item node
The seached node if it was found.
@end table
@item Returns
A pdf status value:
@table @code
@item PDF_OK
The operation succeeded.
@item PDF_ENONODE
@var{element} not found.
@item PDF_EBADDATA
Invalid @var{node} pointer.
@item PDF_EINVRANGE
@var{start_index} or @var{end_index} is greater than the list size or less than 0.
@end table
@item Usage example
@example
pdf_list_t list;
pdf_list_node_t node;
int elem1;
int elem2;
int elem3;
int elem4;

if (pdf_list_new (list_element_equal_p,
                  list_element_destroy,
                  PDF_FALSE,  /* Allow duplicates */
                  &list) == PDF_OK)
   @{
      /* Insert several elements into the list */
      pdf_list_add_last (list, (void *) &elem1, NULL);
      pdf_list_add_last (list, (void *) &elem2, NULL);
      pdf_list_add_last (list, (void *) &elem3, NULL);
      pdf_list_add_last (list, (void *) &elem4, NULL);

      /* Search for an element into the list */
      if (pdf_list_search_from_to (list,
                                   (void *) &elem4,
                                   1, 3,
                                   &node) == PDF_OK)
         @{
            /* The program should never reach this place, since 
               elem4 occupies the last position (3) in the list */
         @}
   @}
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_list_next_node (const pdf_list_t @var{list}, const pdf_list_node_t @var{node}, pdf_list_node_t @var{*next})

Return the node immediately after the given node in the list.

@table @strong
@item Parameters
@table @var
@item list
A list.
@item node
A node contained in @var{list}.
@item prev
A pointer where the next node will be saved.
@end table
@item Returns
A pdf status value:
@table @code
@item PDF_OK
The operation succeeded.
@item PDF_ENONODE
Next node not found.
@item PDF_EBADDATA
Invalid @var{next} pointer.
@end table
@item Usage example
@example
pdf_list_t list;
pdf_list_node_t node_first;
pdf_list_node_t node_second;
int elem1;
int elem2;

if (pdf_list_new (list_element_equal_p,
                  list_element_destroy,
                  PDF_FALSE,  /* Allow duplicates */
                  &list) == PDF_OK)
   @{
      /* Insert several elements into the list */
      pdf_list_add_last (list, (void *) &elem1, NULL);
      pdf_list_add_last (list, (void *) &elem2, NULL);

      /* Get the node containing "elem1" */
      pdf_list_search (list, (void *) &elem1, &node_first);

      /* Get the next node in the list */
      pdf_list_next_node (list, first_node, &node_second);

      /* Now node_second is the node containing elem2 */
   @}
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_list_previous_node (const pdf_list_t @var{list}, const pdf_list_node_t @var{node}, pdf_list_node_t @var{*prev})

Return the node immediately before the given node in the list.

@table @strong
@item Parameters
@table @var
@item list
A list.
@item node
A node contained in @var{list}.
@item prev
A pointer where the previous node will be saved.
@end table
@item Returns
A pdf status value:
@table @code
@item PDF_OK
The operation succeeded.
@item PDF_ENONODE
Previous node not found.
@item PDF_EBADDATA
Invalid @var{prev} pointer.
@end table
@item Usage example
@example
pdf_list_t list;
pdf_list_node_t node_first;
pdf_list_node_t node_second;
int elem1;
int elem2;

if (pdf_list_new (list_element_equal_p,
                  list_element_destroy,
                  PDF_FALSE,  /* Allow duplicates */
                  &list) == PDF_OK)
   @{
      /* Insert several elements into the list */
      pdf_list_add_last (list, (void *) &elem1, NULL);
      pdf_list_add_last (list, (void *) &elem2, NULL);

      /* Get the node containing "elem2" */
      pdf_list_search (list, (void *) &elem2, &node_second);

      /* Get the previous node in the list */
      pdf_list_previous_node (list, second_node, &node_first);

      /* Now node_first is the node containing elem2 */
   @}
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_list_indexof (const pdf_list_t @var{list}, const void* @var{element}, pdf_size_t @var{*position})

Search whether an element is already in the list.

@table @strong
@item Parameters
@table @var
@item list
A list.
@item element
A pointer to user data.
@item position
A pointer where the element position will be saved.
@end table
@item Returns
A pdf status value:
@table @code
@item PDF_OK
The operation succeeded.
@item PDF_ENONODE
@var{element} not found.
@item PDF_EBADDATA
Invalid or NULL pointers.
@end table
@item Usage Example
@example
pdf_list_t list;
pdf_list_node_t node_first;
pdf_list_node_t node_second;
int elem1;
int elem2;
pdf_size_t index_of_elem2;

if (pdf_list_new (list_element_equal_p,
                  list_element_destroy,
                  PDF_FALSE,  /* Allow duplicates */
                  &list) == PDF_OK)
   @{
      /* Insert several elements into the list */
      pdf_list_add_last (list, (void *) &elem1, NULL);
      pdf_list_add_last (list, (void *) &elem2, NULL);

      /* Get the index of elem2 */
      pdf_list_indexof (list, (void *) &elem2, &size_of_elem2);

      /* Now size_of_elem2 contains 1 */
   @}
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_list_indexof_from (const pdf_list_t @var{list}, const pdf_size_t @var{start_index}, const void* @var{element}, pdf_size_t @var{*position})

Search whether an element is already in the list, at a position >= @var{start_index}.

@table @strong
@item Parameters
@table @var
@item list
A list.
@item start_index
An index to a position in @var{list}.
@item element
The element to search for.
@item position
A pointer where the element position will be saved.
@end table
@item Returns
A pdf status value:
@table @code
@item PDF_OK
The operation succeeded.
@item PDF_ENONODE
@var{element} not found.
@item PDF_EBADDATA
Invalid or NULL pointers.
@item PDF_EINVRANGE
@var{start_index} or @var{end_index} is greater than the list size or less than 0.
@end table
@item Usage example
@example
pdf_list_t list;
pdf_list_node_t node_first;
pdf_list_node_t node_second;
int elem1;
int elem2;
int elem3;
int elem4;
pdf_size_t index_of_elem1;

if (pdf_list_new (list_element_equal_p,
                  list_element_destroy,
                  PDF_FALSE,  /* Allow duplicates */
                  &list) == PDF_OK)
   @{
      /* Insert several elements into the list */
      pdf_list_add_last (list, (void *) &elem1, NULL);
      pdf_list_add_last (list, (void *) &elem2, NULL);
      pdf_list_add_last (list, (void *) &elem3, NULL);
      pdf_list_add_last (list, (void *) &elem4, NULL);

      /* Get the index of elem1 */
      if (pdf_list_indexof_from (list,
                                 1, 
                                 (void *) &elem1,
                                 &size_of_elem1) == PDF_ENONODE)
         @{
            /* The program reaches this point, since elem1 occupies
               the first position into the list */
         @}
   @}
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_list_indexof_from_to (const pdf_list_t @var{list}, const pdf_size_t @var{start_index}, const pdf_size_t @var{end_index}, const void* @var{element}, pdf_size_t @var{*position})

Search whether an element is already in the list, at a position >= @var{start_index} and < @var{end_index}.

@table @strong
@item Parameters
@table @var
@item list
A list.
@item start_index
A position in @var{list}.
@item end_index
A position in @var{list}.
@item element
A pointer to some user data.
@item position
A pointer where the element position will be saved.
@end table
@item Returns
A pdf status value:
@table @code
@item PDF_OK
The operation succeeded.
@item PDF_ENONODE
@var{element} not found.
@item PDF_EBADDATA
Invalid or NULL pointers.
@item PDF_EINVRANGE
@var{start_index} or @var{end_index} is greater than the list size or less than 0.
@end table
@item Usage example
@example
pdf_list_t list;
pdf_list_node_t node_first;
pdf_list_node_t node_second;
int elem1;
int elem2;
int elem3;
int elem4;
pdf_size_t index_of_elem4;

if (pdf_list_new (list_element_equal_p,
                  list_element_destroy,
                  PDF_FALSE,  /* Allow duplicates */
                  &list) == PDF_OK)
   @{
      /* Insert several elements into the list */
      pdf_list_add_last (list, (void *) &elem1, NULL);
      pdf_list_add_last (list, (void *) &elem2, NULL);
      pdf_list_add_last (list, (void *) &elem3, NULL);
      pdf_list_add_last (list, (void *) &elem4, NULL);

      /* Get the index of elem4 */
      if (pdf_list_indexof_from_to (list,
                                    1, 3,
                                    (void *) &elem1,
                                    &size_of_elem4) == PDF_ENONODE)
         @{
            /* The program reaches this point, since elem4 occupies
               the last position (3) into the list */
         @}
   @}
@end example
@end table
@end deftypefun

@node Setting and Getting List Elements
@subsection Setting and Getting List Elements

@deftypefun {void *} pdf_list_node_value (const pdf_list_t @var{list}, const pdf_list_node_t @var{node})

Get the element value represented by a list node.

@table @strong
@item Parameters
@table @var
@item list
A list.
@item node
A node of @var{list}.
@end table
@item Returns
The element value represented by @var{node}.
@item Usage example
@example
pdf_list_t list;
pdf_list_node_t node;
int elem1;
int *pointer_to_elem1;

if (pdf_list_new (list_element_equal_p,
                  list_element_destroy,
                  PDF_FALSE,  /* Allow duplicates */
                  &list) == PDF_OK)
   @{
      /* Insert an element into the list */
      pdf_list_add_last (list, (void *) &elem1, NULL);

      /* Get the node of the element of the list */
      pdf_list_search (list, (void *) &elem1, &node);

      /* Get the value out of the node */
      pointer_to_elem1 = (int *) pdf_list_node_value (list, node);
   @}
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_list_get_at (const pdf_list_t @var{list}, const pdf_size_t @var{position}, const void @var{**value})

Get the element at a given position in the list.

@table @strong
@item Parameters
@table @var
@item list
A list.
@item position
A position in @var{list}. 
Must be @code{>= 0} and @code{< pdf_list_size (list)}.
@item value
A pointer to which the element will be saved.
@end table
@item Returns
A pdf status value:
@table @code
@item PDF_OK
The operation succeeded.
@item PDF_EINVRANGE
Invalid @var{position}
@item PDF_EBADDATA
Invalid @var{value} pointer.
@end table
@item Usage example
@example
pdf_list_t list;
int elem1;
int *pointer_to_elem1;

if (pdf_list_new (list_element_equal_p,
                  list_element_destroy,
                  PDF_FALSE,  /* Allow duplicates */
                  &list) == PDF_OK)
   @{
      /* Insert an element into the list */
      pdf_list_add_last (list, (void *) &elem1, NULL);

      /* Get the first element of the list */
      pdf_list_get_at (list, 0, &pointer_to_elem_1);
   @}
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_list_set_at (pdf_list_t @var{list}, const pdf_size_t @var{position}, const void* @var{element}, pdf_list_node_t @var{*node})

Replace the element at a given position in a list.

@table @strong
@item Parameters
@table @var
@item list
A list.
@item position
A position in @var{list}.
Must be @code{>= 0} and @code{< pdf_list_size (list)}.
@item element
The new element.
@item node
A pointer to save the node containing the replaced element or NULL.
@end table
@item Returns
A pdf status value:
@table @code
@item PDF_OK
The operation succeeded.
@item PDF_EINVRANGE
Invalid @var{position} range.
@item PDF_BADDATA
The list does not allow duplicated values and already contain
@var{element}.
@end table
@item Usage example
@example
pdf_list_t list;
pdf_u32_t a;
pdf_u32_t b;
pdf_u32_t c;
pdf_u32_t x;

/* Create a list of integers */
if (pdf_list_new (NULL,
                  NULL,
                  PDF_FALSE, /* Allow duplicates */
                  &list) == PDF_OK)
   @{
      /* Insert the elements into the list */
      pdf_list_add_last (list, (void *) &a, NULL);
      pdf_list_add_last (list, (void *) &b, NULL);
      pdf_list_add_last (list, (void *) &c, NULL);

      /* Now the list contains abc */

      pdf_list_set_at (list, 1, (void *) &x, NULL);

      /* Now the list contains axc */
   @}
@end example
@end table
@end deftypefun

@node Adding and Removing List Elements
@subsection Adding and Removing List Elements

@deftypefun pdf_status_t pdf_list_add_first (pdf_list_t @var{list}, const void* @var{element}, pdf_list_node_t *@var{node})

Add an element as the first element of the list. If @var{node} is not
NULL then a reference to the newly created node is copied to it.

@table @strong
@item Parameters
@table @var
@item list
A list.
@item element
A pointer to the user data to be stored as a list element.
@item node
If non NULL, a list node variable used to contain the added element.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The element was inserted successfully.
@item PDF_EBADDATA
The list does not allow duplicated values and already contain
@var{element}.
@end table
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_list_add_last (pdf_list_t @var{list}, const void* @var{element}, pdf_list_node_t *@var{node})

Add an element as the last element of the list. If @var{node} is not
NULL then a reference to the newly created node is copied to it.

@table @strong
@item Parameters
@table @var
@item list
A list.
@item element
A pointer to the user data to be stored as a list element.
@item node
If non NULL, a list node variable used to contain the added element.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The element was inserted successfully.
@item PDF_EBADDATA
The list does not allow duplicated values and already contain
@var{element}.
@end table
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_list_add_at (pdf_list_t @var{list}, const pdf_size_t @var{position}, const void* @var{element}, pdf_list_node_t @var{*node})

Add an element at a given position in the list.

@table @strong
@item Parameters
@table @var
@item list
A list.
@item position
A position in the list.
Should be @code{>= 0} and @code{<= pdf_list_size (list)}.
@item element
A pointer to the user data to be stored as a list element.
@item node
A pointer to the node where the given element was stored or NULL.
@end table
@item Returns
A pdf status value:
@table @code
@item PDF_OK
The operation succeeded.
@item PDF_EINVRANGE
Invalid range of given @var{position}.
@item PDF_BADDATA
The list does not allow duplicated values and already contain
@var{element}.
@end table
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_list_remove_node (pdf_list_t @var{list}, const pdf_list_node_t @var{node})

Remove an element from the list.

@table @strong
@item Parameters
@table @var
@item list
A list.
@item node
The node to be removed.
@end table
@item Returns
A pdf status value:
@table @code
@item PDF_OK
@end table
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_list_remove_at (pdf_list_t @var{list}, const pdf_size_t @var{position})

Remove an element at a given position from the list.

@table @strong
@item Parameters
@table @var
@item list
A list.
@item position
A position in @var{list}.
Must be @code{>= 0} and @code{< pdf_list_size (list)}.
@end table
@item Returns
A pdf status value:
@table @code
@item PDF_OK
The operation succeeded.
@item PDF_EINVRANGE
Invalid @var{position} range.
@end table
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_list_remove (pdf_list_t @var{list}, const void * @var{element})

Search and remove an element from the lsit.

@table @strong
@item Parameters
@table @var
@item list
A list.
@item element
The element to be removed.
@end table
@item Returns
A pdf status value:
@table @code
@item PDF_OK
@var{element} was found in the list and was removed.
@item PDF_EBADDATA
@var{element} was not found in the list.
@end table
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun


@node Working with sorted lists
@subsection Working with sorted lists

@deftypefun pdf_status_t pdf_list_sorted_add (pdf_list_t @var{list}, pdf_list_element_compar_fn_t @var{compar_fn}, const void* @var{element}, pdf_list_node_t @var{* element_node})

Add an element to the list.

@table @strong
@item Parameters
@table @var
@item list
A list.
@item compar_fn
A comparision function.
@item element
A pointer to the user data to be stored as a list element.
@item element_node
A pointer where the added element node will be saved. Can be NULL.
@end table
@item Returns
A pdf status value:
@table @code
@item PDF_OK
The operation succeeded.
@item PDF_EBADDATA
Invalid @var{compar_fn} pointer.
@end table
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_list_sorted_remove (pdf_list_t @var{list}, pdf_list_element_compar_fn_t @var{compar_fn}, const void * @var{element})

Search and remove an element from the list.

@table @strong
@item Parameters
@table @var
@item list
A list.
@item compar_fn
A comparision function.
@item element
The element to be removed.
@end table
@item Returns
A pdf status value:
@table @code
@item PDF_OK
@var{element} was found in the list and was removed.
@item PDF_ENONODE
@var{element} was not found in the list.
@item PDF_EBADDATA
Invalid @var{compar_fn}.
@end table
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_list_sorted_search (const pdf_list_t @var{list}, pdf_list_element_compar_fn_t @var{compar_fn}, const void* @var{element}, pdf_list_node_t @var{*node})

Search whether an element is already in the list.

@table @strong
@item Parameters
@table @var
@item list
A list.
@item compar_fn
A comparision function.
@item element
The element to search for.
@item node
The searched node if it was found.
@end table
@item Returns
A pdf status value:
@table @code
@item PDF_OK
The operation succeeded.
@item PDF_ENONODE
@var{element} not found.
@item PDF_EBADDATA
Invalid @var{node} pointer or @var{compar_fn}.
@end table
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_list_sorted_search_from_to (const pdf_list_t @var{list}, pdf_list_element_compar_fn_t @var{compar_fn}, const pdf_size_t @var{start_index}, const pdf_size_t @var{end_index}, const void* @var{element}, pdf_list_node_t @var{*node})

Search whether an element is already in the list, at a position >=
@var{start_index} and < @var{end_index}.

@table @strong
@item Parameters
@table @var
@item list
A list.
@item compar_fn
A comparision function.
@item start_index
Index to the first list position to be searched.
@item end_index
Index to the last list position to be searched.
@item element
The element to search for.
@item node
The seached node if it was found.
@end table
@item Returns
A pdf status value:
@table @code
@item PDF_OK
The operation succeeded.
@item PDF_ENONODE
@var{element} not found.
@item PDF_EBADDATA
Invalid @var{node} pointer or @var{compar_fn}.
@item PDF_EINVRANGE
@var{start_index} or @var{end_index} is greater than the list size or less than 0.
@end table
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_list_sorted_indexof (const pdf_list_t @var{list}, pdf_list_element_compar_fn_t @var{compar_fn}, const void* @var{element}, pdf_size_t @var{*position})

Search whether an element is already in the list.

@table @strong
@item Parameters
@table @var
@item list
A list.
@item compar_fn
A comparision function.
@item element
A pointer to user data.
@item position
A pointer where the element position will be saved.
@end table
@item Returns
A pdf status value:
@table @code
@item PDF_OK
The operation succeeded.
@item PDF_ENONODE
@var{element} not found.
@item PDF_EBADDATA
Invalid or NULL pointers.
@end table
@item Usage Example
@example
XXX
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_list_sorted_indexof_from_to (const pdf_list_t @var{list}, pdf_list_element_compar_fn_t @var{compar_fn}, const pdf_size_t @var{start_index}, const pdf_size_t @var{end_index}, const void* @var{element}, pdf_size_t @var{*position})

Search whether an element is already in the list, at a position >= @var{start_index} and < @var{end_index}.

@table @strong
@item Parameters
@table @var
@item list
A list.
@item compar_fn
A comparision function.
@item start_index
A position in @var{list}.
@item end_index
A position in @var{list}.
@item element
A pointer to some user data.
@item position
A pointer where the element position will be saved.
@end table
@item Returns
A pdf status value:
@table @code
@item PDF_OK
The operation succeeded.
@item PDF_ENONODE
@var{element} not found.
@item PDF_EBADDATA
Invalid or NULL pointers.
@item PDF_EINVRANGE
@var{start_index} or @var{end_index} is greater than the list size or less than 0.
@end table
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun


@node Working with Iterators
@subsection Working with Iterators

@deftypefun pdf_status_t pdf_list_iterator (const pdf_list_t @var{list}, pdf_list_iterator_t @var{*itr})

Create an iterator traversing a list.

The list contents must not be modified while the iterator is in use,
except for replacing or removing the last returned element.

@table @strong
@item Parameters
@table @var
@item list
A list.
@item itr
A pointer to where the new iterator will be saved.
@end table
@item Returns
A status variable:
@table @code
@item PDF_OK
@var{itr} contains a new iterator for @var{list}.
@item PDF_ENOMEM
There is no memory available for a new iterator.
@item PDF_EBADDATA
@var{itr} points to NULL.
@end table
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_list_iterator_from_to (const pdf_list_t @var{list}, const pdf_size_t @var{start_index}, const pdf_size_t @var{end_index}, pdf_list_iterator_t @var{*itr})

Create an iterator traversing the element with indices @code{i},
@code{start_index <= i < end_index}, of a list.

The list contents must not be modified while the iterator is in use,
except for replacing or removing the last returned element.

@table @strong
@item Parameters
@table @var
@item list
A list.
@item start_index
A position in @var{list}.
@item end_index
A position in @var{list}.
@item itr
A pointer to an iterator where the new one will be saved.
@end table
@item Returns
A status variable:
@table @code
@item PDF_OK
@var{itr} contains a new iterator for @var{list} pointing to @var{start_index}.
@item PDF_ENOMEM
There is no memory available for a new iterator.
@item PDF_EINVRANGE
@var{start_index} or @var{end_index} is greater than the list size or less than 0.
@item PDF_EBADDATA
@var{itr} points to NULL.
@end table
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_list_iterator_next (pdf_list_iterator_t *@var{iterator}, const void **@var{element_pointer}, pdf_list_node_t *@var{node_pointer})

If there is a next element, store the next element in
@var{*element_pointer}, store its node in @var{*node_pointer} if it is
non-@code{NULL}, and advance the iterator.

@table @strong
@item Parameters
@table @var
@item iterator
A list iterator.
@item element_pointer
A pointer to a pointer to user data.
@item node_pointer
A pointer to a list node.
@end table
@item Returns
A pdf status value:
@table @code
@item PDF_OK
There is a next element.
@item PDF_ERROR
There is not a next element.
@end table
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_list_iterator_free (pdf_list_iterator_t *@var{iterator})

Free an iterator releasing any used resource.

@table @strong
@item Parameters
@table @var
@item iterator
A list iterator.
@end table
@item Returns
A pdf status value:
@table @code
@item PDF_OK
@end table
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun


@node Filtered Streams
@section Filtered Streams

This module provides read/write streams of data to memory buffers and
open files adding the following functionality:

@itemize @minus
@item Filtering.
@item Buffering.
@end itemize

Several streams can be created to operate in the same open file. This
provides a convenient access to files with several parts requiring
different filters to read or write its contents.

Filters (such as the PDF standard ones) are supported for both reading
and writing. Many filters may be used in a single stream (those
filters are applied in an order when writing and in the inverse order
when reading).

The file streams maintain a buffer for both reading and writing. The
size of the buffer is specified by the client in creation time. This
is used, for example, to provide efficient character-based I/O.

Note that the streams operating in memory buffers do not provide
buffering.

@menu
* Stream Types::
* Creating and Destroying Streams::
* Managing the Filter Chain::
* Reading and Writing Data::
* Stream Positioning::
@end menu

@node Stream Types
@subsection Stream Types

@deftp {Data Type} pdf_stm_t
A stm variable.
@end deftp

@deftp {Data Type} {enum pdf_stm_mode_e}
The operation mode of a stm object.

@table @code
@item PDF_STM_READ
The stm will be used to read data from the open file or memory buffer.
@item PDF_STM_WRITE
The stm will be used to write data into the open file or memory buffer.
@end table
@end deftp

@deftp {Data Type} {enum pdf_stm_filter_type_e}
The several types of supported stream filters.

@table @code
@item PDF_STM_FILTER_AHEX_ENC
ASCII Hex encoder.
@item PDF_STM_FILTER_AHEX_DEC
ASCII Hex decoder.
@item PDF_STM_FILTER_RL_ENC
Run-Length encoder.
@item PDF_STM_FILTER_RL_DEC
Run-Length decoder.
@item PDF_STM_FILTER_FLATE_ENC
Flate (zlib) encoder.
@item PDF_STM_FILTER_FLATE_DEC
Flate (zlib) decoder.
@item PDF_STM_FILTER_JBIG2_DEC
JBIG2 decoder.
@end table
@end deftp

@node Creating and Destroying Streams
@subsection Creating and Destroying Streams

@deftypefun pdf_status_t pdf_stm_file_new (pdf_fsys_file_t @var{file}, pdf_off_t @var{offset}, pdf_size_t @var{cache_size}, enum pdf_stm_mode_e @var{mode}, pdf_stm_t *@var{stm})

Create a new stream operating in a given open file. 

@table @strong
@item Parameters
@table @var
@item file
An open file.
@item offset
Position into the file.
@item cache_size
The desired size for the stream cache, measured in octects. If it is
@code{0} then the default size (4kb) is used.
@item mode
The operation mode for the stream.
@item stm
A pointer to the stm to be created.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The stream object was successfully created.
@item PDF_ERROR
There was an error and the stream was not created.
@end table
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_stm_mem_new (pdf_char_t *@var{buffer}, pdf_size_t @var{size}, pdf_size_t @var{cache_size}, enum pdf_stm_mode_e @var{mode}, pdf_stm_t *@var{stm})

Create a new stream operating in a memory buffer.

@table @strong
@item Parameters
@table @var
@item buffer
Memory buffer where the information will be written-to or readed-from.
@item size
The desired size for the memory buffer, measured in octects.
@item cache_size
The desired size for the stream cache, measured in octects. If it is
@code{0} then the default size (4kb) is used.
@item mode
The operation mode for the stream.
@item stm
A pointer to the stm to be created.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The stream was successfully created.
@item PDF_ERROR
There was an error and the stream was not created.
@end table
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_stm_destroy (pdf_stm_t @var{stm})

Destroy a stream freeing all the used resources.

@table @strong
@item Parameters
@table @var
@item stm
A stream.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The stream was successfully destroyed.
@item PDF_ERROR
There was an error destroying the stream.
@end table
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@node Managing the Filter Chain
@subsection Managing the Filter Chain

The following functions can be used to build the filter chain of a
given stream.

@deftypefun pdf_status_t pdf_stm_install_filter (pdf_stm_t @var{stm}, enum pdf_stm_filter_type_e @var{filter_type}, pdf_hash_t @var{filter_params})

Install a fiter in the filter chain of a stream.

@table @strong
@item Parameters
@table @var
@item stm
A stream.
@item filter_type
The type of the filter to be installed.
@item filter_params
Hash table containing a set of key-value pairs with the parameters for
the filter.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The filter was successfully installed in the stream.
@item PDF_ERROR
There was an error and the filter was not installed in the stream.
@end table
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@node Reading and Writing Data
@subsection Reading and Writing Data

@deftypefun pdf_size_t pdf_stm_read (pdf_stm_t @var{stm}, pdf_char_t *@var{buf}, pdf_size_t @var{bytes})

Read a chunk of data from a given stream.

@table @strong
@item Parameters
@table @var
@item stm
A stream.
@item buf
The buffer to hold the read data.
@item bytes
The number of octects to read.
@end table
@item Returns
A PDF size value containing the number of octects actually readed. If
the returned value is less than @var{bytes} then an end of file
condition occurred.
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@deftypefun pdf_size_t pdf_stm_write (pdf_stm_t @var{stm}, pdf_char_t *@var{buf}, pdf_size_t @var{bytes})

Write a chunk of data into a given stream.

@table @strong
@item Parameters
@table @var
@item stm
A stream.
@item buf
The buffer containing the written information.
@item bytes
The number of bytes to write into the stream.
@end table
@item Returns
A PDF size value containing the number of octects actually readed. If
the returned value is less than @code{bytes} then a
disk full condition has occured.
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@deftypefun pdf_u32_t pdf_stm_read_char (pdf_stm_t stm)

Read a character from a given stream.

@table @strong
@item Parameters
@table @var
@item stm
A stream.
@end table
@item Returns
An unsigned integer containing @code{PDF_EOF} or the readed character
code.
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@deftypefun pdf_u32_t pdf_stm_peek_char (pdf_stm_t stm)

Peek a character from a given stream.

@table @strong
@item Parameters
@table @var
@item stm
A stream.
@end table
@item Returns
An unsigned integer containing @code{PDF_EOF} or the peeked character
code.
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@deftypefun pdf_size_t pdf_stm_flush (pdf_stm_t @var{stm}, pdf_bool_t @var{finish_p})

Flush any pending writing data in a given stream.

If @var{finish_p} equals to @code{PDF_TRUE} then the filters in the
stream's filter chain are tell to generate any remaining output.

@table @strong
@item Parameters
@table @var
@item stm
A stream.
@item finish_p
A boolean value indicating whether to finalize the filter chain.
@end table
@item Returns
A PDF size value containing the number of octects that has been
flushed. May be @code{0}.
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@node Stream Positioning
@subsection Stream Positioning

@deftypefun pdf_off_t pdf_stm_seek (pdf_stm_t @var{stm}, pdf_off_t @var{pos})

Seek into a given stream.

@table @strong
@item Parameters
@table @var
@item stm
A stream.
@item pos
The position to seek, measured in octects from the beginning of the
stream.
@end table
@item Returns
The new position of the stream read/write pointer. If it is equal to
the current position then there was an error.
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@deftypefun pdf_off_t pdf_stm_tell (pdf_stm_t @var{stm})

Get the current position of the read/write pointer of a stream.

@table @strong
@item Parameters
@table @var
@item stm
A stream.
@end table
@item Returns
The current position (measured in octets from the beginning of the
stream) of the read/write pointer.
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@node Floating Point Maths
@section Floating Point Maths

@menu
* Floating Point Types::
* Number Conversion Routines::
* Geometry Routines::
* Creation and Destruction of Functions::
* Evaluation of Functions::
@end menu

@node Floating Point Types
@subsection Floating Point Types

@deftp {Data Type} pdf_real_t
An opaque type representing a floating-point number.
@end deftp

@deftp {Data Type} {struct pdf_point_s}

This structure represents a single point. The coordinates of the point
are made using floating point numbers.

@table @code
@item pdf_real_t h
Horizontal coordinate.
@item pdf_real_t v
Vertical coordinate.
@end table
@end deftp

@deftp {Data Type} pdf_point_t

A pointer to a @code{pdf_point_s} structure.

@end deftp

@deftp {Data Type} {struct pdf_matrix_s}

This structure represents a 3x3 matrix representing an affine
transformation.

@table @code
@item pdf_real_t a
@item pdf_real_t b
The first row of the matrix is @code{a b 0}.
@item pdf_real_t c
@item pdf_real_t d
The second row of the matrix is @code{c d 0}.
@item pdf_real_t h
@item pdf_real_t v
The third row of the matrix is @code{h v 1}.
@end table
@end deftp

@deftp {Data Type} pdf_matrix_t

A pointer to a @code{pdf_matrix_s} structure.

@end deftp


@deftp {Data Type} {struct pdf_rect_s}

This structure represents a rectangle. It is composed by the
coordinates for its four sides.

The rectangle sides should be horizontal and vertical and opposite
sides should be parallel.

@table @code
@item pdf_real_t left
@code{x} coordinate for the left points.
@item pdf_real_t top
@code{y} coordinate for the upper points.
@item pdf_real_t right
@code{x} coordinate for the right points.
@item pdf_real_t bottom
@code{y} coordinate for the bottom points.
@end table
@end deftp

@deftp {Data Type} pdf_rect_t

A pointer to a @code{pdf_rect_s} structure.

@end deftp

@deftp {Data Type} {struct pdf_quad_s}
This structure represents a quadrilateral. It is composed by four
corners (floating-point points).
@table @code
@item pdf_point_t tl
Top-left point.
@item pdf_point_t tr
Top-right point.
@item pdf_point_t bl
Bottom-left point.
@item pdf_point_t br
Bottom-right point.
@end table
@end deftp

@deftp {Data Type} pdf_quad_t

A pointer to a @code{pdf_quad_t} structure.

@end deftp

@deftp {Data Type} pdf_fp_func_t

Opaque type representing a Floating Point function.

@end deftp

@node Number Conversion Routines
@subsection Number Conversion Routines

@deftypefun pdf_status_t pdf_fp_string_to_real (const pdf_char_t *@var{string}, pdf_real_t *@var{result})

Convert a numeric string representation to a @code{pdf_real_t}
value. The string is scanned from left to right, taking into account
the data before the first invalid character.

@table @strong
@item Parameters
@table @var
@item string
A @code{NULL} terminated string.
@item result
The real variable where the result is stored.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The conversion was successful.
@item PDF_ERROR
No recognizable real value was found in the string.
@end table
@item Usage example
@example
pdf_real_t real;
pdf_char_t str[5];

strcpy (str, "1");
str[1] = 0;
pdf_fp_string_to_real (str, &real);
/* real now contains 1.0 */

strcpy (str, "1.0");
str[3] = 0;
pdf_fp_string_to_real (str, &real);
/* real now contains 1.0 */


strcpy (str, "1.0X");
str[4] = 0;
pdf_fp_string_to_real (str, &real);
/* real now contains 1.0 */

strcpy (str, "foo");
str[3] = 0;
if (pdf_fp_string_to_real (str, &real) == PDF_ERROR)
@{
   /* The code reach this point */
@}
@end example
@end table
@end deftypefun


@deftypefun pdf_status_t pdf_fp_real_to_string (pdf_real_t @var{real}, pdf_char_t *@var{s}, pdf_size_t @var{max_length}, pdf_u32_t @var{precision})

Get a textual representation of a  @code{pdf_real_t} value.

@table @strong
@item Parameters
@table @var
@item real
The number to convert.
@item s
The string where to store the textual representation of
@var{real}. Note that this function adds a '\0' to the end of the
textual representation.
@item max_length
The maximum number of characters that @var{s} may contain.
@item precision
The number of decimal digits to include in the textual representation.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
A textual representation of @var{real} was successfully written in
@var{s}.
@item PDF_ERROR
An error prevented to perform the conversion.
@end table
@item Usage example
@example
pdf_real_t real;
pdf_char_t s[9];

real = 1.123456;

pdf_fp_real_to_string (real, s, 9, 6);
/* s contains "1.123456" */

pdf_fp_real_to_string (real, s, 9, 3);
/* s contains "1.123" */

if (pdf_fp_real_to_string (real, s, 4, 3) == PDF_ERROR)
@{
    /* The code reach this point: not enough space in the string
       to hold the textual representation of the number with
       the specified precision */
@}
@end example
@end table
@end deftypefun


@node Geometry Routines
@subsection Geometry Routines

@deftypefun pdf_status_t pdf_fp_matrix_concat (pdf_matrix_t @var{result}, pdf_matrix_t @var{matrix_1}, pdf_matrix_t @var{matrix_2})

Multiplies two matrices.

@table @strong
@item Parameters
@item result
Pointer to the matrix that will be filled with the result. It may be
a copy of @var{matrix_1} or @var{matrix_2}.
@item matrix_1
The first matrix to multiply.
@item matrix_2
The second matrix to multiply.
@item Returns
A PDF status code:
@table @code
@item PDF_OK
The operation succeeded.
@item PDF_ERROR
There was an error performing the execution.
@end table
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_fp_matrix_invert (pdf_matrix_t @var{result}, pdf_matrix_t @var{matrix})

Calculate the inverse of a matrix.

@table @strong
@item Parameters
@table @var
@item result
A pointer to a matrix that will store the inverted matrix. This
parameters can be a copy of @var{matrix}.
@item matrix
A pointer to a matrix used to calculate the inverse.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The operation succeeded.
@item PDF_ERROR
An error prevented the operation to finish.
@end table
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@deftypefun pdf_fp_matrix_transform (pdf_point_t @var{result}, const pdf_matrix_t @var{matrix}, const pdf_point_t @var{point})

Transform a point through a matrix.

@table @strong
@item Parameters
@table @var
@item result
A pointer to a point to hold the result. This can be a copy of
@var{point}.
@item matrix
A pointer to the matrix used to perform the transformation.
@item point
A pointer to the point to transform.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The operation suceeded.
@item PDF_ERROR
An error prevented the operation to finish.
@end table
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@deftypefun pdf_fp_matrix_transform_rect (pdf_rect_t @var{result}, const pdf_matrix_t @var{matrix}, const pdf_rect_t @var{rect})

Transform a rectangle through a matrix.

@table @strong
@item Parameters
@table @var
@item result
A pointer to a rectangle to hold the result. This can be a copy of
@var{rect}.
@item matrix
A pointer to the matrix used to perform the transformation.
@item point
A pointer to the rectangle to transform.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The operation suceeded.
@item PDF_ERROR
An error prevented the operation to finish.
@end table
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@node Creation and Destruction of Functions
@subsection Creation and Destruction of Functions

@node Evaluation of Functions
@subsection Evaluation of Functions

@node Encoded Text
@section Encoded Text

@menu
* Text Data Types::
* Initializing Text Module::
* Creating and Destroying Text::
* Managing Text Properties::
* Managing Text Contents::
* Comparing Text Variables::
* Managing Host Encodings::
@end menu

@node Text Data Types
@subsection Text Data Types

@deftp {Data Type} {enum pdf_text_unicode_encoding_e}

Enumeration of supported Unicode encodings.

@table @code
@item PDF_TEXT_UTF8
UTF-8 encoding.
@item PDF_TEXT_UTF16_BE
Big Endian UTF-16 encoding.
@item PDF_TEXT_UTF16_LE
Little Endian UTF-16 encoding.
@item PDF_TEXT_UTF16_HE
Host Endian UTF-16 encoding (may be little-endian or big-endian).
@item PDF_TEXT_UTF32_BE
Big Endian UTF-32 encoding.
@item PDF_TEXT_UTF32_LE
Little Endian UTF-32 encoding.
@item PDF_TEXT_UTF32_HE
Host Endian UTF-32 encoding (may be little-endian or big-endian).
@end table
@end deftp


@deftp {Data Type} {pdf_text_unicode_options_e}

Enumeration of extra options to get the contents of a pdf_text_t in a given
UNICODE encoding (see function `pdf_text_get_unicode').

@table @code
@item PDF_TEXT_UNICODE_NO_OPTION (= 0)
No specific option
@item PDF_TEXT_UNICODE_WITH_BOM
Prepend Byte Order Marker to the UNICODE string.
@item PDF_TEXT_UTF16BE_WITH_LANGCODE
Insert language/country code information between the BOM (if required) and the
data. This option is ONLY applicable to UTF16BE. If specified in any other
encoding, the function will fail.
@item PDF_TEXT_UNICODE_WITH_NUL_SUFFIX
Append a NUL suffix to the Unicode string (1-byte NUL for UTF-8, 2-byte NUL for
UTF-16 and 4-byte NUL for UTF-32).
@end table
@end deftp



@deftp {Data Type} {enum pdf_text_filter_type_e}

Enumeration of supported filters in encoded text objects
(see function `pdf_text_filter').

@table @code
@item PDF_TEXT_FILTER_IDENTITY
Do not perform any transformation in the encoded text. It is a no-op.
@item PDF_TEXT_FILTER_LINE_ENDINGS
Normalize line endings.
@item PDF_TEXT_FILTER_UPPER_CASE
Makes all text upper case.
@item PDF_TEXT_FILTER_LOWER_CASE
Makes all text lower case.
@item PDF_TEXT_FILTER_TITLE_CASE
Makes all text title case.
@item PDF_TEXT_FILTER_REMOVE_AMP
Remove all single ampersands. This filter transform @code{&&} into
@code{&}.
@item PDF_TEXT_FILTER_NORM_WITH_FULL_WIDTH
Normalize with full width ASCII variants filter.
@item PDF_TEXT_FILTER_REMOVE_LINE_ENDINGS
Replace line endings with space characters.
@end table
@end deftp


@deftp {Data Type} pdf_text_t

A Unicode string, which must be considered as an opaque type. It contains the data
in UTF-32BE encoding, as well as any `ISO-639-1' country code and/or `ISO-3166-1 alpha-2'
language code applied. It also contains an internal list of word boundaries.

This data type must be initialized before being used, and destroyed afterwards.

@end deftp

@deftp {Data Type} pdf_text_host_encoding_t

This data type identifies an encoding used in a host (all the possible values
are host-dependent). There is no initialization/destruction requirement for
this data type.

@end deftp


@node Initializing Text Module
@subsection Initializing Text Module

@deftypefun pdf_status_t pdf_text_init (void)

Initialize the Text Module. Must be launched only once at program startup,
and is NOT thread-safe.

@table @strong
@item Parameters
None.
@item Returns
Status of the initialization.
@end table
@end deftypefun

@node Creating and Destroying Text
@subsection Creating and Destroying Text

@deftypefun pdf_status_t pdf_text_new (pdf_text_t *text)

Create a new text object containing no text.

@table @strong
@item Parameters
@table @var
@item text
A pointer to the new instance of text object.
@end table
@item Returns
A pdf status value:
@table @code
@item PDF_OK
The text object was successfully created.
@item PDF_ENOMEM
Not enough memory to create the text object.
@item PDF_EBADCONTEXT
The global context of the text module was not initialized.
@item PDF_ERROR
Other error.
@end table
@item Usage Example
@example
pdf_text_t mytext;

pdf_text_new (&mytext);
@end example
@end table
@end deftypefun


@deftypefun pdf_status_t pdf_text_destroy (pdf_text_t text)

Destroy a text object and its contents.

@table @strong
@item Parameters
@table @var
@item text
A properly created text object.
@end table
@item Returns
The status of the destruction
@item Usage Example
@example
pdf_text_t mytext;

mytext = pdf_text_new ();
pdf_text_destroy(mytext);

@end example
@end table
@end deftypefun

@deftypefun pdf_text_t pdf_text_dup (const pdf_text_t @var{text})

Dup a new text object from a existing one.

@table @strong
@item Parameters
@table @var
@item text
A properly created text object.
@end table
@item Returns
A pointer to the newly created text object.
@item Usage Example
@example
pdf_text_t text1;
pdf_text_t text2;

text1 = pdf_text_new ();
text2 = pdf_text_dup (text1);
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_text_new_from_host (const pdf_char_t *@var{str}, const pdf_size_t @var{size}, const pdf_text_host_encoding_t @var{enc}, pdf_text_t *@var{text})

Create a new text object and initialize it with a given host encoded
string.

@table @strong
@item Parameters
@table @var
@item str
A multybyte string in some host encoding.
@item size
The length of @var{str}, in bytes.
@item enc
The host encoding with which @var{str} is encoded.
@item text
A pointer to the output text object
@end table
@item Returns
A pdf status value:
@table @code
@item PDF_OK
The operation succeeded.
@item PDF_ENOMEM
Out of memory condition.
@item PDF_EBADCONTEXT
The global context for the text module is not initialized.
@item PDF_ETEXTENC
Invalid data in the input string (encoding error).
@item PDF_EBADDATA
Invalid parameters.
@end table
@item Usage Example
@example

pdf_text_t text;
pdf_char_t *he_string;
pdf_size_t  he_string_size;
pdf_text_host_encoding_t encoding;
pdf_status_t ret_code;

/* Obtain host encoding and text... */

/* And create text object with those contents */
ret_code = pdf_text_new_from_host(he_string, he_string_size,
                                  encoding,
                                  &text);
if(ret_code != PDF_OK)
  @{
    /* Something bad happened */
  @}

@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_text_new_from_pdf_string (const pdf_char_t *@var{str}, const pdf_size_t @var{size}, pdf_char_t **@var{remaining_str}, pdf_size_t *@var{remaining_length}, pdf_text_t *@var{text})

Create a new text object and initialize it with a given `PDF string'
text representation. This `PDF string' can be either encoded in UTF-16BE, with
BOM and optional Country/Language code information, or in PDF Doc Encoding.

The Country/Language code marker is treated as end-of-text marker, so that a text object
handles only a given pair of country and language codes. This function must be used
inside a loop, so that the input string of data is splitted in chunks if more than
one language/code is available in the text (only if PDF string is encoded in
UTF-16BE).

@table @strong
@item Parameters
@table @var
@item str
A text representation of a PDF string.
@item size
The length of @var{str} in bytes
@item remaining_str
Returned pointer to the next chunk of data to process, if any.
@item remaining_length
Length of @var{remaining_str} in bytes
@item text
A pointer to the newly created text object.
@end table
@item Returns
A pdf status value:
@table @code
@item PDF_OK
The operation succeeded.
@item PDF_ENOMEM
Out of memory condition.
@item PDF_EBADCONTEXT
The global context for the text module is not initialized.
@item PDF_ETEXTENC
Invalid data in the input string (encoding error).
@item PDF_EBADDATA
Invalid parameters.
@end table
@item Usage Example
@example

pdf_text_t text;
pdf_char_t *pdf_string;
pdf_size_t  pdf_string_size;
pdf_char_t *remaining_str;
pdf_size_t remaining_size;
pdf_status_t ret_code;

/* Obtain PDF string... */

/* And create text object with those contents */
remaining_str = pdf_string;
remaining_length = pdf_string_size;
do
@{
  ret_code = pdf_text_new_from_host(remaining_str, remaining_length,
                                    &remaining_str, &remaining_length,
                                    &text);

  /* Do something with the chunk of string */

  pdf_text_destroy(text);
@}
while((ret_code == PDF_OK) && (remaining_length > 0));


@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_text_new_from_unicode (const pdf_char_t *@var{str}, const pdf_size_t @var{size}, const enum pdf_text_unicode_encoding_e @var{enc}, pdf_text_t *@var{text})

Create a new text object from a string of Unicode characters in a
given unicode encoding. The Unicode string can be given with or without BOM,
and there mustn't be any language/code information embedded in the string.

Note that for UTF-16BE strings two options are possible to create the
pdf_text_t object: treating it as a PDF string (so BOM is mandatory and 
Language/Country code are optional) or treating it as a general Unicode
string (so BOM is optional and Language/Country code is not allowed).

@table @strong
@item Parameters
@table @var
@item str
A Unicode string.
@item size
The length of @var{ucs} in bytes.
@item enc
The Unicode encoding used by @var{ucs}.
@item text
A pointer to the newly created text object.
@end table
@item Returns
A pdf status value:
@item PDF_OK
The operation succeeded.
@item PDF_ENOMEM
Out of memory condition.
@item PDF_EBADCONTEXT
The global context for the text module is not initialized.
@item PDF_ETEXTENC
Invalid data in the input string (encoding error).
@item PDF_EBADDATA
Invalid parameters.
@item Usage Example
@example

pdf_text_t text;
pdf_char_t *unicode_string;
pdf_size_t  unicode_string_size;
pdf_status_t ret_code;

/* Obtain unicode text... */

/* And create text object with those contents */
ret_code = pdf_text_new_from_unicode(unicode_string, unicode_string_size,
                                     PDF_TEXT_UTF16_BE,
                                     &text);
if(ret_code != PDF_OK)
  @{
    /* Something bad happened */
  @}

@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_text_new_from_u32 (const pdf_u32_t @var{number}, pdf_text_t *text)

Create a new text variable containing the textual representation of a
given integer.

@table @strong
@item Parameters
@table @var
@item number
An unsigned 32 bit number.
@item text
A pointer to the newly created text object.
@end table
@item Returns
A pdf status value:
@table @code
@item PDF_OK
The operation succeeded.
@item PDF_ENOMEM
Out of memory condition.
@item PDF_EBADCONTEXT
The global context for the text module is not initialized.
@item PDF_ETEXTENC
Invalid data in the input string (encoding error).
@item PDF_EBADDATA
Invalid parameters.
@end table
@item Usage Example
@example
pdf_text_t text;
pdf_u32_t number;
pdf_status_t ret_code;

number = 24;
ret_code = pdf_text_new_from_u32 (number, &text);

if(ret_code != PDF_OK)
  @{
    /* Something bad happened */
  @}

@end example
@end table
@end deftypefun

@node Managing Text Properties
@subsection Managing Text Properties

@deftypefun {const pdf_char_t *} pdf_text_get_country (const pdf_text_t @var{text})

Return the `ISO-3166-1 alpha-2' country code associated with a text variable, as a
NUL-terminated string. The returned string should not be modified, as it is
managed by the `pdf_text_t' data type.

@table @strong
@item Parameters
@table @var
@item text
A text variable.
@end table
@item Returns
The code of the country associated with @var{text}.
@item Usage Example
@example
pdf_text_t text;
pdf_char_t *code;

/* ...create and manipulate `text' */

code = pdf_text_get_country (text);
@end example
@end table
@end deftypefun

@deftypefun {const pdf_char_t *} pdf_text_get_language (const pdf_text_t @var{text})

Return the `ISO-639-1' language code associated with a text variable, as a
NUL-terminated string. The returned string should not be modified, as it is
managed by the `pdf_text_t' data type.

@table @strong
@item Parameters
@table @var
@item text
A text variable.
@end table
@item Returns
The code of the language associated with @var{text}.
@item Usage Example
@example
pdf_text_t text;
pdf_char_t *code;

/* ...create and manipulate `text' */

code = pdf_text_get_language (text);
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_text_set_country (pdf_text_t @var{text}, const pdf_char_t *@var{code})

Associate a text variable with a `ISO-3166-1 alpha-2' country code.

@table @strong
@item Parameters
@table @var
@item text
A text variable.
@item code
A country code.
@end table
@item Returns
The status of the assignment.
@item Usage Example
@example
pdf_text_t text;
pdf_status_t ret_code;

/* ...create and manipulate `text' */

ret_code = pdf_text_set_country (text, "27");

@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_text_set_language (pdf_text_t @var{text}, const pdf_char_t *@var{code})

Associate a text variable with a `ISO-639-1' language code.

@table @strong
@item Parameters
@table @var
@item text
A text variable.
@item code
A language code.
@end table
@item Returns
The status of the assignment.
@item Usage Example
@example
pdf_text_t text;
pdf_status_t ret_code;

/* ...create and manipulate `text' */

ret_code = pdf_text_set_language (text, "10");
@end example
@end table
@end deftypefun

@deftypefun pdf_bool_t pdf_text_empty_p (const pdf_text_t @var{text})

Determine if a given text variable is empty (contains no text).

@table @strong
@item Parameters
@table @var
@item text
A text variable.
@end table
@item Returns
A boolean value:
@table @code
@item PDF_TRUE
The text variable contain no text.
@item PDF_FALSE
The text variable contain some text.
@end table
@item Usage Example
@example
pdf_text_t text;

/* ...initialize and manipulate `text'... */

if (pdf_text_empty_p (text))
@{
  /* `text' contains no text */
@}
@end example
@end table
@end deftypefun


@node Managing Text Contents
@subsection Managing Text Contents

@deftypefun pdf_status_t pdf_text_get_host (pdf_char_t **@var{contents}, pdf_size_t *@var{length}, const pdf_text_t @var{text}, const pdf_text_host_encoding_t @var{enc})

Get the contents of a text variable encoded in a given host encoding.

@table @strong
@item Parameters
@table @var
@item contents
Output array of bytes (May contain NUL bytes). Must be freed afterwards.
@item length
Output length of @var{contents}
@item text
A text variable.
@item enc
A host encoding supported by the host.
@end table
@item Returns
The status of the conversion.
@item Usage Example
@example
pdf_text_t text;
pdf_text_host_encoding_t encoding;
pdf_char_t *str;
pdf_size_t str_length;
pdf_status_t ret_code;

/* ...initialize and manipulate `text'... */

ret_code = pdf_text_get_host (&str, &str_length, text, encoding);

pdf_dealloc(str);

@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_text_get_pdfdocenc (pdf_char_t **@var{contents}, const pdf_text_t @var{text})

Get the contents of a text variable encoded in PDF Doc Encoding,
and NUL-terminated.

@table @strong
@item Parameters
@table @var
@item contents
Output array of bytes (Can't contain NUL bytes). Must be freed afterwards.
@item text
A text variable.
@end table
@item Returns
The status of the conversion.
@item Usage Example
@example
pdf_text_t text;
pdf_char_t *str;
pdf_status_t ret_code;

/* ...initialize and manipulate `text'... */

ret_code = pdf_text_get_pdfdocenc (&str, text);

pdf_dealloc(str);

@end example
@end table
@end deftypefun


@deftypefun pdf_status_t pdf_text_get_unicode (pdf_char_t **@var{contents}, pdf_size_t *@var{length}, const pdf_text_t @var{text}, const enum pdf_text_unicode_encoding_e @var{enc}, const pdf_u32_t @var{options})

Get the contents of a text variable encoded in the specified
Unicode encoding. Additional options can be set in the request.

@table @strong
@item Parameters
@table @var
@item contents
Output array of bytes (May contain NUL bytes). Must be freed afterwards.
@item length
Output length of @var{contents}
@item text
A text variable.
@item enc
A given UNICODE encoding, specifying requested endianness.
@item options
Additional options that can be set, in the way: OPTION_1 | OPTION_2 | OPTION_3.
(see @code{pdf_text_unicode_options_e} data type)
@end table
@item Returns
The status of the conversion.
@item Usage Example
@example
pdf_text_t text;
pdf_char_t *str;
pdf_size_t str_length;
pdf_status_t ret_code;

/* ...initialize and manipulate `text'... */

ret_code = pdf_text_get_unicode (&str, &str_length,
                                 text,
                                 PDF_TEXT_UTF16_BE,
                                 (PDF_TEXT_UNICODE_WITH_BOM | PDF_TEXT_UTF16BE_WITH_LANGCODE));

pdf_dealloc(str);

@end example
@end table
@end deftypefun




@deftypefun {pdf_char_t *} pdf_text_get_hex (const pdf_text_t @var{text}, const pdf_char_t @var{delimiter})

Get the contents of a text variable encoded in ASCII format and represented in Hexadecimal format, separated by the character given in @var{delimiter} (usually ':').

@table @strong
@item Parameters
@table @var
@item text
A text variable
@item delimiter
A single ASCII char used as delimiter
@end table
@item Returns
A NUL-terminated string with the contents of the text object in hexadecimal representation. The string must be deallocated by the caller.
@item Usage Example
@example
pdf_text_t text;
pdf_char_t *str;
pdf_status_t ret_code;

/* ...initialize and manipulate `text'... */

str = pdf_text_get_hex (text, ':');

PDF_DEBUG_BASE("Internal representation of the string is: '%s'",str);

pdf_dealloc(str);

@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_text_set_host (pdf_text_t @var{text}, const pdf_char_t *@var{str}, const pdf_size_t @var{size}, const pdf_text_host_encoding_t @var{enc})

Set a string encoded with some host encoding as the value of a text
variable.

@table @strong
@item Parameters
@table @var
@item text
A text variable.
@item str
A string encoded with some host encoding.
@item enc
The length of @var{str}, in bytes.
@item enc
The host encoding used to encode @var{str}.
@end table
@item Returns
The status of the conversion.
@item Usage Example
@example
pdf_text_t text;
pdf_text_host_encoding_t encoding;
pdf_char_t *str;
pdf_size_t length;

/* ...initialize and manipulate `text', `encoding' and `str'... */
if (pdf_text_set_host (text, str, length, enc) != PDF_OK)
@{
  /* `str' contains bad data */
@}
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_text_set_pdfdocenc (pdf_text_t @var{text}, const pdf_char_t *@var{str})

Set a PDF Doc Encoding encoded string as the value of a text variable.

@table @strong
@item Parameters
@table @var
@item text
A text variable.
@item str
A string encoded with PDF Doc Encoding, NUL terminated.
@end table
@item Returns
The status of the conversion.
@item Usage Example
@example
pdf_text_t text;
pdf_char_t *str;

/* ...initialize and manipulate `text' and `str'... */
if (pdf_text_set_pdfdocenc (text, str) != PDF_OK)
@{
  /* `str' contains bad data */
@}
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_text_set_unicode (pdf_text_t @var{text}, const pdf_char_t *@var{str}, const pdf_size_t @var{size}, const enum pdf_text_unicode_encoding_e @var{enc})

Set a Unicode encoded string as the value of a text variable.

@table @strong
@item Parameters
@table @var
@item text
A text variable.
@item str
A Unicode string without country/language data embedded.
@item size
The length of @var{str}, in bytes.
@item enc
The used Unicode encoding in @var{str}.
@end table
@item Returns
The status of the conversion.
@item Usage Example
@example
pdf_text_t text;
pdf_char_t *str;
pdf_size_t length;
enum pdf_text_unicode_encoding_e enc;

/* ...initialize and manipulate `text', `str' and `enc'... */
if (pdf_text_set_unicode (text, str, length, enc) != PDF_OK)
@{
  /* `str' contains bad data */
@}
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_text_concat (pdf_text_t @var{text1}, const pdf_text_t @var{text2}, const pdf_bool_t @var{override_langinfo})

Concatenate the contents of two text variables (@var{text1} first,
then @var{text2}) and store the result in @var{text}.

Warning! @var{override_langinfo} is not set and different country/language 
codes are found within the text variables an error will be returned 
(concatenation not possible). If @var{override_langinfo} is set, the country
 and language information is not checked.

@table @strong
@item Parameters
@table @var
@item text1
The first text variable to concatenate. The contents of this variable
are modified with the output of the concatenation.
@item text2
The second text variable to concatenate. The contents of this variable
are left unchanged.
@item override_langinfo
Flag to indicate if the language and country information must be checked
before performing the concatenation.
@end table
@item Returns
The status of the operation.
@item Usage Example
@example
pdf_text_t text1;
pdf_text_t text2;

/* ...initialize `text1' and `text2'... */
if (pdf_text_concat (text1, text2, PDF_FALSE) != PDF_OK)
@{
   /* Manage the error */
@}
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_text_replace (pdf_text_t @var{text}, const pdf_text_t @var{new_pattern}, const pdf_text_t @var{old_pattern})

Replace a fixed pattern in the content of a given text variable.

@table @strong
@item Parameters
@table @var
@item text
A text variable.
@item new_pattern
The replacement text.
@item old_pattern
The text to be replaced. Any occurrence of this text is replaced with @var{new_pattern}.
@end table
@item Returns
The status of the operation
@item Usage Example
@example
pdf_text_t text;
pdf_text_t new_pattern;
pdf_text_t old_pattern;

/* ...initialize `text', `new_pattern' and `old_pattern'... */
if (pdf_text_replace (text, new_pattern, new_pattern) != PDF_OK)
@{
  /* Manage the error */
@}
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_text_replace_ascii (pdf_text_t @var{text}, const pdf_char_t *@var{new_pattern}, const pdf_char_t *@var{old_pattern})

Replace a fixed ASCII pattern in the content of a given text variable.

@table @strong
@item Parameters
@table @var
@item text
A text variable.
@item new_pattern
The replacement ASCII string.
@item old_pattern
The text to be replaced. Any occurrence of this text is replaced with @var{new_pattern}.
@end table
@item Returns
The status of the operation
@item Usage Example
@example
pdf_text_t text;
const pdf_char_t *new_pattern = "GNU/Linux";
const pdf_char_t *old_pattern = "Linux";

/* ...initialize `text'... */
if (pdf_text_replace_ascii (text, new_pattern, old_pattern) != PDF_OK)
@{
  /* Manage the error */
@}
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_text_filter (pdf_text_t @var{text}, const pdf_u32_t @var{filter})

Filter the contents of a text variable.

@table @strong
@item Parameters
@table @var
@item text
A text variable.
@item filter
Filter to be run in @var{text}, in the way: FILTER_1 | FILTER_2 | FILTER_3.
(see @code{pdf_text_filter_type_e} data type).

Warning!! At most one case-related filter can be applied at a time.
@end table
@item Returns
The status of the operation
@item Usage Example
@example
pdf_text_t text;

/* ...initialize `text'... */

if (pdf_text_filter (text, (PDF_TEXT_FILTER_LOWER_CASE | PDF_TEXT_FILTER_REMOVE_AMP)) != PDF_OK)
@{
  /* Manage error */
@}
@end example
@end table
@end deftypefun


@node Comparing Text Variables
@subsection Comparing Text Variables

@deftypefun pdf_i32_t pdf_text_cmp (const pdf_text_t @var{text1}, const pdf_text_t @var{text2}, const pdf_bool_t @var{case_sensitive}, pdf_status_t *@var{p_ret_code})

Compare the contents of two text variables.

@table @strong
@item Parameters
@table @var
@item text1
A text variable.
@item text2
A text variable.
@item case_sensitive
A boolean value indicating if the comparison is case-sensitive:
@table @code
@item PDF_TRUE
Case sensitive.
@item PDF_FALSE
Case insensitive.
@end table
@item p_ret_code
Pointer to store the status of the comparison (an internal error could happen).
NULL can be passed, so that the return status is not considered.
@end table
@item Returns
An integer:
@table @code
@item -1
If text1 < text2
@item 0
If text1 = text2
@item +1
If text1 > text2
@end table
@item Usage Example
@example
pdf_text_t text1;
pdf_text_t text2;

/* ...initialize `text1' and `text2'... */

switch (pdf_text_cmp (text1, text2, PDF_FALSE))
@{
 case -1:
 @{
   /* XXX */
   break;
 @}
 case 0:
 @{
   /* XXX */
   break;
 @}
 case +1:
 @{
   /* XXX */
   break;
 @}
@}
@end example
@end table
@end deftypefun

@node Managing Host Encodings
@subsection Managing Host Encodings

@deftypefun pdf_text_host_encoding_t pdf_text_get_host_encoding (void)

Return the host encoding configured by the user/system in the locale. 

@table @strong
@item Parameters
None
@item Returns
The host encoding configured in the user's locale.
@item Usage Example
@example
pdf_text_host_encoding enc;

enc = pdf_text_get_host_encoding();

@end example
@end table
@end deftypefun


@deftypefun pdf_status_t pdf_text_check_host_encoding (const pdf_char_t *@var{encoding_name}, pdf_text_host_encoding_t *@var{p_encoding})

Check if a given encoding is available in the system as a host-encoding. If available, it will return PDF_OK and will fill in the pdf_text_host_encoding_t variable passed by reference.

@table @strong
@item Parameters
@table @var
@item encoding_name
Name of the encoding to check for.
@item p_encoding
Pointer to a pdf_text_host_encoding_t variable.
@end table
@item Returns
Returns PDF_OK if the encoding is available in the system as a host-encoding.
@item Usage Example
@example
pdf_text_host_encoding enc;

if(pdf_text_check_host_encoding((pdf_char_t *)"ascii-us",&enc) == PDF_OK)
  @{
    /* XXX */
  @}

@end example
@end table
@end deftypefun


@deftypefun pdf_text_host_encoding_t pdf_text_get_best_encoding (const pdf_text_t @var{text}, const pdf_text_host_encoding_t @var{preferred_encoding})

Return the best available host encoding to encode the contents of a
given text variable. A specified preferred encoding is selected if
there is no clear best encoding.

The ``best'' encoding is an encoding able to encode the bigger number
of characters of the unicode content of the given text variable, so the
function will check for Unicode encodings supported in the system.
@table @strong
@item Parameters
@table @var
@item text
A text variable.
@item preferred_encoding
A text encoding supported by the host.
@end table
@item Returns
The best host encoding available to encode the contents of @var{text}.
@item Usage Example
@example
pdf_text_t text;
pdf_text_host_encoding pref;
pdf_text_host_encoding enc;

/* ...create and manipulate `text'... */

enc = pdf_text_get_best_encoding (text, pref);

@end example
@end table
@end deftypefun


@node Time Management
@section Time Management

@menu
* Time Related Data Types::
* Time Creation and Destruction::
* Managing Time Values::
* Getting Time Intervals::
* Time Comparison::
* Time Printing and Parsing::
* Getting the Current Time::
* Time Span Creation and Destruction::
* Managing Time Span Values::
* Time Span Comparison::
* Calendar Spans Management::
* Platform-specific functions::
@end menu

@node Time Related Data Types
@subsection Time Related Data Types

@deftp {Data Type} pdf_time_t
A variable of type @code{pdf_time_t} contains information about a
particular date and time.

Note that leap seconds are not considered.
@end deftp

@deftp {Data Type} pdf_time_span_t
A variable of type @code{pdf_time_span_t} represents a span of time.

@end deftp

@deftp {Data Type} struct pdf_time_cal_s
This structure holds information about a specific time represented in
calendar items: years, months, days, day of week, hours, minutes,
seconds and the relative offset with GMT.

The calendar can be represented in both UTC and local time. If the given GMT
offset is zero, the calendar fields come in UTC; if not zero, the calendar
fields come in a given local time.

@table @code
@item pdf_i32_t year
A year number. Negative values may be supported in some systems.
@item pdf_u32_t month
A month number. The valid range is @code{1..12}.
@item pdf_u32_t day
A day number. The valid range is @code{1..31}.
@item pdf_u32_t dow
Day of the week. The valid range is @code{1..7} (Monday to Sunday).
@item pdf_u32_t hour
An hour. The valid range is @code{0..23}.
@item pdf_u32_t minute
A minute. The valid range is @code{0..59}.
@item pdf_u32_t sec
A second. The valid range is @code{0..59}.
@item pdf_i32_t gmt_offset
A GMT offset, in seconds west of GMT.
@end table
@end deftp

@deftp {Data Type} struct pdf_time_cal_span_s
This structure holds information about a time span represented in
calendar items: years, months, days, hours, minutes and seconds.

@table @code
@item pdf_u32_t years
@item pdf_u32_t months
@item pdf_u32_t days
@item pdf_u32_t hours
@item pdf_u32_t minutes
@item pdf_u32_t seconds
@end table
@end deftp

@deftp {Data Type} {enum pdf_time_format_e}
Enumeration containing the several supported time formats used to
convert a time to a string representation or to parse a time from a
string representation.

@table @code
@item PDF_TIME_FORMAT_PDF
PDF date strings.
@item PDF_TIME_FORMAT_ISO_8601
ISO 8601 date and time strings.
@item PDF_TIME_FORMAT_UTC_ASN1
UTC ASN1 date.
@item PDF_TIME_FORMAT_GENERALIZED_ASN1
Generalized ASN1 date.
@end table
@end deftp

@node Time Creation and Destruction
@subsection Time Creation and Destruction

@deftypefun pdf_status_t pdf_time_new (pdf_time_t *@var{time})
Create a new time and set it to the Epoch: Jan 1 1970-01-01 00:00:00 UTC

@table @strong
@item Parameters
@table @var
@item time
The time object that will contain the newly created instance.
@end table
@item Returns
A pdf status value:
@table @code
@item PDF_OK
The time object was successfully instantiated.
@item PDF_ENOMEM
Not enough memory to perform the requested operation.
@end table
@item Usage example
@example
pdf_time_t mytime;

if (pdf_time_new (&mytime) != PDF_OK)
   @{
     /* Error */
   @}
@end example
@end table
@end deftypefun

@deftypefun pdf_time_t pdf_time_dup (const pdf_time_t @var{orig})
Dup a new time variable from a given one, allocating memory.

@table @strong
@item Parameters

@table @var
@item orig
The time variable to be dupped. Should be a properly created time
variable.
@end table
@item Returns
A new time variable containing a copy of @var{orig} values.
@code{NULL} if there is an error.
@item Usage example
@example
pdf_time_t orig;
pdf_time_t new_time;

orig = pdf_time_new ();
new_time = pdf_time_dup (orig);

if (new_time == NULL)
@{
  /* Error */
@}
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_time_destroy (pdf_time_t @var{time_var})
Destroy @var{time_var} and free all used memory.

@table @strong
@item Parameters
@table @var
@item time_var
The time variable to be destroyed. Should be a properly created time
variable.
@end table
@item Returns
A status value:
@table @code
@item PDF_OK
The operation succeeded.
@end table
@item Usage example
@example
pdf_time_t mytime;

mytime = pdf_time_new ();
pdf_time_destroy (mytime);
@end example
@end table
@end deftypefun

@node Managing Time Values
@subsection Managing Time Values

@deftypefun pdf_status_t pdf_time_copy (const pdf_time_t @var{orig}, pdf_time_t @var{copy})
Copies the data from @var{orig} to @var{copy}.

@table @strong
@item Parameters
@table @var
@item orig
The time whose data is to be copied. Should be a properly created time variable.
@item copy
The time to receive the data from @var{orig}. Should be a properly
created time variable.

Note that any previous data is destroyed.
@end table
@item Returns
A status value:
@table @code
@item PDF_OK
The operation succeeded.
@end table
@item Usage example
@example
pdf_time_t orig;
pdf_time_t copy;

orig = pdf_time_new ();
copy = pdf_time_new ();

if (!pdf_time_copy (orig, copy))
@{
  /* Error */
@}
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_time_clear (pdf_time_t @var{time_var})
Reset @var{time_var} to the newly created state. After this call
@var{time_var} will contain the same date as if returned by
@code{pdf_time_new}.

@table @strong
@item Parameters
@table @var
@item time_var
The time variable to clear. Should be a properly create time variable.
@end table
@item Returns
A status value:
@table @code
@item PDF_OK
The operation succeeded.
@end table
@item Usage example
@example
pdf_time_t mytime;

mytime = pdf_time_new ();

/* ...manipulate `mytime'... */

pdf_time_clear (mytime);
@end example
@end table
@end deftypefun


@deftypefun pdf_status_t pdf_time_set_from_u32 (pdf_time_t @var{time_var}, pdf_u32_t @var{seconds})
This function will initialize @var{time_var} to the given Unix time (seconds since January 1st 1970) in UTC timescale.
The time is represented as a 32-bit unsigned integer.

@table @strong
@item Parameters
@table @var
@item time_var 
The time variable to set. Should be a properly create time variable.
@item seconds
Seconds since January 1st 1970, 32-bit unsigned value.
@end table
@item Returns
A status value:
@table @code
@item PDF_OK
The operation succeeded.
@end table
@item Usage example
@example
pdf_time_t mytime;

mytime = pdf_time_new ();

pdf_time_set_from_i32(mytime, 1217009657);

@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_time_set_from_i64 (pdf_time_t @var{time_var}, pdf_i64_t @var{seconds})
This function will initialize @var{time_var} to the given Unix time (seconds since January 1st 1970) in UTC timescale.
The time is represented as a pdf_i64_t integer.

@table @strong
@item Parameters
@table @var
@item time_var 
The time variable to set. Should be a properly create time variable.
@item seconds
Seconds since January 1st 1970, pdf_i64_t variable.
@end table
@item Returns
A status value:
@table @code
@item PDF_OK
The operation succeeded.
@end table
@item Usage example
@example
pdf_time_t mytime;
pdf_i64_t  epoch = pdf_i64_new(0,1217009657);
mytime = pdf_time_new ();

pdf_time_set_from_i64(mytime, epoch);

@end example
@end table
@end deftypefun



@deftypefun pdf_status_t pdf_time_add_cal_span (pdf_time_t @var{time_var}, const struct pdf_time_cal_span_s *@var{p_cal_span})
Add the time span represented by the calendar span under the address in @var{p_cal_span} to @var{time_var}.

@table @strong
@item Parameters

@table @var
@item time_var
A properly created time variable.
@item p_cal_span
A pointer to a calendar span with valid values.
@end table

@item Returns
A status value:
@table @code
@item PDF_OK
The operation successfully finished.
@item PDF_EBADDATA
The data in @var{*p_cal_span} is invalid.
@end table

@item Usage example
@example
pdf_time_t mytime;
struct pdf_time_cal_span_s cal_span;

mytime = pdf_time_new (); /* Initialized to Jan 1 1970-01-01 00:00:00 */

cal_span.year = 30;
cal_span.month = 7;
cal_span.day = 20;
cal_span.hour = 21;
cal_span.minute = 0;
cal_span.second = 0;

if (pdf_time_add_cal_span (mytime, &cal_span) == PDF_EBADDATA)
@{
  /* Bad data in `cal_span' */
@}
else
@{
  /* `time' now contains Aug 21 2000-08-21 21:00:00 */
@}
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_time_sub_cal_span (pdf_time_t @var{time_var}, const struct pdf_time_cal_span_s *@var{p_cal_span})
Subtract the time span represented by the calendar span under the address in @var{p_cal_span} to @var{time_var}.

@table @strong
@item Parameters

@table @var
@item time_var
A properly created time variable.
@item p_cal_span
A pointer to a calendar span with valid values.
@end table

@item Returns
A status value:
@table @code
@item PDF_OK
The operation successfully finished.
@item PDF_EBADDATA
The data in @var{cal_span} is invalid.
@end table

@item Usage example
@example
pdf_time_t mytime;
struct pdf_time_cal_span_s cal_span;

mytime = pdf_time_new (); /* Initialized to Jan 1 1970-01-01 00:00:00 */

cal_span.year = 30;
cal_span.month = 7;
cal_span.day = 20;
cal_span.hour = 21;
cal_span.minute = 0;
cal_span.second = 0;

if (pdf_time_add_cal_span (mytime, &cal_span) == PDF_EBADDATA)
@{
  /* Bad data in `cal_span' */
@}
else
@{
  /* `time' now contains Aug 21 2000-08-21 21:00:00 */
@}

if (pdf_time_sub_cal_span (mytime, cal_span) == PDF_EBADDATA)
@{
  /* Bad data in `cal_span' */
@}
else
@{
  /* `time' now contains Jan 1 1970-01-01 00:00:00 */
@}
@end example
@end table
@end deftypefun


@deftypefun pdf_status_t pdf_time_add_span (pdf_time_t @var{time_var}, const pdf_time_span_t @var{time_span})
Add the time span contained in @var{time_span} to @var{time_var}.

@table @strong
@item Parameters

@table @var
@item time_var
A properly created time variable.
@item time_span
A properly created time span.
@end table

@item Returns
A status value:
@table @code
@item PDF_OK
The operation successfully finished.
@end table

@item Usage example
@example
pdf_time_t mytime;
pdf_time_span_t myspan;

mytime = pdf_time_new ();

/* ...create and initialize `myspan'... */

pdf_time_add_span (mytime, myspan);
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_time_sub_span (pdf_time_t @var{time_var}, const pdf_time_span_t @var{time_span})
Subtract the time span contained in @var{time_span} to @var{time_var}.

@table @strong
@item Parameters

@table @var
@item time_var
A properly created time variable.
@item time_span
A properly created time span.
@end table

@item Returns
A status value:
@table @code
@item PDF_OK
The operation successfully finished.
@end table

@item Usage example
@example
pdf_time_t mytime;
pdf_time_span_t myspan;

mytime = pdf_time_new ();

/* ...create and initialize `myspan'... */

pdf_time_sub_span (mytime, myspan);
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_time_get_local_cal (const pdf_time_t @var{time_var}, struct pdf_time_cal_s *@var{p_local_cal})
Fill @var{p_local_cal} with the local calendar time of @var{time_var}.

@table @strong
@item Parameters

@table @var
@item time_var
A properly created time variable.
@item p_local_cal
A pointer to the time calendar structure that will hold the local time
of @var{time_var}.
@end table

@item Returns
A status value:
@table @code
@item PDF_OK
The operation successfully finished.
@end table

@item Usage example
@example
pdf_time_t mytime;
struct pdf_time_cal_s cal;

/* ...create and manipulate `mytime'... */

pdf_time_get_local_cal (mytime, &cal);
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_time_get_utc_cal (const pdf_time_t @var{time_var}, struct pdf_time_cal_s *@var{p_utc_cal})
Get the UTC calendar time of a given time variable.

@table @strong
@item Parameters

@table @var
@item time_var
A properly created time variable.
@item p_cal_time
A pointer to the calendar time structure that will hold the UTC time of @var{time_var}.
@end table

@item Returns
A status value:
@table @code
@item PDF_OK
The operation successfully finished.
@end table

@item Usage example
@example
pdf_time_t mytime;
sruct pdf_time_cal_s cal_time;

/* ...create and manipulate `mytime'... */

pdf_time_get_utc_cal (mytime, &cal_time);
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_time_from_cal (pdf_time_t @var{time_var}, const struct pdf_time_cal_s *@var{p_cal_time})
Set the value of a time variable to a given calendar time.

@table @strong
@item Parameters

@table @var
@item time_var
A properl created time variable.
@item p_cal_time
A pointer to a calendar time structure.
@end table

@item Returns
A status value:
@table @code
@item PDF_OK
The operation successfully finished.
@item PDF_EBADDATA
There is invalid data in the calendar structure @var{cal_time}.
@end table

@item Usage example
@example
pdf_time_t mytime;
struct pdf_time_cal_s mycaltime;

mytime = pdf_time_new ();

mycaltime.year = 2000;
mycaltime.month = 8;
mycaltime.day = 10;
mycaltime.dow = 0; /* This field is ignored by `pdf_time_from_cal' */
mycaltime.hour = 0;
mycaltime.minute = 0;
mycaltime.sec = 0;
mycaltime.gmt_offset = 1;

if (pdf_time_from_cal (mytime, &mycaltime) == PDF_EBADDATA)
@{
  /* Bad data in `mycaltime' */
@}
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_time_set_local_offset (pdf_time_t @var{time_var})
Set the local time offset of @var{time_var} to the one used by the
operating system.

@table @strong
@item Parameters

@table @var
@item time
A properly created time variable.
@end table

@item Returns
A status value:
@table @code
@item PDF_OK
The operation successfully finished.
@end table

@item Usage example
@example
pdf_time_t mytime;

mytime = pdf_time_new ();
pdf_time_set_local_offset (time);
@end example
@end table
@end deftypefun

@node Getting Time Intervals
@subsection Getting Time Intervals

@deftypefun pdf_status_t pdf_time_diff_cal (const pdf_time_t @var{time1}, const pdf_time_t @var{time2}, struct pdf_time_cal_span_s *@var{p_cal_span})
Calculate the time span that goes from @var{time1} to @var{time2} and
store it in @var{p_cal_span}.

Note that the highest possible distribution inside @var{p_cal_span} is used.
@table @strong
@item Parameters

@table @var
@item time1
The beginning of the time interval (inclusive).
@item time2
The end of the time interval (exclusive).
@item p_cal_span
Pointer to the calendar time span structure that will hold the time span that
goes between @var{time1} and @var{time2}.
@end table

@item Returns
A status value:
@table @code
@item PDF_OK
The operation successfully finished.
@end table

@item Usage example
@example
pdf_time_t time_begin;
pdf_time_t time_end;
struct pdf_time_cal_span_s cal_span;

/* ...create and manipulate `time_begin' and `time_end' */

pdf_time_diff (time_begin, time_end, &cal_span);
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_time_diff (const pdf_time_t @var{time1}, const pdf_time_t @var{time2}, pdf_time_span_t *@var{p_time_span})
Calculate the time span between two dates.

@table @strong
@item Parameters

@table @var
@item time1
The beginning time. Should be a properly created time.
@item time2
The ending time. Should be a properly created time.
@item p_time_span
The pointer to the time span variable that will hold the difference between
@var{time1} and @var{time2}. Should be a properly created time
span. Any previous content of @var{*p_time_span} will be destroyed.
@end table

@item Returns
A status value:
@table @code
@item PDF_OK
The operation successfully finished.
@end table

@item Usage example
@example
pdf_time_t time1;
pdf_time_t time2;
pdf_time_span_t time_span;

/* ...create and manipulate `time1', `time2' and `time_span'... */

pdf_time_diff (time1, time2, &time_span);
@end example
@end table
@end deftypefun

@node Time Comparison
@subsection Time Comparison

@deftypefun pdf_i32_t pdf_time_cmp (const pdf_time_t @var{time1}, const pdf_time_t @var{time2})
Compares two times.

@table @strong
@item Parameters

@table @var
@item time1
The first time to compare.
Should be a properly created time variable.
@item time2
The second time to compare.
Should be a properly created time variable.
@end table

@item Returns
A status value:
@table @code
@item -1
If @var{time1} precedes @var{time2}.
@item 0
If @var{time1} and @var{time2} contain the same time.
@item 1
If @var{time2} precedes @var{time1}.
@end table

@item Usage example
@example
pdf_time_t time1;
pdf_time_t time2;

time1 = pdf_time_new ();
time2 = pdf_time_new ();

/* ...manipulate `time1' and `time2'... */

switch (pdf_time_cmp (time1, time2))
@{
  case -1:
  @{
    /* `time1' precedes `time2' */
    break;
  @}
  case 0:
  @{
    /* `time1' contain the same time than `time2' */
    break;
  @}
  case 1:
  @{
    /* `time2' precedes `time1' */
    break;
  @}
@}
@end example
@end table
@end deftypefun

@node Time Printing and Parsing
@subsection Time Printing and Parsing

@deftypefun pdf_char_t* pdf_time_to_string (const pdf_time_t @var{time_var}, const enum pdf_time_format_e @var{time_format})
Create a string representation of a given time.

@table @strong
@item Parameters

@table @var
@item time_var
A properly created time variable.
@item time_format
The format to use when creating the string representation of @var{time}. 
@end table

@item Returns
The string representation of @var{time}. Must be deallocated by the caller of the function explicitly with pdf_dealloc().
@code{NULL} if there is an error.

@item Usage example
@example
pdf_time_t mytime;
pdf_char_t *mytime_str;

/* ...create and manipulate `mytime'... */

mytime_str = pdf_time_to_string (mytime, PDF_TIME_FORMAT_PDF);

pdf_dealloc(mytime_str);
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_time_from_string (pdf_time_t @var{time_var}, const pdf_char_t *@var{time_str}, const enum pdf_time_format_e @var{time_format})
Get a string containing a time specification in some format and fill a
time variable with the parsed values.

@table @strong
@item Parameters

@table @var
@item time_var
A properly created time variable.

@item time_str
A null-terminated string representation of a time.
@item time_format
The format indicating how to parse @var{time_str}.
@end table

@item Returns
A status value:
@table @code
@item PDF_OK
The operation succeeded.
@item PDF_EBADDATA
Error while parsing @var{time_str} according to @var{time_format}.
@end table

@item Usage example
@example
pdf_time_t mytime;
char time_str[] = "FIXME: put a correct PDF time there";

mytime = pdf_time_new ();
if (pdf_time_from_string (mytime, 
                          time_str,
                          PDF_TIME_FORMAT_PDF) == PDF_EBADDATA)
@{
  /* Error while parsing `time_str' according to `PDF_TIME_FORMAT_PDF' */
@}
@end example
@end table
@end deftypefun

@node Getting the Current Time
@subsection Getting the Current Time

@deftypefun pdf_status_t pdf_time_set_to_current_local_time (pdf_time_t @var{time_var})
Set the value of @var{time_var} to the current local time used by the
operating system.

@table @strong
@item Parameters

@table @var
@item time_var
A properly created time variable.
@end table

@item Returns
A status value:
@table @code
@item PDF_OK
The operation successfully finished.
@end table

@item Usage example
@example
pdf_time_t mytime;

mytime = pdf_time_new ();

pdf_time_set_to_current_local_time (mytime);
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_time_set_to_current_utc_time (pdf_time_t @var{time_var})
Set the value of @var{time_var} to the current UTC time used by the operating system.

@table @strong
@item Parameters

@table @var
@item time_var
A properly created time variable.
@end table

@item Returns
A status value:
@table @code
@item PDF_OK
The operation successfully finished.
@end table

@item Usage example
@example
pdf_time_t mytime;

mytime = pdf_time_new ();

pdf_time_set_to_current_utc_time (mytime);
@end example
@end table
@end deftypefun

@node Time Span Creation and Destruction
@subsection Time Span Creation and Destruction

@deftypefun pdf_time_span_t pdf_time_span_new (void)

Allocate and return a new time span variable. The time span is
initialized with a zero value (zero seconds).

@table @strong
@item Parameters

None.

@item Returns
The newly created time span variable or @code{NULL} if there is an
error. 
@item Usage example
@example
pdf_time_span_t span;

span = pdf_time_span_new ();
@end example
@end table
@end deftypefun

@deftypefun pdf_time_span_t pdf_time_span_dup (const pdf_time_span_t @var{span})

Allocate and dup a new time span from an existing one. The new time
span has the same value as the base time span.

@table @strong
@item Parameters

@table @var
@item span
A properly created time span variable.
@end table

@item Returns
The newly created time span variable.
@item Usage example
@example
pdf_time_span_t span;
pdf_time_span_t new_span;

/* ...create and manipulate `span'... */

new_span = pdf_time_span_dup (span);
@end example
@end table
@end deftypefun


@deftypefun pdf_status_t pdf_time_span_destroy (pdf_time_span_t *@var{p_span})

Destroy a time span variable freeing all used memory.

@table @strong
@item Parameters

@table @var
@item p_span
The pointer to the time span variable to be destroyed.
@end table

@item Returns
A status value:
@table @code
@item PDF_OK
The operation successfully finished.
@end table
@item Usage example
@example
pdf_time_span_t span;

/* ...create and manipulate `span'... */

pdf_time_span_destroy (span);
@end example
@end table
@end deftypefun

@node Managing Time Span Values
@subsection Managing Time Span Values

@deftypefun pdf_status_t pdf_time_span_set (pdf_time_span_t *@var{p_span}, const pdf_i32_t @var{high_value}, const pdf_u32_t @var{low_value})

Set the value of a time span. The internal representation of the time
span is 64 bits long (signed).

@table @strong
@item Parameters

@table @var
@item p_span
A pointer to a properly created time span variable.
@item high_value
The high (signed) part of the time span value.
@item low_value
The low (unsigned) part of the time span value.
@end table

@item Returns
A status value:
@table @code
@item PDF_OK
The operation successfully finished.
@end table

@item Usage exaple
@example
pdf_time_span_t span;

span = pdf_time_span_new ();
pdf_time_span_set (&span, (32 << 1), 10); /* The span is -10 seconds long */
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_time_span_set_from_i32 (pdf_time_span_t *@var{p_span}, const pdf_i32_t @var{seconds})

Set the value of a time span from a 32 bits signed number.

@table @strong
@item Parameters

@table @var
@item p_span
A pointer to a properly created time span variable.
@item seconds
A signed 32 bits number.
@end table

@item Returns
A status value:
@table @code
@item PDF_OK
The operation successfully finished.
@end table

@item Usage example
@example
pdf_time_span_t span;

span = pdf_time_span_create ();
pdf_time_span_set_from_i32 (&span, -10); /* The span is -10 seconds long */
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_time_span_negate (pdf_time_span_t *@var{p_span})

Make a positive time span into a negative one or make a negative time
span into a positive one.

@table @strong
@item Parameters

@table @var
@item span
A pointer to a properly created time span variable.
@end table

@item Returns
A status value:
@table @code
@item PDF_OK
The operation successfully finished.
@end table

@item Usage example
@example
pdf_time_span_t span;

/* ...create and manipulate `span'... */

pdf_time_span_negate (span);
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_time_span_add (const pdf_time_span_t @var{span1}, const pdf_time_span_t @var{span2}, pdf_time_span_t *@var{p_result})

Add two time spans and store the result in another time span.

@table @strong
@item Parameters

@table @var
@item span1
The first time span to add.
@item span2
The second time span to add.
@item p_result
The pointer to the time span holding the result of the add operation. Any previous
content is lost.
@end table

@item Returns
A status value:
@table @code
@item PDF_OK
The operation successfully finished.
@end table

@item Usage example
@example
pdf_time_span_t span1;
pdf_time_span_t span2;
pdf_time_span_t result;

/* ...create and manipulate `span1', `span2' and `result'... */
pdf_time_span_add (span1, span2, &result);
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_time_span_copy (const pdf_time_span_t @var{orig}, pdf_time_span_t *@var{p_dest})

Copy the value of a time span into another time span.

@table @strong
@item Parameters

@table @var
@item orig
The origin time span.
@item p_dest
The pointer to the time span variable that will hold the value of @var{orig}. Any
previous value is lost.
@end table

@item Returns
A status value:
@table @code
@item PDF_OK
The operation successfully finished.
@end table

@item Usage example
@example
pdf_time_span_t span_orig;
pdf_time_span_t span_dest;

/* ...create and manipulate `span_orig' and `span_dest'... */

pdf_time_span_copy (span_orig, span_dest);
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_time_span_diff (const pdf_time_span_t @var{span1}, const pdf_time_span_t @var{span2}, pdf_time_span_t *@var{p_result})

Difference two time spans and store the result (maybe negative) into
another time span.

@table @strong
@item Parameters

@table @var
@item span1
The first time span to diff.
@item span2
The second time span to diff.
@item p_result
The result of the diff operation. Any previous value of the time span
is lost.
@end table

@item Returns
A status value:
@table @code
@item PDF_OK
The operation successfully finished.
@end table

@item Usage example
@example
pdf_time_span_t span1;
pdf_time_span_t span2;
pdf_time_span_t span_diff;

/* ...create and manipulate `span1', `span2' and `span3' */

pdf_time_span_diff (span1, span2, span_diff);
@end example
@end table
@end deftypefun

@deftypefun pdf_i64_t pdf_time_span_to_secs (const pdf_time_span_t @var{span})

Get the value of a time span in seconds. 

@table @strong
@item Parameters

@table @var
@item span
A properly created time span variable.
@end table

@item Returns
The value of the time span in seconds.
A negative value is returned if the time span is negative.
@item Usage example
@example
pdf_time_span_t span;
pdf_i32_t num_seconds;

/* ...create and manipulate `span'... */

num_seconds = pdf_time_span_to_secs (span);
@end example
@end table
@end deftypefun

@node Time Span Comparison
@subsection Time Span Comparison

@deftypefun pdf_i32_t pdf_time_span_cmp (const pdf_time_span_t @var{span1}, const pdf_time_span_t @var{span2})

Compare the length two time spans.

@table @strong
@item Parameters

@table @var
@item span1
The first time span to compare.
@item span2
The second time span to compare.
@end table

@item Returns
A status value:
@table @code
@item -1
The length of @var{span1} is shorter than the length of @var{span2}.
@item 0
The lengts of @var{span1} and @var{span2} are equal.
@item +1
The length of @var{span1} is greater than the length of @var{span2}.
@end table

@item Usage example
@example
pdf_time_span_t span1;
pdf_time_span_t span2;

/* ...create and manipulate `span1' and `span2'... */
switch (pdf_time_span_cmp (span1, span2))
@{
  case -1:
  @{
    /* The length of `span1' is shorter than the length of `span2' */
    break;
  @}
  case 0:
  @{
    /* The length of `span1' is equal to the length of `span2' */
    break;
  @}
  case 1:
  @{
    /* The length of `span1' is greater than the length of `span2' */
    break;
  @}
@}
@end example
@end table
@end deftypefun

@node Calendar Spans Management
@subsection  Calendar Spans Management

@deftypefun pdf_status_t pdf_time_add_cal_span_with_base (const struct pdf_time_cal_span_s *@var{p_span1}, const struct pdf_time_cal_span_s *@var{p_span2}, const pdf_time_t @var{base_time}, struct pdf_time_cal_span_s *@var{p_result})

Add two calendar spans. Since the calendar spans are relative (some
years has more days than another) the calendar spans are first
resolved from a base time.

@table @strong
@item Parameters

@table @var
@item p_span1
The pointer to the first calendar span to add.
@item p_span2
The pointer to the second calendar span to add.
@item base_time
The base time to use.
@item p_result
Pointer to the calendar span to store the result of the add operation.
@end table

@item Returns
A status value:
@table @code
@item PDF_OK
The operation successfully finished.
@item PDF_EBADDATA
There is invalid data in @var{span1} or @var{span2}.
@end table

@item Usage example
@example
pdf_time_t mytime;
struct pdf_time_cal_span_s cal_span1;
struct pdf_time_cal_span_s cal_span2;
struct pdf_time_cal_span_s cal_result;

/* ...create and initialize `mytime', `cal_span1'
 *    and `cal_span2'...
 */

if (pdf_time_add_cal_span_with_base (&cal_span1,
                                     &cal_span2,
                                     mytime,
                                     &cal_result) == PDF_EBADDATA)
@{
  /* Invalid data in `cal_span1' or `cal_span2' */
@}      
@end example
@end table
@end deftypefun


@deftypefun pdf_i32_t pdf_time_cal_span_cmp (const struct pdf_time_cal_span_s *@var{p_span1}, const struct pdf_time_cal_span_s *@var{p_span2}, const pdf_time_t @var{base_time}, pdf_status_t *p_ret_code)

Compare two calendar spans previously resolved with a given base time.

@table @strong
@item Parameters

@table @var
@item p_span1
The pointer to the first calendar span to be compared.
@item p_span2
The pointer to the second calendar span to be compared.
@item base_time
The used base time. Should be a correctly created time variable.
@item p_ret_code
Pointer to a status variable to store any error happened in the function.
@end table

@item Returns

@table @code
@item -1
Given the base time, the time interval defined by @var{p_span2} is
greater in length than the time interval defined by @var{p_span1}.
@item 0
Given the base time, the time inveral defined by @var{p_span1} is equal
in length than the time interval defined by @var{p_span2}.
@item +1
Given the base time, the time interval defined by @var{p_span1} is
greater in length than the time interval defined by @var{p_span2}.
@end table

@item Usage example
@example
pdf_time_t mytime;
struct pdf_time_cal_span_s span1;
struct pdf_time_cal_span_s span2;

/* ...create and manipulate `mytime', `span1' and `span2'... */

switch (pdf_time_cal_span_cmp (&span1, &span2, mytime))
@{
  case -1:
  @{
    /* The length of `span1' is shorter than the length of `span2' */
    break;
  @}
  case 0:
  @{
    /* The length of `span1' is equal than the length of `span2' */
    break;
  @}
  case 1:
  @{
    /* The length of `span1' is greater than the length of `span2' */
    break;
  @}
@}
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_time_cal_span_diff (const struct pdf_time_cal_span_s *@var{p_span1}, const struct pdf_time_cal_span_s *@var{p_span2}, const pdf_time_t @var{base_time}, struct pdf_time_cal_span_s *@var{p_result})

Compute the difference between two calendar spans relative to a given
base time and store it in a given calendar span.

@table @strong
@item Parameters

@table @var
@item p_span1
The pointer to the first calendar span to diff.
@item p_span2
The pointer to the second calendar span to diff.
@item base_time
The base time. Should be a correctly created time variable.
@item p_result
Pointer to the calendar structure holding the result of the difference.
@end table

@item Returns
A status value:
@table @code
@item PDF_OK
The operation successfully finished.
@item PDF_EBADDATA
There is invalid data in @var{span1} or @var{span2}.
@end table

@item Usage example
@example
pdf_time_t mytime;
struct pdf_time_cal_span_s span1;
struct pdf_time_cal_span_s span2;
struct pdf_time_cal_span_s result;

/* ...create and manipulate `span1', `span2' and 
 *    `result'... 
 */

if (pdf_time_cal_span_diff (&span1,
                            &span2,
                            mytime,
                            &result) == PDF_EBADDATA)
@{
  /* Invalid data in `span1' or `span2' */
@}
@end example
@end table
@end deftypefun

@node Platform-specific functions
@subsection Platform-specific functions

@deftypefun pdf_status_t pdf_time_w32_set_from_filetime (pdf_time_t @var{time_var}, const FILETIME *@var{p_filetime})
This function will initialize @var{time_var} to the given Filetime epoch in UTC timescale.

This function is only available in Windows OS.

@table @strong
@item Parameters
@table @var
@item time_var 
The time variable to set. Should be a properly create time variable.
@item p_filetime
Pointer to a valid FILETIME structure, containing 100-nanosecond intervals since 1 January 1601.
@end table
@item Returns
A status value:
@table @code
@item PDF_OK
The operation succeeded.
@end table
@item Usage example
@example
pdf_time_t mytime;
FILETIME filetime;
mytime = pdf_time_new ();

/* do stuff to get the FILETIME */

pdf_time_w32_set_from_filetime(mytime, &filetime);

@end example
@end table
@end deftypefun



@node The Filesystem Module
@section The Filesystem Module

@menu
* Filesystem Concepts::
* Filesystem Interfaces::
* The Filesystem Interface::
* The File Interface::
* The Filesystem Implementation Interface::
* The Filesystem Definition Interface::
@end menu

@node Filesystem Concepts
@subsection Filesystem Concepts

Filesystem objects provides access to file system services in an
abstract way, letting the library client to define filesystems for
other classes of devices. Open files are readable or writeable file
items in a filesystem. Path names are named locations identifying
files or folders.

In the GNU PDF Library a filesystem object (of type @code{pdf_fsys_t}) is
an implementation of the file system services for a specific class of
devices. The filesystem object provides the functionality to open
files, read and write data from/to open files, create and delete
folders, rename files, manage file and folder permissions, etc.

By implementing the functions defined in the Filesystem Implementation
Interface the client can define and use its own filesystems. In this
way a high level of abstraction is achieved in the library code that
uses the filesystem services: the library is able to read the contents
of a PDF file from a file stored in the local filesystem, from a
network webdav based filesystem, an http server or a compressed image.

The GNU PDF Library provides the default @emph{disk} filesystem
implementation for each supported plattform.

Conceptually speaking a filesystem contain a tree (or several
trees in some filesystem implementations supporting several
volumes) of @emph{filesystem items}. 

Each time has a type and several properties. The client can ask the
filesystem for the properties of a given item identified by a path
name.

An open file object (of type @code{pdf_fsys_file_t}) represent a readable
and/or writable file in a filesystem. Open files are associated with a
given filesystem and any filesystem can maintain an arbitrary number
of open files (this may depend on the specific filesystem
implementation).

The client can read and write data from/to an open file using the
@code{pdf_fsys_file_*} functions. The implementation of the open files
then call to the appropriate functionality of the filesystem managing
the file.

The client should close any opened file calling the appropriate
function on the underlying filesystem.

There is not an explicit data type for an @emph{open folder} in the GNU
PDF Library. Instead, folders are referred using @emph{path names}.

The Filesystem Interface provides functions to create, delete and
rename folders.

Both files and folders in a filesystem can be referred using a string
locator: a @emph{path name}. Path names are implemented using PDF
strings. Several path names can refer to the same file or folder.

Both the encoding and the format of the contents of a path name
depends on the specific filesystem implementation. The default disk
filesystem provided by the GNU PDF Library uses the textual device
idependent file specifications described in the PDF Reference (section
3.10). The interpretation of those path names depend in the specific
plattform where the library is running. See XXX for more information
about the disk filesystem path names.

@node Filesystem Interfaces
@subsection Filesystem Interfaces

This section describes several interfaces that can be found in the
Filesystem module. There is an internal interface filesystem
implementors can implement to define a new filesystem. It is called
the @emph{Filesystem Implementation Interface}. A @emph{Filesystem Definition
Interface} allow users to register the implementation functions into a
filesystem variable. There are also two interfaces implemented by the
Filesystem module allowing clients to access the module functionality:
the @emph{Filesystem Interface}, used to manage several filesystem
aspects, and the @emph{File Interface}, that provides functionalities
related to open files, such as reading and writing information.

The following interface diagram show the relation between the
filesystem interface, the filesystem definition interface, the
filesystem implementation interface and the file interface:

@node The Filesystem Interface
@subsection The Filesystem Interface

The Filesystem Interface is implemented by the Filesystem module and
provides access to some filesystem functionalities in a filesystem
implementation independent way.

The functionality covered by the Filesystem Interface includes:

@itemize @bullet
@item
Folder management.
@item
Folder contents management. 
@item
Volume-level flush operations.
@item
Read In Advance (RIA) capabilities.
@item
Storage properties management (free space, etc).
@item
Management of filesystem items (rename, remove, flags, etc).
@item
Utility functions (get a path name for a temporal file, etc).
@end itemize

Note that not all the filesystem implementations support these
operations. Read In Advance capabilities, for example, are usually
implemented in slow file system devices such as network
filesystems. When a specific filesystem implementation does not support
a functionality in the Filesystem Interface then the specific call
becomes a no-op.

@menu
* Filesystem Data Types::
* Getting File System Properties::
* Opening Files::
* Folder Management::
* Getting File System Item Properties::
* File System Utility Functions::
@end menu

@node Filesystem Data Types
@subsubsection Filesystem Data Types

The following data types are defined and provided to the client by the
Filesystem Module.

@deftp {Data Type} pdf_fsys_t
An opaque type representing a filesystem.
@end deftp


@deftp {Data Type} struct pdf_fsys_item_props_s
This structure holds information about a filesystem item (a file or a
directory).

@table @code
@item pdf_bool_t is_hidden
@item pdf_bool_t is_readable
@item pdf_bool_t is_writable
@item pdf_time_t creation_date
@item pdf_time_t modification_date
@item pdf_u32_t file_size_high
@item pdf_u32_t file_size_low
@item pdf_u32_t folder_size
@end table
@end deftp

@node Getting File System Properties
@subsubsection Getting File System Properties

@deftypefun pdf_size_t pdf_fsys_get_free_space (pdf_fsys_t @var{filesystem}, pdf_text_t @var{path_name})

Get the free storage space in the volume containing @var{path_name}.

@table @strong
@item Parameters
@table @var
@item file_system
A filesystem. If @code{NULL} then the default filesystem is used.
@item path_name
A path name.
@end table
@item Returns
A PDF size value containing the remaining free space in the volume
containing @var{path_name}.
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@node Opening Files
@subsubsection Opening Files

@deftypefun pdf_status_t pdf_fsys_open (const pdf_fsys_t @var{filesystem}, const pdf_text_t @var{path_name}, const enum pdf_fsys_file_mode_e @var{mode}, pdf_fsys_file_t @var{file})

Open a file in @var{filesystem} identified by @var{path_name} using
the specified @var{mode} and store a new open file variable in
@var{file}.

@table @strong
@item Parameters
@table @var
@item filesystem
A filesystem. If @code{NULL} the default filesystem is used.
@item path_name
A path name that identifies the file to be opened. The format and
encoding of this text variable depends on the underlying filesystem
implementation. 
@item mode
The open mode to use to open the file.
@item file
The output file variable.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK 
The file was successfully opened and stored in the @var{file}
variable.
@item PDF_EBADNAME
The path name specified in @var{path_name} does not identify an existing
file in the filesystem.
@item PDF_EBADPERMS
The client does not have permission to open the specified file using the
specified mode. 
@item PDF_ENOMEM
Not enough memory.
@end table
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun               

@node Folder Management
@subsubsection Folder Management

@deftypefun pdf_status_t pdf_fsys_create_folder (const pdf_fsys_t @var{filesystem}, const pdf_text_t @var{path_name})

Create a folder named @var{path_name}.

@table @strong
@item Parameters
@table @var
@item filesystem
A filesystem. If @code{NULL} the default filesystem is used.
@item path_name
The path name of the folder to be created.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The folder was successfully created.
@item PDF_EBADNAME
The specified @var{path_name} is incorrect.
@item PDF_EBADPERMS
The client does not have permissions to create the folder.
@item PDF_ERROR
Any other error condition.
@end table
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_fsys_get_folder_contents (const pdf_fsys_t @var{filesystem}, const pdf_text_t @var{path_name}, pdf_list_t @var{item_list})

Get a list with the path names of the items contained in a given folder.

@table @strong
@item Parameters
@table @var
@item filesystem
A filesystem. If @code{NULL} the default filesystem is used.
@item path_name
The path name of a folder.
@item item_list
An output list variable to hold the path names of the items contained
in the folder.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The operation was successfully performed.
@item PDF_EBADNAME
@var{path_name} does not name a folder in the filesystem.
@item PDF_EBADPERMS
The client does not have permissions to read the contents of the folder.
@item PDF_ERROR
Any other error condition.
@end table
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_fsys_get_parent (const pdf_fsys_t @var{filesystem}, const pdf_text_t @var{path_name}, pdf_text_t @var{parent_path})

Get the path name of the father of a given item in the filesystem.

@table @strong
@item Parameters
@table @var
@item filesystem
A filesystem. If @code{NULL} the default filesystem is used.
@item path_name
The path name of an item in the filesystem.
@item parent_path 
Output text variable to hold the path of the parent of the item
identified by @var{path_name}. If @var{path_name} is the root
directory then @code{NULL} is returned in @var{parent_path}.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The path name of the parent of the item was successfully stored in
@var{parent_path}.
@item PDF_EBADNAME
@var{path_name} does not name a valid item in the filesystem.
@item PDF_EBADPERMS
The client does not have permissions to get the parent of the specified
item.
@end table
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_fsys_remove_folder (const pdf_fsys_t @var{filesystem}, const pdf_text_t @var{path_name})

Remove an empty folder from the filesystem.

@table @strong
@item Parameters
@table @var
@item filesystem
A filesystem. If @code{NULL} the default filesystem is used.
@item path_name
A path name of an empty folder in the filesystem.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The folder was successfully removed.
@item PDF_EBADNAME
@var{path_name} does not name a folder in the filesystem.
@item PDF_EBADPERMS
The client does not have permissions to remove the folder.
@item PDF_ERROR
Any other error.
@end table
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@node Getting File System Item Properties
@subsubsection Getting File System Item Properties

The following functions provides access to generic properties of
filesystem items (both files and directories).

@deftypefun pdf_status_t pdf_fsys_get_item_props (pdf_fsys_t @var{filesystem}, pdf_text_t @var{path_name}, struct pdf_fsys_item_props_s *@var{item_props})

Get the properties of a filesystem item identified by a path name.

@table @strong
@item Parameters
@table @var
@item filesystem
A filesystem. If @code{NULL} the default filesystem is used.
@item path_name
A pdf string containing the path name of the filesystem item.
@item item_props
The address of a structure to hold the properties of the filesystem
item.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The operation succeeded.
@item PDF_EBADDATA
Invalid path name.
@item PDF_EBADPERMS
The client does not have enough permissions to read the requested item.
@end table
@item Usage example
@example
struct pdf_fsys_item_props_s item_props;
pdf_text_t path = pdf_text_new_from_unicode ("/path/to/foo",
                                             12, PDF_TEXT_UTF8,
                                             &text);
/* Get the properties for the item */
pdf_status_t ret = pdf_fsys_get_item_props (NULL, path, &item_props);
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_fsys_item_props_to_hash (const struct pdf_fsys_item_props_s @var{item_props}, pdf_hash_t @var{props_hash})

Get a PDF hash variable containing the properties of a filesystem
item.

The key-value pairs returned in the hash variable are the following:

@table @code
@item isHidden
Boolean value.
@item isReadable
Boolean value.
@item isWritable
Boolean value.
@item creationDate
Text value containing a PDF style date string.
@item modDate
Text value containing a PDF style date string.
@item fileSizeHigh
32bit unsigned integer value.
@item fileSizeLow
32bit unsigned integer value.
@item folderSize
32bit unsigned integer value.
@item creatorCode
32bit unsigned integer value.
@item versionMajor
32bit unsigned integer value.
@item versionMinor
32bit unsigned integer value.
@item isCheckedOut
Boolean value.
@item isPublished
Boolean value.
@end table

@table @strong
@item Parameters
@table @var
@item item_props
A filesystem item properties structure.
@item props_hash
A PDF hash variable. It will be filled with the properties of the
item.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The operation succeeded and the properties were stored in the hash
variable.
@end table
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@deftypefun pdf_bool_t pdf_fsys_item_p (pdf_fsys_t @var{filesystem}, pdf_text_t @var{path_name})

Determine if a given item, identified by a path name, exists in a given
filesystem.

@table @strong
@item Parameters
@item filesystem
A filesystem. If @code{NULL} the default filesystem is used.
@item path_name
A path name.
@item Returns
A PDF boolean value:
@table @code
@item PDF_TRUE
The specified item exists in the filesystem.
@item PDF_FALSE
The specified item does not exist in the filesystem or the client does not
have enough permissions to be able to read it.
@end table
@item Usage example
@example
pdf_bool_t ret;
pdf_text_t path = pdf_text_new_from_unicode ("/path/to/foo",
                                             12, PDF_TEXT_UTF8,
                                             &text);
/* Test whether the path to /path/to/foo is a valid path to foo */
pdf_bool_t ret = pdf_fsys_item_p (NULL, path);
@end example
@end table
@end deftypefun

@deftypefun pdf_bool_t pdf_fsys_item_readable_p (pdf_fsys_t @var{filesystem}, pdf_text_t @var{path_name})

Determine if a given filesystem item, identified by a path name, is
readable.

@table @strong
@item Parameters
@table @var
@item filesystem
A filesystem. If @code{NULL} the default filesystem is used.
@item path_name
A valid path name of an existing filesytem item.
@end table
@item Returns
A PDF boolean value:
@table @code
@item PDF_TRUE
The filesystem item is readable.
@item PDF_FALSE
The filesystem item is not readable.
@end table
@item Usage example
@example
pdf_text_t path = pdf_text_new_from_unicode ("/path/to/foo",
                                             12, PDF_TEXT_UTF8,
                                             &text);
/* Determine if the item is readable */
pdf_bool_t ret = pdf_fsys_item_readable_p (NULL, path);
@end example
@end table
@end deftypefun

@deftypefun pdf_bool_t pdf_fsys_item_writable_p (pdf_fsys_t @var{filesystem}, pdf_text_t @var{path_name})

Determine if a given filesystem item, identified by a path name, is
writable. 

@table @strong
@item Parameters
@table @var
@item filesystem
A filesystem. If @code{NULL} the default filesystem is used.
@item path_name
A valid path name of an existing filesystem item.
@end table
@item Returns
A PDF boolean value:
@table @code
@item PDF_TRUE
The filesystem item is writable.
@item PDF_FALSE
The filesystem item is not writable.
@end table
@item Usage example
@example
pdf_text_t path = pdf_text_new_from_unicode ("/path/to/foo",
                                             12, PDF_TEXT_UTF8,
                                             &text);
/* Determine if the item is writable */
pdf_bool_t ret = pdf_fsys_item_writable_p (NULL, path);
@end example
@end table
@end deftypefun

@node File System Utility Functions
@subsubsection File System Utility Functions

@deftypefun pdf_text_t pdf_fsys_get_temp_path_name (pdf_fsys_t @var{filesystem})

Return a path name for a new temporary file in the specified filesystem.

@table @strong
@item Parameters
@table @var
@item file_system
A filesystem.
@end table
@item Returns
A PDF text variable containing a path name.
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@node The File Interface
@subsection The File Interface

The File Interface is implemented by the filesystem module and
provides access to filesystem functionality related with open files,
such as writing and reading data to/from a specific file.

Note that open file variables (@code{pdf_fsys_file_t}) contain a
reference to its underlying filesystem implementation, so the client
should only provide a correctly initialized (opened) file variable to
the @code{pdf_fsys_file_*} functions.

The functionality covered by the File Interface includes:

@itemize @bullet
@item
Synchronous Input/Output.
@item
Asynchronoous Input/Output (not to be confused with RIA. See above).
@item
File-level flush operations.
@item
File positioning management.
@item
File size management.
@item
File flags (status) management.
@end itemize

@menu
* File Data Types::
* File Properties Management::
* Comparing Files::
* Managing File Positions::
* Changing the Size of a File::
* Synchronous Input/Output::
* Read in Advance::
* Closing and Reopening Files::
@end menu

@node File Data Types
@subsubsection File Data Types

The following file-related data types are defined and provided to the
client by the Filesystem Module.

@deftp {Data Type} pdf_fsys_file_t
An opaque type representing an open file. The client can perform
several operations in the file using the @code{pdf_fsys_file_t} as a
reference.
@end deftp

@deftp {Data Type} {enum pdf_fsys_file_mode_e}

The mode used when opening a file in a filesystem. The available modes
are described in the following list.

@table @code
@item PDF_FSYS_OPEN_MODE_READ
The file is opened in read-only mode. The file should exist in the
filesystem.
@item PDF_FSYS_OPEN_MODE_WRITE
The file is opened in write-only mode. The file is truncated to 0
size (any previous contents are lost) if the file exists and it is
created if it does not exist.
@item PDF_FSYS_OPEN_MODE_RW
The file is opened in read/write mode. The file should exist in the
filesystem.
@item 
@end table
@end deftp

@node File Properties Management
@subsubsection File Properties Management

The following functions provides access to several properties of open
files. 

@deftypefun pdf_size_t pdf_fsys_file_get_size (pdf_fsys_file_t @var{file})

Get the size (in number of octects) of a given open file.

@table @strong
@item Parameters
@table @var
@item file
An open file.
@end table
@item Returns
The size of the file in octects.
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@deftypefun pdf_fsys_t pdf_fsys_file_get_filesystem (pdf_fsys_file_t @var{file})

Get the filesystem associated with a given open file.

@table @strong
@item Parameters
@table @var
@item file
An open fiile.
@end table
@item Returns
The filesystem associated with @var{file}.
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@deftypefun {enum pdf_fsys_file_mode_e} pdf_fsys_file_get_mode (pdf_fsys_file_t @var{file})

Return the access mode used to open a given file.

@table @strong
@item Parameters
@table @var
@item file
An open file.
@end table
@item Returns
A mode value if successful, otherwise returns -1.
@item Usage example
@example
pdf_status_t ret;
pdf_fsys_file_t file = pdf_alloc(sizeof(pdf_fsys_file_s));
pdf_text_t path = pdf_text_new_from_unicode ("/path/to/foo",
                                             12, PDF_TEXT_UTF8,
                                             &text);
ret = pdf_fsys_open (path, PDF_FSYS_OPEN_MODE_READ, file);

enum pdf_fsys_file_mode_e mode;
mode = pdf_fsys_file_get_mode(file);
@end example
@end table
@end deftypefun

@deftypefun pdf_text_t pdf_fsys_file_get_url (pdf_fsys_file_t @var{file})

Get a text variable containing a valid URL to refer to a given open
file. Note that for some filesystems could be not possible to build a
valid URL.

@table @strong
@item Parameters
@table @var
@item file
An open file.
@end table
@item Returns
A PDF text variable containing a valid URL that can be used to refer
to the open file.

If the filesystem does not support URLs then an empty string is
returned.
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_fsys_file_set_mode (pdf_fsys_file_t @var{file}, enum pdf_fsys_file_mode_e @var{new_mode})

Update the mode of a given open file.

@table @strong
@item Parameters
@table @var
@item file
An open file.
@item new_mode
The new mode to set for the file.
@end table
@item Returns
Returns PDF_OK if the mode is set to the new mode, otherwise returns
an appropriate pdf_status_t error.
A PDF status value:
@table @code
@item PDF_OK
The operation succeeded.
@item PDF_EBADDATA
The mode provided was invalid.
@item PDF_ERROR
General failure, most applicable to Win32.
@end table
@item Usage example
@example
pdf_status_t ret;
pdf_fsys_file_t file = pdf_alloc(sizeof(pdf_fsys_file_s));
pdf_text_t path = pdf_text_new_from_unicode ("/path/to/foo",
                                             12, PDF_TEXT_UTF8,
                                             &text);
ret = pdf_fsys_open (path, PDF_FSYS_OPEN_MODE_WRITE, file);

enum pdf_fsys_file_mode_e mode = PDF_FSYS_OPEN_MODE_READ;
ret = pdf_fsys_file_set_mode(file, mode);
@end example
@end table
@end deftypefun

@node Comparing Files
@subsubsection Comparing Files

The following functions allow to compare files.

@deftypefun pdf_bool_t pdf_fsys_file_same_p (pdf_fsys_file_t @var{file}, pdf_text_t @var{path})

Determine whether a given open file is the same file as a given file
identified by a file path.

@table @strong
@item Parameters
@table @var
@item file
An open file.
@item path
A file path.
@end table
@item Returns
A PDF boolean value:
@table @code
@item PDF_TRUE
Both files are the same file.
@item PDF_FALSE
The files are not the same file, or the given pathname does not identify
a file in the underlying filesystem.
@end table
@item Usage example
@example
pdf_bool_t ret;
pdf_fsys_file_t file; /* some pre-initialized file variable */
pdf_text_t other_path = pdf_text_new_from_unicode ("/path/to/baz",
                                                   12, PDF_TEXT_UTF8,
                                                   &text);
ret = pdf_fsys_file_same_p (file, other_path);
@end example
@end table
@end deftypefun

@node Managing File Positions
@subsubsection Managing File Positions

The following functions allow to move the input/output pointer of a
buffer file (its ``current position'').

@deftypefun pdf_status_t pdf_fsys_file_get_pos (pdf_fsys_file_t @var{file}, pdf_size_t *@var{pos})

Get the current position (in octects) in a given open file.

@table @strong
@item Parameters
@table @var
@item file
An open file.
@item pos
The address of a @code{pdf_size_t} variable.
@end table
@item Returns
A PDF status variable:
@table @code
@item PDF_OK
The operation was successfully performed.
@item PDF_ERROR
The function call failed due to an error.
@end table
@item Usage example
@example
pdf_status_t ret;
pdf_fsys_file_t file = pdf_alloc(sizeof(pdf_fsys_file_s));
pdf_text_t path = pdf_text_new_from_unicode ("/path/to/foo",
                                             12, PDF_TEXT_UTF8,
                                             &text);
ret = pdf_fsys_open (path, PDF_FSYS_OPEN_MODE_WRITE, file);

pdf_size_t pos = 20;
ret = pdf_fsys_file_get_pos(file, pos);
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_fsys_file_set_pos (pdf_fsys_file_t @var{file}, pdf_size_t @var{new_pos})

Set the current position in a given open file.

@table @strong
@item Parameters
@table @var
@item file
An open file.
@item new_pos
The new position of the file.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The operation succeeded.
@item PDF_EBADDATA
Invalid new position.
@item PDF_EBADPERMS
The client does not have enough permissions to change the current file
position.
@end table
@item Usage example
@example
pdf_status_t ret;
pdf_fsys_file_t file = pdf_alloc(sizeof(pdf_fsys_file_s));
pdf_text_t path = pdf_text_new_from_unicode ("/path/to/foo",
                                             12, PDF_TEXT_UTF8,
                                             &text);
ret = pdf_fsys_open (path, PDF_FSYS_OPEN_MODE_WRITE, file);

pdf_size_t pos = 20;
ret = pdf_fsys_file_set_pos(file, pos);
@end example
@end table
@end deftypefun

@node Changing the Size of a File
@subsubsection Changing the Size of a File


@deftypefun pdf_bool_t pdf_fsys_file_can_set_size_p (pdf_fsys_file_t @var{file}, pdf_size_t @var{size})

Determine if a given open file is resizeable to a given size.

@table @strong
@item Parameters
@table @var
@item file
An open file.
@item size
The new size for the file in octects.
@end table
@item Returns
A PDF boolean value:
@table @code
@item PDF_TRUE
The file can be resized to the given size.
@item PDF_FALSE
The file cannot be resized to the given size.
@end table
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_fsys_file_set_size (pdf_fsys_file_t @var{file}, pdf_size_t @var{size})

Resize a given file to a given new size measured in octects.

@table @strong
@item Parameters
@table @var
@item file
An open file.
@item new_size
The new size for the file. If it is bigger than the previous size then
the file is augmented to that size. If it is shorter than the previous
size then the file gets truncated.
@end table
@item Returns
A PDF size value indicating the new size of the file. It should match
the requested new size, or is @code{0} if there is an error.
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun


@node Synchronous Input/Output
@subsubsection Synchronous Input/Output

The following functions provides synchronous input/output for open
files.

@deftypefun pdf_size_t pdf_fsys_file_read (pdf_fsys_file_t @var{file}, const pdf_size_t @var{elem_size}, const pdf_size_t @var{elem_count}, void *@var{data})

Synchronously read data from an open file item.

@table @strong
@item Parameters
@table @var
@item file
An open file variable.
@item elem_size
The size of the data chunks to read from the file.
@item elem_count
The number of data chunks to read from the file.
@item data
A pointer to memory used to store the readed elements.
@end table
@item Returns
A PDF size value indicating the number of readed octects or @code{0} if there
was an error.
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@deftypefun pdf_size_t pdf_fsys_file_write (pdf_fsys_file_t @var{file}, const pdf_size_t @var{elem_size}, const pdf_size_t @var{elem_count}, void *@var{data})

Synchronously write data to an open file item.

@table @strong
@item Parameters
@table @var
@item file
An open file variable.
@item elem_size
The size of the data chunks to write into the file.
@item elem_count
The number of data chunks to be write into the file.
@item data
A pointer to memory containing the data to write into the file.
@end table
@item Returns
A PDF size value indicating the number of octects written into the
file or @code{0} if there was an error.
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_fsys_file_flush (pdf_fsys_file_t @var{file})

Flush all the written data for the specified file.

@table @strong
@item Parameters
@table @var
@item file
An open file variable.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The open file was flushed successfully.
@item PDF_EBADDATA
Bad function parameters to underlying @code{write()}.
@item PDF_EAGAIN
Try again.
@item PDF_ERROR
There was an error flushing the open file.
@end table
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@node Read in Advance
@subsubsection Read in Advance

When working with slow filesystems (such as network filesystems) it is
useful to be able to request parts of the file in advance.

@deftypefun pdf_status_t pdf_fsys_file_request_ria (pdf_fsys_file_t @var{file}, pdf_size_t @var{offset}, pdf_size_t @var{count})

Request a Read-In-Advance operation in a given open file.

Note that it is up to the underlying filesystem to honour the
operation. If the filesystem does not implement RIA capabilities then
this function is a no-op.

@table @strong
@item Parameters
@table @var
@item file
An open file.
@item offset
The beginning of the requested block.
@item count
The size (in octects) of the requested block.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The operation succeeded.
@item PDF_ERROR
An error occurred.
@end table
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@deftypefun pdf_bool_t pdf_fsys_file_has_ria (pdf_fsys_file_t @var{file})

Determine whether the filesystem is performing some RIA operation for
the given open file.

Note that it is up to the underlying filesystem to honour the
operation. If the filesystem does not implement RIA capabilities then
this function always return @code{PDF_FALSE}.

@table @strong
@item Parameters
@table @var
@item file
An open file.
@end table
@item Returns
A PDF boolean value:
@table @code
@item PDF_TRUE
The filesystem is performing some RIA operation in the given file.
@item PDF_FALSE
There is not an outstanding RIA operation in the given file.
@end table
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_fsys_file_cancel_ria (pdf_fsys_file_t @var{file})

Cancel any pending RIA operation in a given open file.

Note that it is up to the underlying filesystem to honour the
operation. If the filesystem does not implement RIA capabilities then
this function is a no-op.

@table @strong
@item Parameters
@table @var
@item file
An open file.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
Any pending RIA operation was cancelled.
@end table
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@node Closing and Reopening Files
@subsubsection Closing and Reopening Files

The following functions allow to close an open file or to reopen it
using another file mode.

@deftypefun pdf_status_t pdf_fsys_file_close (pdf_fsys_file_t @var{file})

Close a given open file. Any pending output data is flushed before to
close the file.

@table @strong
@item Parameters
@table @var
@item file
An open file.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The file was successfully closed.
@item PDF_ERROR
There was an error closing the file.
@end table
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_fsys_file_reopen (pdf_fsys_file_t @var{file}, enum pdf_fsys_file_mode_e @var{mode})

Reopen a given open file with a given mode.

@table @strong
@item Parameters
@table @var
@item file
An open file.
@item mode
A file mode.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The file was successfully reopened using the new mode.
@item PDF_EBADPERMS
The client does not have enough permissions to open the file using the
specified mode. The open file is now closed.
@end table
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun


@node The Filesystem Implementation Interface
@subsection The Filesystem Implementation Interface

The filesystem implementation interface is a set of functions that are
installed in a @code{pdf_fsys_t} variable in order to provide its
functionality. By implementing those functions the client can provide
a filesystem for some (physical or logical) storage device: a webdav
directory, a read-only http filesystem, etc.

Note that the functions conforming the Implementation Interface are
not intended to be directly invoked by clients. Clients can access to
the functionality of the filesystem using indirect ways:

@itemize @bullet
@item
Making calls to the Filesystem Interface.
@item
Making calls to the File Interface.
@end itemize

The implementation of both interfaces then makes use of the Filesystem
Implementation Interface in order to honour the petition.

@menu
* File System Interface Implementation::
* File Interface Implementation::
@end menu

@node File System Interface Implementation
@subsubsection File System Interface Implementation

@deftp {Data Type} {pdf_status_t (*pdf_fsys_open_fn_t) (pdf_text_t @var{path_name}, enum pdf_fsys_file_mode_e @var{mode}, pdf_fsys_file_t @var{file})}

Filesystem callback called to open a file identified by the path
@var{path_name} in the mode specified by @var{mode}. A new
@code{pdf_fsys_file_t} is created and stored in @var{file}.

This callback is called by the @code{pdf_fsys_open} filesystem
interface function.
@end deftp

@deftp {Data Type} {pdf_status_t (*pdf_fsys_close_fn_t) (pdf_fsys_file_t @var{file})}

Filesystem callback used to close a given file identified by the
open file variable @var{file}. The output buffers of the file are
flushed before to close it.

This callback is called by the @code{pdf_fsys_close} filesystem
interface function.
@end deftp

The following callbacks are defined to provide folder management:
creation, deletion and modification of folders in the filesystem and
retrieval of folder contents.

@deftp {Data Type} {pdf_status_t (*pdf_fsys_create_folder_fn_t) (pdf_text_t @var{path_name})}

Filesystem callback used to create a folder identified by the
@var{path_name} path name.

This callback is called by the @code{pdf_fsys_create_folder}
filesystem interface function.
@end deftp

@deftp {Data Type} {pdf_status_t (*pdf_fsys_get_folder_contents_fn_t) (pdf_text_t @var{path_name}, pdf_list_t @var{item_list})}

Filesystem callback used to get the contents of a specified folder as
a list of path names.

This callback is called by the @code{pdf_fsys_get_folder_contents}
filesystem interface function.
@end deftp

@deftp {Data Type} {pdf_status_t (*pdf_fsys_get_parent_fn_t) (pdf_text_t @var{path_name}, pdf_text_t @var{parent_path})}

Filesystem callback used to get the path name of the father of a given
item in a filesystem. If @var{path_name} is the root directory then
NULL is returned in @var{parent_path}.

This callback is called by the @code{pdf_fsys_get_parent} filesystem
interface function.
@end deftp

@deftp {Data Type} {pdf_status_t (*pdf_fsys_remove_folder_fn_t) (pdf_text_t @var{path_name})}

Filesystem callback used to remove an empty folder identified by
@var{path_name}. 

This callback is called by the @code{pdf_fsys_remove_folder}
filesystem interface function.
@end deftp

The following callbacks are defined to provide synchronous
input/output in open files.

@deftp {Data Type} {pdf_size_t (*pdf_fsys_file_read_fn_t) (pdf_fsys_file_t @var{file}, pdf_size_t @var{elem_size}, pdf_size_t @var{elem_count}, void *@var{data})}

Filesystem callback used to synchronously read data from an open file
item.

This callback is called by the @code{pdf_fsys_file_read} file
interface function.
@end deftp

@deftp {Data Type} {pdf_size_t (*pdf_fsys_file_write_fn_t) (pdf_fsys_file_t @var{file}, pdf_size_t @var{elem_size}, pdf_size_t @var{elem_count}, void *@var{data})}

Filesystem callback used to synchronously write data to an open file
item.

This callback is called by the @code{pdf_fsys_file_write} file
interface function.
@end deftp

@deftp {Data Type} {pdf_status_t (*pdf_fsys_file_flush_fn_t) (pdf_fsys_file_t @var{file})}

Filesystem callback used to flush all the written data for the
specified file.

This callback is called by the @code{pdf_fsys_file_flush} file
interface function.
@end deftp

The following callbacks are defined to provide access to several
filesystem item properties. The file system items are addressed using
path names.

@deftp {Data Type} {pdf_status_t (*pdf_fsys_get_item_props_fn_t) (pdf_text_t @var{path_name}, struct pdf_fsys_item_props_s *@var{props})}

Filesystem callback used to get the properties of a named filesystem
item.

This callback is called by the @code{pdf_fsys_get_item_props}
filesystem interface function.
@end deftp

@deftp {Data Type} {pdf_size_t (*pdf_fsys_get_free_space_fn_t) (pdf_text_t @var{path_name})}

Filesystem callback used to get the free storage space in the volume
containing @var{path_name}.

This callback is called by the @code{pdf_fsys_get_free_space} file
system interface function.
@end deftp

@deftp {Data Type} {pdf_bool_t (*pdf_fsys_item_p_fn_t) (pdf_text_t @var{path_name})}

Filesystem callback used to determine whether a given item,
identified by a path name, exists in a given filesystem.

This callback is called by the @code{pdf_fsys_item_p} file system
interface function.
@end deftp

@deftp {Data Type} {pdf_bool_t (*pdf_fsys_item_readable_p_fn_t) (pdf_text_t @var{path_name})}

Filesystem callback used to determine whether a given filesystem
item, identified by a path name, is readable.

This callback is called by the @code{pdf_fsys_item_readable_p}
file system interface function.
@end deftp

@deftp {Data Type} {pdf_bool_t (*pdf_fsys_item_writable_p_fn_t) (pdf_fsys_t @var{filename}, pdf_text_t @var{path_name})}

Filesystem callback used to determine whether a given filesystem
item, identified by a path name, is writeable.

This callback is called by the @code{pdf_fsys_item_writeable_p} file
system interface function.
@end deftp

@deftp {Data Type} {pdf_text_t (*pdf_fsys_get_temp_path_name_fn_t) (void)}

Filesystem callback used to get a path name for a new temporary file
in teh specified filesystem.

This callback is called by the @code{pdf_fsys_get_temp_path_name} file
system interface function.
@end deftp

@node File Interface Implementation
@subsubsection File Interface Implementation

The following callbacks are defined to provide access to several file
properties.

@deftp {Data Type} {pdf_bool_t (*pdf_fsys_file_can_set_size_fn_t) (pdf_fsys_file_t @var{file}, pdf_size_t @var{pos})}

Filesystem callback used to determine if it is possible to set the
size of a given file to an especified value.

The callback should return a PDF bool value specifying if it is
possible to perform the operation.
@end deftp

@deftp {Data Type} {pdf_status_t (*pdf_fsys_file_get_size_fn_t) (pdf_fsys_file_t @var{file}, pdf_size_t @var{pos})}

Filesystem callback used to get the logical size of a file (in
octects).

The callback should return a PDF status value:
@table @code
@item PDF_OK
The operation was successfully performed and the logical size of the
file was stored in @var{pos}.
@item PDF_BADPERMS
The client does not have enough permissions to get the logical size of
@var{file}.
@end table
@end deftp

@deftp {Data Type} {pdf_status_t (*pdf_fsys_file_set_size_fn_t) (pdf_fsys_file_t @var{file}, pdf_size_t @var{pos})}

Filesystem callback used to set the logical size of a file (in
octects).

The callback should return a PDF status value:
@table @code
@item PDF_OK
The operation was successfully performed and the logical size of the
file was changed.
@item PDF_BADPERMS
The client does not have enough permissions to set the logical size of
@var{file}. 
@end table
@end deftp

@deftp {Data Type} {pdf_status_t (*pdf_fsys_file_get_pos_fn_t) (pdf_fsys_file_t @var{file}, pdf_size_t *@var{pos})}

Filesystem callback used to get the current position in a given file.

The callback should return a PDF status variable:
@table @code
@item PDF_OK
The operation was successfully performed and the current position in
@var{file} was stored in @var{pos}.
@end table

This callback is called by the @code{pdf_fsys_file_get_pos} file
interface function.
@end deftp

@deftp {Data Type} {pdf_status_t (*pdf_fsys_file_set_pos_fn_t) (pdf_fsys_file_t @var{file}, pdf_size_t @var{pos})}

Filesystem callback used to set the current position in a given file.

The callback should return a PDF status variable:
@table @code
@item PDF_OK
The operation was successfully performed and the current position in
@var{file} was set to @var{pos}.
@end table

This callback is called by the @code{pdf_fsys_file_set_pos} file
interface function.
@end deftp

@deftp {Data Type} {enum pdf_fsys_file_mode_e (*pdf_fsys_file_get_mode_fn_t) (pdf_fsys_file_t @var{file})}

Filesystem callback used to get the open mode of a given open file.

This callback is called by the @code{pdf_fsys_file_get_mode} file
interface function.
@end deftp

@deftp {Data Type} {enum pdf_fsys_file_mode_e (*pdf_fsys_file_set_mode_fn_t) (pdf_fsys_file_t @var{file}, enum pdf_fsys_file_mode_e @var{new_mode})}

Filesystem callback used to update the mode of a given open file with
a given set of file modes.

This callback is called by the @code{pdf_fsys_file_set_mode} file
interface function.
@end deftp

@deftp {Data Type} {pdf_text_t (*pdf_fsys_file_get_url_fn_t) (pdf_fsys_file_t @var{file})}

Filesystem callback used to get a URL pointing to a given open file.

This callback is called by the @code{pdf_fsys_file_get_url} file
interface function.
@end deftp

@deftp {Data Type} {pdf_bool_t (*pdf_fsys_file_same_p_fn_t) (pdf_fsys_file_t @var{file}, pdf_text_t @var{path_name})}

Filesystem callback used to determine whether a given open file is the
same file as a given file identified by a file path.

This callback is called by the @code{pdf_fsys_file_same_p} file
interface function.
@end deftp

@deftp {Data Type} {pdf_status_t (*pdf_fsys_file_request_ria_fn_t) (pdf_fsys_file_t @var{file}, pdf_size_t @var{offset}, pdf_size_t @var{count})}

Filesystem callback used to request a Read-In-Advance operation in a
given open file.

This callback is called by the @code{pdf_fsys_file_request_ria} file
interface function.
@end deftp

@deftp {Data Type} {pdf_bool_t (*pdf_fsys_file_has_ria_fn_t) (pdf_fsys_file_t @var{file})}

Filesystem callback used to determine whether the filesystem is
performing some RIA operation for the given open file.

This callback is called by the @code{pdf_fsys_file_has_ria} file
interface function.
@end deftp

@deftp {Data Type} {pdf_status_t (*pdf_fsys_file_cancel_ria_fn_t) (pdf_fsys_file_t @var{file})}

Filesystem callback used to cancel any pending RIA operation in a
given open file.

This callback is called by the @code{pdf_fsys_file_cancel_ria} file
interface function.
@end deftp

@deftp {Data Type} {pdf_status_t (*pdf_fsys_file_close_fn_t) (pdf_fsys_file_t @var{file})}

Filesystem callback used to close a given open file.

This callback is called by the @code{pdf_fsys_file_close} file
interface function.
@end deftp

@deftp {Data Type} {pdf_status_t (*pdf_fsys_file_reopen_fn_t) (pdf_fsys_file_t @var{file}, enum pdf_fsys_file_mode_e @var{mode})}

Filesystem callback used to reopen a given open file with a
given mode.

This callback is called by the @code{pdf_fsys_file_reopen} file
interface function.
@end deftp

@node The Filesystem Definition Interface
@subsection The Filesystem Definition Interface

The Filesystem Definition Interface is implemented by the Filesystem
module and provides functionality to provide an implementation of a
filesystem. A @code{pdf_fsys_t} should be properly defined before to
use it.

The Filesystem Definition Interface defines the following elements:

@itemize @bullet
@item
The function types conforming the Filesystem Implementation Interface.
@item
Installation functions to register implementation functions into a
filesystem variable.
@end itemize

@menu
* File System Definition Data Types::
* File System Definition Functions::
@end menu

@node File System Definition Data Types
@subsubsection File System Definition Data Types

@deftp {Data Type} struct pdf_fsys_impl_s

Structure containing the callbacks to a concrete file system
implementation.

The members of the structure are the following:

@table @code
@item pdf_fsys_open_fn_t open_fn
@item pdf_fsys_close_fn_t c close_fn
@item pdf_fsys_create_folder_fn_t create_folder_fn
@item pdf_fsys_get_folder_contents_fn_t get_folder_contents_fn
@item pdf_fsys_get_parent_fn_t get_parent_fn
@item pdf_fsys_remove_folder_fn_t remove_folder_fn
@item pdf_fsys_file_read_fn_t file_read_fn
@item pdf_fsys_file_write_fn_t file_write_fn
@item pdf_fsys_file_flush_fn_t fiile_flush_fn
@item pdf_fsys_get_item_props_fn_t get_item_props_fn
@item pdf_fsys_get_free_space_fn_t get_free_space_fn
@item pdf_fsys_item_p_fn_t item_p_fn
@item pdf_fsys_item_readable_p_fn_t item_readable_p_fn
@item pdf_fsys_item_writable_p_fn_t item_writable_p_fn
@item pdf_fsys_get_temp_path_name_fn_t get_temp_path_name_fn
@item pdf_fsys_file_can_set_size_fn_t file_can_set_size_fn
@item pdf_fsys_file_get_size_fn_t file_get_size_fn
@item pdf_fsys_file_set_size_fn_t file_set_size_fn
@item pdf_fsys_file_get_pos_fn_t file_get_pos_fn
@item pdf_fsys_file_set_pos_fn_t file_set_pos_fn
@item pdf_fsys_file_get_mode_fn_t file_get_mode_fn
@item pdf_fsys_file_set_mode_fn_t file_set_mode_fn
@item pdf_fsys_file_get_url_fn_t file_get_url_fn
@item pdf_fsys_file_same_p_fn_t file_same_p_fn
@item pdf_fsys_file_request_ria_fn_t file_request_ria_fn
@item pdf_fsys_file_has_ria_fn_t file_has_ria_fn
@item pdf_fsys_file_cancel_ria_fn_t file_cancel_ria_fn
@item pdf_fsys_file_close_fn_t file_close_fn
@item pdf_fsys_file_reopen_fn_t file_reopen_fn
@end table
@end deftp

@node File System Definition Functions
@subsubsection File System Definition Functions

@deftypefun pdf_fsys_t pdf_fsys_create (struct pdf_fsys_impl_s @var{implementation})

Create and return a new filesystem variable that will use a given
implementation.

@table @strong
@item Parameters
@table @var
@item implementation
A filesystem implementation.
@end table
@item Returns
A fileystem variable.
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_fsys_destroy (pdf_fsys_t @var{filesystem})

Destroy a filesystem freein all used resources.

@table @strong
@item Parameters
@table @var
@item filesystem
A filesystem variable.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The filesystem was successfully destroyed.
@end table
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun



@node Encryption
@section Encryption

This section describes related to encryption functions.

@menu
* Initializating the module::   
* Creating and destroying Ciphers::  
* Encryption and decryption::   
* Message digest functions::  
@end menu

@node Initializating the module
@subsection Initializating the module

The encryption module must be initialized when Libgnupdf library was
loaded It is *NOT* safe-thread.

@deftypefun pdf_status_t pdf_crypt_init (void)

Initialize the encryption module.

@table @strong
@item Parameters
None.
@item Returns
A PDF status value:
@table @code
@item PDF_OK
Operation successful
@item PDF_ERROR
A error ocurred.
@end table
@item Usage example
@example
pdf_status_t st;

st = pdf_crypt_init ();

if (st != PDF_OK)
@{
   /* Error */
@}
@end example
@end table
@end deftypefun

@node Creating and destroying Ciphers
@subsection Creating and destroying Ciphers

@deftp {Data Type} {enum pdf_crypt_cipher_algo_e}
An algorithm provided. It contains low level functions of the algorithm
implementation.

@table @code
@item PDF_CRYPT_CIPHER_ALGO_AESV2
Use AES algorithm with a key of 128 bits to encrypt the data.
@item PDF_CRYPT_CIPHER_ALGO_V2
Use ARC4 algorithm.
@end table
@end deftp

@deftp {Data Type} {pdf_crypt_cipher_t}
A cipher. It contains data which is required between several calls to
functions.
@end deftp

@deftypefun pdf_status_t pdf_crypt_cipher_new (enum pdf_crypt_cipher_algo_e @var{algorithm}, pdf_crypt_cipher_t *@var{cipher})

Create a new cipher.

@table @strong
@item Parameters
@table @var
@item algorithm
The algorithm the cipher will use in order to encrypt or decrypt data.
@item cipher
A pointer to @code{pdf_crypt_cipher_t} variable where it will put the cipher.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
Operation successful
@item PDF_ERROR
A error ocurred when trying to create the cipher.
@end table
@item Usage example
@example
pdf_status_t st;
pdf_crypt_cipher_t cipher;

st = pdf_crypt_cipher_new (PDF_CRYPT_CIPHER_ALG_AESV2, &cipher);

if (st != PDF_OK)
@{
   /* Error */
@}
@end example
@end table
@end deftypefun


@deftypefun pdf_status_t pdf_crypt_cipher_destroy (pdf_crypt_cipher_t @var{cipher})

Destroy a cipher.

@table @strong
@item Parameters
@table @var
@item cipher
The cipher you want destroy. It must have been created with
@code{pdf_crypt_cipher_new} functions previously.
@end table
@item Returns
@table @code
A PDF status value:
@item PDF_OK
Operation successful
@item PDF_ERROR
A error ocurred when trying to destroy the cipher.
@end table
@item Usage example
@example
pdf_crypt_cipher_t cipher;
pdf_crypt_cipher_new (PDF_CRYPT_CIPHER_ALG_AESV2, &cipher);
pdf_crypt_cipher_destroy (cipher);
@end example
@end table
@end deftypefun


@node Encryption and decryption
@subsection Encryption and decryption

@deftypefun pdf_status_t pdf_crypt_cipher_setkey (pdf_crypt_cipher_t *@var{cipher}, pdf_char_t  *@var{key}, pdf_size_t @var{size})

Set the key which will be used to encrypt and decrypt data.

@table @strong
@item Parameters
@table @var
@item cipher
A pointer to a cipher created previously.
@item key
A pointer to memory where the key is stored.
@item size
The length of the key in bytes. Note that some algorithms could require
a fixed length of key.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
Operation successful
@item PDF_EBADDATA
Invalid argument. The @var{size} parameter is not supported by the
cipher.
@item PDF_ERROR
A error ocurred while trying to set the key.
@end table
@item Usage example
@example
pdf_status_t st;
pdf_crypt_cipher_t cipher;
pdf_char_t key[16];

/* ... */
st = pdf_crypt_cipher_setkey (&cipher, key, sizeof(key));

if (st != PDF_OK)
@{
   /* Error */
@}
@end example
@end table
@end deftypefun

@deftypefun pdf_size_t pdf_crypt_cipher_encrypt_size (pdf_crypt_cipher_t @var{cipher}, pdf_char_t  *@var{in}, pdf_size_t  @var{in_size})

Compute the size for the output buffer in
@code{pdf_crypt_cipher_encrypt} function for the given parameters.

@table @strong
@item Parameters
@table @var
@item cipher
A cipher.
@item in
A pointer to the buffer which will be encrypted.
@item in_size
The length of the buffer in bytes.
@end table
@item Returns
The size of a valid output buffer in @code{pdf_crypt_cipher_encrypt}
function for this parameters.
@item Usage example
@example
pdf_crypt_cipher_t cipher;
pdf_size_t size;
pdf_char_t in[16];

/* ...prepare the cipher... */
size = pdf_crypt_cipher_encrypt_size (cipher, in, sizeof (in));
@end example
@end table
@end deftypefun

@deftypefun pdf_size_t pdf_crypt_cipher_decrypt_size (pdf_crypt_cipher_t @var{cipher}, pdf_char_t  *@var{in}, pdf_size_t @var{in_size})

Compute the size for a valid output buffer in
@code{pdf_crypt_cipher_decrypt} function for the given parameters.

@table @strong
@item Parameters
@table @var
@item cipher
A cipher.
@item in
A pointer to the buffer which will be decrypted.
@item in_size
The length of the buffer in bytes.
@end table
@item Returns
The size of a valid output buffer in @code{pdf_crypt_cipher_encrypt}
function for this parameters.
@item Usage example
@example
pdf_crypt_cipher_t cipher;
pdf_size_t size;
pdf_char_t *in;
pdf_size_t in_size;

/* ...prepare the cipher... */
size = pdf_crypt_cipher_decrypt_size (cipher, in, in_size);
@end example
@end table
@end deftypefun


@deftypefun pdf_status_t pdf_crypt_cipher_encrypt (pdf_crypt_cipher_t @var{cipher}, pdf_char_t  *@var{out}, pdf_size_t  @var{out_size}, pdf_char_t  *@var{in}, pdf_size_t  @var{in_size}, pdf_size_t *@var{result_size})

Encrypt a buffer. The ciphered text will be put in @var{out}.

@table @strong
@item Parameters
@table @var
@item cipher
A cipher.
@item out
A pointer to the output buffer.
@item out_size
Size reserved for the output buffer in bytes. The function will fail if
it is not too large to contain the output.
@item in
A pointer to input buffer.
@item in_size
The length of the input buffer in bytes. I must be greater than zero.
@item result_size
A pointer where it will put the real size of the output buffer. This
size will be lesser or equal than out_size.
@end table
@item Returns
@table @code
@item PDF_OK
Operation successful
@item PDF_ERROR
An error ocurred.
@end table
@item Usage example
@example
pdf_crypt_cipher_t cipher;
pdf_status_t st;
pdf_char_t *out;
pdf_char_t *in;
pdf_size_t out_size;
pdf_size_t in_size;
  
/* ... */
out_size = pdf_crypt_cipher_encrypt_size (cipher, in, in_size);
out = pdf_alloc (out_size);

st = pdf_crypt_cipher_encrypt (cipher, out, out_size, in, in_size, &out_size);

if (st != PDF_OK)
@{
  /* Error*/
@}
@end example
@end table
@end deftypefun


@deftypefun pdf_status_t pdf_crypt_cipher_decrypt (pdf_crypt_cipher_t @var{cipher}, pdf_char_t  *@var{out}, pdf_size_t  @var{out_size}, pdf_char_t  *@var{in}, pdf_size_t  @var{in_size}, pdf_size_t *@var{result_size})

Decrypt a buffer. The plain text will be put in @var{out}.

@table @strong
@item Parameters
@table @var
@item cipher
A cipher.
@item out
A pointer to the output buffer.
@item out_size
Size reserved for the output buffer in bytes. The function will fail if
it is not too large to contain the output.
@item in
A pointer to input buffer.
@item in_size
The length of the input buffer in bytes. It must be greater than zero.
@item result_size
A pointer where it will put the real size of the output buffer. This size
will be lesser or equal than out_size.
@end table
@item Returns
@table @code
@item PDF_OK
Operation successful
@item PDF_ERROR
An error ocurred.
@end table
@item Usage example
@example
pdf_crypt_cipher_t cipher;
pdf_status_t st;
pdf_char_t *out;
pdf_char_t *in;
pdf_size_t out_size;
pdf_size_t in_size;
  
/* ... */
out_size = pdf_crypt_cipher_decrypt_size (cipher, in, in_size);
out = pdf_alloc (out_size);

st = pdf_crypt_crypt_decrypt (cipher, out, out_size, in, in_size, &out_size);

if (st != PDF_OK)
@{
  /* Error*/
@}
@end example
@end table
@end deftypefun

@node Message digest functions
@subsection Message digest functions

@deftp {Data Type} {enum pdf_crypt_md_algo_e}
An algorithm provided. It contains low level functions of the algorithm
implementation.

@table @code
@item PDF_CRYPT_MD_MD5
Use the md5 algorithm.
@end table
@end deftp

@deftp {Data Type} {pdf_crypt_md_t}
A message-digest descriptor.
@end deftp



@deftypefun pdf_status_t pdf_crypt_md_new (pdf_crypt_md_t  *@var{md}, enum pdf_crypt_md_algo_e @var{algo})

Create a message-digest descriptor for an algorithm.

@table @strong
@item Parameters
@table @var
@item md
A pointer to the pdf_crypt_md_t.
@item algo
Algorithm which be used to hashing.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
Operation successful
@item PDF_ERROR
An error ocurred.
@end table
@item Usage example
@example
pdf_status_t st;
pdf_crypt_md_t md;

st = pdf_crypt_md_new (&md, PDF_CRYPT_MD_MD5);

if (st != PDF_OK)
@{
   /* Error /*
@}
@end example
@end table
@end deftypefun



@deftypefun pdf_status_t pdf_crypt_md_hash (pdf_crypt_md_t @var{md}, pdf_char_t  *@var{out}, pdf_size_t  @var{out_size}, pdf_char_t  *@var{in}, pdf_size_t  @var{in_size})

Compute the message-digest for a given buffer.

@table @strong
@item Parameters
@table @var
@item md
A message-digest descriptor.
@item out
A pointer to output buffer.
@item out_size
The size of output buffer in bytes.
@item in
A pointer to the input buffer.
@item in_size
Size of the input buffer in bytes.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
Operation successful
@item PDF_EBADDATA
Bad parameter. The size of the output buffer is wrong.
@end table
@item Usage example
@example
pdf_crypt_md_t md;
pdf_char_t out[16];
pdf_char_t *in;
pdf_size_t in_size;
pdf_status_t st;

/* ...Prepare IN and IN_SIZE variables */

pdf_crypt_md_new (&md, PDF_CRYPT_MD_MD5);

st = pdf_crypt_md_hash (md, out, sizeof(out), in, in_size);

if (st != PDF_OK)
@{
   /* Error */
@}

pdf_crypt_md_destroy (md);
@end example
@end table
@end deftypefun


@deftypefun pdf_status_t pdf_crypt_md_destroy (pdf_crypt_md_t  @var{md})

Destroy a message-digest descriptor.

@table @strong
@item Parameters
@table @var
@item md
An message-digest descriptor.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
Operation successful
@item PDF_ERROR
An error ocurred.
@end table
@item Usage example
@example
pdf_status_t st;
pdf_crypt_md_t md;

st = pdf_crypt_md_new (&md, PDF_CRYPT_MD_MD5);

/* ... /*

pdf_crypt_md_destroy (md);
@end example
@end table
@end deftypefun




@node Object Layer
@chapter Object Layer

@menu
* Object Layer Overview::
* PDF Objects::
* Object Collections::
* Memory Management::
* Object Level Documents::
* Real Objects::
* Integer Objects::
* Boolean Objects::
* Name Objects::
* String Objects::
* Array Objects::
* Dictionary Objects::
* Stream Objects::
* Indirect Objects::
* Null Object::
@end menu

@node Object Layer Overview
@section Overview

The Object Layer of the library provides access to manipulate PDF
documents as a collection of PDF objects (@pxref{PDF Objects}).

Note that the use of this layer can lead to non-well conformed PDF
documents: not every PDF object collection define a document. So the
client should be careful when using this layer. In contrast the
@ref{Document Layer} provides a convenient API to manipulate PDF files
while maintaining its structural integrity.

All the names for constants, data types and functions defined in this
layer are prefixed with @code{pdfo_} or @code{PDFO_}.

@node PDF Objects
@section PDF Objects

@node Object Collections
@section Object Collections

@node Memory Management
@section Memory Management

@node Object Level Documents
@section Object Level Documents

@node Real Objects
@section Real Objects

A real object represent a fixed-point real number.

@menu
* Real Object Creation::
* Managing Real Object Attributes::
@end menu

@node Real Object Creation
@subsection Real Object Creation

@deftypefun pdfo_obj_t pdfo_create_real (const pdfo_doc_t @var{doc}, const pdf_bool_t @var{indirect}, const pdf_real_t @var{value})

Creates a new real object.

@table @strong
@item Parameters

@table @var
@item doc
Document that contain this object.
@item indirect
Boolean value specifying if we want to create an indirect object.
@item value
Initialization value.
@end table

@item Returns
The newly created object.
@item Usage example

@example
pdfo_doc_t doc;
pdfo_obj_t new_obj;

/* Initialize `doc' ... */

new_obj = pdfo_create_real (doc, PDF_FALSE, 2.12);
@end example 
@end table
@end deftypefun 

@node Managing Real Object Attributes
@subsection Managing Real Object Attributes

@deftypefun pdf_real_t pdfo_get_real (const pdfo_obj_t @var{object})

Gets the real value of a real object.

@table @strong
@item Parameters

None.

@item Returns
The real value of the given object.
@item Usage example

@example
pdfo_obj_t real_obj;
pdf_real_t value;

/* Initialize `real_obj' as a Real object ... */

value = pdfo_get_real (new_obj);
@end example
@end table
@end deftypefun

@deftypefun void pdfo_set_real (pdfo_obj_t @var{object}, const pdf_real_t @var{value})

Set a new real value in a real object.

@table @strong
@item Parameters
@table @var
@item object
Real object.
@item value
New real value.
@end table

@item Returns
None.
@item Usage example
@example
pdfo_obj_t real_obj;
pdf_real_t value;

/* Initialize `real_obj' as a Real object ... */

pdfo_set_real (new_obj, 3.14);
@end example
@end table
@end deftypefun

@node Integer Objects
@section Integer Objects

@node Boolean Objects
@section Boolean Objects

@node Name Objects
@section Name Objects

@node String Objects
@section String Objects

@node Array Objects
@section Array Objects

@node Dictionary Objects
@section Dictionary Objects

@node Stream Objects
@section Stream Objects

@node Indirect Objects
@section Indirect Objects

@node Null Object
@section Null Object


@node Document Layer
@chapter Document Layer

@node Page Contents Layer
@chapter Page Contents Layer


@c FDL
@c ===

@node GNU Free Documentation License
@appendix GNU Free Documentation License

@include fdl.texi


@c The indexes
@c ===========

@node Global variable index
@unnumbered Global variable index

@printindex vr

@node Data type index
@unnumbered Data type index

@printindex tp

@node Function index
@unnumbered Function index

@printindex fn


@bye
