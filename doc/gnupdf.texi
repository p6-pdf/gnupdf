\input texinfo
@comment $Id: gnupdf.texi,v 1.79 2008/07/07 20:22:31 jemarch Exp $
@comment %**start of header
@setfilename gnupdf.info
@settitle GNU PDF Library Reference
@comment %**end of header

@comment Avoid the indentation of @example and @smallexample in the
@comment html output.  This doesn't fixes the problem of the
@comment indentation, but it is better than nothing.
@ifhtml
@exampleindent 0
@end ifhtml

@include version.texi

@copying
This is the @cite{GNU PDF Library Reference}, updated for
@strong{libgnupdf} version @strong{@value{VERSION}}.

Copyright @copyright{} 2007-2011 Free Software Foundation, Inc.

@quotation
Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with no
Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts. A
copy of the license is included in the section entitled ``GNU Free
Documentation License''.
@end quotation
@end copying

@dircategory Software libraries
@direntry
* gnupdf: (gnupdf).             The GNU PDF Library reference.
@end direntry

@titlepage
@sp 6
@center @titlefont{GNU PDF Library Reference}
@sp 4
@center Updated for version @value{VERSION}.
@sp 5
@center Free Software Foundation
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@contents

@ifnottex
@node Top
@top GNU PDF Library Reference

GNU PDF Library Reference

@insertcopying
@end ifnottex

@menu
* Overview::                    The GNU PDF library in brief.
* Base Layer::                  Base library facilities.
* Object Layer::                Editing the object structure of a PDF file.
* Document Layer::              Editing the document-level structure of a PDF
                                 file.
* Page Contents Layer::         Editing the contents of pages.
* Implementation Limits::       Implementation limits in the library.
* GNU Free Documentation License::  Distribution terms of this manual.

Indices

* Global variable index::       Variables provided by the library.
* Data type index::             Data types provided by the library.
* Function index::              Functions provided by the library.
@end menu

@node Overview
@chapter Overview

@node Base Layer
@chapter Base Layer

@menu
* Base Layer Overview::         Definition and purpose of this layer.
* Error Management::            Error reporting and tracing.
* Memory Allocation::           Functions to (de)allocate memory.
* Basic Types::                 Numbers, buffers and other simple
                                 types.
* Lists::                       Generic lists.
* Hash Tables::                 Generic associative tables.
* Filtered Streams::            Operating files or memory buffers with
                                 filtering support.
* Floating Point Maths::        Working with real numbers.
* Encoded Text::                Manipulating encoded strings.
* Time Management::             Times and calendars.
* The Filesystem Module::       An abstract file system interface.
* The Tokeniser::               Decomposing a PDF document in tokens.
* Encryption::                  Basic encryption facilities.
@end menu

@node Base Layer Overview
@section Overview

The base layer of the GNU PDF Library provides system-independent
access to several facilities.

The implemented facilities are organized into modules. Each module
exports an API to be used by the client application or other layers of
the library. Some modules make use of the facilities implemented in
other modules (such as allocation or error functions).

@node Error Management
@section Error Management

The Error module provides procedures for error reporting to the
client as well as for error tracing (via debug messages) to
developers. Here we also define status types returned by most
procedures (there are exceptions though), as well as a generic
error data type.

@menu
* Types::                      Status values returned by the functions
                                of this library.
* Error Reporting procedures:: Reporting errors in the library.
* Error Printing procedures::  Printing the textual description of
                                errors and error codes.
@end menu

@node Types
@subsection Types

@deftp {Data Type} pdf_status_t
A status variable. This type of variable is returned by many library
functions in order to communicate the status of the performed
operation.
@end deftp

The following constants define the valid values to be held in a
@code{pdf_status_t} variable:

@deftp {Constant} PDF_OK
Success
@end deftp

@deftp {Constant} PDF_ERROR
A serious error
@end deftp

@deftp {Constant} PDF_EBADDATA
Invalid or bad arguments
@end deftp

@deftp {Constant} PDF_ENOMEM
Insufficient memory
@end deftp

@deftp {Constant} PDF_EEOF
End of file
@end deftp

@deftp {Constant} PDF_EDIVBYZERO
Divison by zero
@end deftp

@deftp {Constant} PDF_ENONODE
No node found
@end deftp

@deftp {Constant} PDF_EINVRANGE
Invalid range
@end deftp

@deftp {Constant} PDF_ETEXTENC
Error in text encoding
@end deftp

@deftp {Constant} PDF_ENOMATCH
No matching found
@end deftp

This list will grow as we get closer to a mature state of development.

@deftp {Data Type} pdf_error_domain_t
An enumerated value which represents a submodule of the library.
@end deftp

The following constants define the valid values to be held in a
@code{pdf_error_domain_t} variable:

@deftp {Constant} PDF_EDOMAIN_UNDEFINED
The domain is undefined.
@end deftp

@deftp {Constant} PDF_EDOMAIN_BASE_BASIC
The Basic Types submodule in the Base layer.
@end deftp

@deftp {Constant} PDF_EDOMAIN_BASE_HT
The Hash Tables module in the Base layer.
@end deftp

@deftp {Constant} PDF_EDOMAIN_BASE_LISTS
The Lists module in the Base layer.
@end deftp

@deftp {Constant} PDF_EDOMAIN_BASE_STM
The Streams module in the Base layer.
@end deftp

@deftp {Constant} PDF_EDOMAIN_BASE_FP
The Floating Points module in the Base layer.
@end deftp

@deftp {Constant} PDF_EDOMAIN_BASE_TEXT
The Text module in the Base layer.
@end deftp

@deftp {Constant} PDF_EDOMAIN_BASE_FSYS
The FileSystem module in the Base layer.
@end deftp

@deftp {Constant} PDF_EDOMAIN_BASE_TOKENISER
The Tokeniser module in the Base layer.
@end deftp

@deftp {Constant} PDF_EDOMAIN_BASE_ENCRYPTION
The Encryption module in the Base layer.
@end deftp


@deftp {Data Type} pdf_error_t
An opaque data type, representing a generic error. This variable holds where the
error was originally reported (a @code{pdf_error_domain_t}), which kind of error
it is (a @code{pdf_status_t}) as well as a text message with more information on
the issue.
@end deftp


@node Error Reporting procedures
@subsection Error Reporting procedures

@deftypefun {pdf_error_t *}pdf_error_new (pdf_error_domain_t @var{domain}, pdf_status_t @var{status}, const pdf_char_t *@var{format}, @var{...})

Creates a new @code{pdf_error_t} variable.

Note that the status of the newly created error will be set to
@code{PDF_ENOMEM} if there is not enough memory to create the error
object.

@table @strong
@item Parameters
@table @var
@item domain
a valid error domain
@item status
a valid status code
@item format
string format for the message
@item ...
format's arguments
@end table
@item Returns
a newly created @code{pdf_error_t}
@item Usage example
@example
pdf_error_t *error;

error = pdf_error_new (PDF_EDOMAIN_TEXT,
                       PDF_EBADCONTEXT,
                       "Context was not properly initialized");
@end example
@end table
@end deftypefun

@deftypefun {pdf_error_t *}pdf_error_dup (const pdf_error_t *@var{error})

Duplicates a @code{pdf_error_t} variable.

@table @strong
@item Parameters
@table @var
@item error
A @code{pdf_error_t} to duplicate
@end table
@item Returns
a newly created @code{pdf_error_t}
@item Usage example
@example
pdf_error_t *error;
pdf_error_t *dup;

error = pdf_error_new (PDF_EDOMAIN_TEXT,
                       PDF_EBADCONTEXT,
                       "Context was not properly initialized");

dup = pdf_error_dup (error);
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_error_get_status (const pdf_error_t *@var{error})

Returns the status code in @var{error}.

@table @strong
@item Parameters
@table @var
@item error
a @code{pdf_error_t}
@end table
@item Returns
a @code{pdf_status_t}
@item Usage example
@example
pdf_error_t *error;

error = pdf_error_new (PDF_EDOMAIN_TEXT,
                       PDF_EBADCONTEXT,
                       "Context was not properly initialized");

if (pdf_error_get_status (error) != PDF_EBADCONTEXT)
  @{
        /* Won't happen */
  @}
@end example
@end table
@end deftypefun

@deftypefun pdf_error_domain_t pdf_error_get_domain (const pdf_error_t *@var{error})

Returns the error domain in @var{error}.

@table @strong
@item Parameters
@table @var
@item error
a @code{pdf_error_t}
@end table
@item Returns
a @code{pdf_error_domain_t}
@item Usage example
@example
pdf_error_t *error;

error = pdf_error_new (PDF_EDOMAIN_TEXT,
                       PDF_EBADCONTEXT,
                       "Context was not properly initialized");

if (pdf_error_get_domain (error) != PDF_EDOMAIN_TEXT)
  @{
        /* Won't happen */
  @}
@end example
@end table
@end deftypefun

@deftypefun const pdf_char_t *pdf_error_get_message (const pdf_error_t *@var{error})

Returns the message in @var{error}.

@table @strong
@item Parameters
@table @var
@item error
a @code{pdf_error_t}
@end table
@item Returns
a @code{pdf_error_domain_t}
@item Usage example
@example
pdf_error_t *error;

error = pdf_error_new (PDF_EDOMAIN_TEXT,
                       PDF_EBADCONTEXT,
                       "Context was not properly initialized");

pdf_perror (pdf_error_get_status (error),
            pdf_error_get_domain (error));
@end example
@end table
@end deftypefun

@deftypefun void pdf_error_destroy (pdf_error_t *@var{error})

Disposes @var{error} and its contents.

@table @strong
@item Parameters
@table @var
@item error
a @code{pdf_error_t}
@end table
@item Usage example
@example
pdf_error_t *error;

error = pdf_error_new (PDF_EDOMAIN_TEXT,
                       PDF_EBADCONTEXT,
                       "Context was not properly initialized");

pdf_error_destroy (error);
@end example
@end table
@end deftypefun


@deftypefun void pdf_set_error (pdf_error_t **@var{err}, pdf_error_domain_t @var{domain}, pdf_status_t @var{status}, const pdf_char_t *@var{format}, @var{...})

Does nothing if @var{err} is @code{NULL}. If @var{err} is not @code{NULL},
then *@var{err} must be @code{NULL}. It will create a new @code{pdf_error_t} and place
it in *@var{err}.

@table @strong
@item Parameters
@table @var
@item err
a pointer to a @code{pdf_error_t}
@item domain
a valid error domain
@item status
a valid error status
@item format
string format for the message
@item ...
format's arguments
@end table
@item Usage example
@example
pdf_bool_t
pdf_magic (pdf_char_t   *spell,
           pdf_error_t **error)
@{
  if (!pdf_magic_is_spell_known (spell))
    @{
      pdf_set_error (error,
                     PDF_EDOMAIN_UNDEFINED,
                     PDF_EBADDATA,
                     "Wrong or unknown spell: '%s'",
                     spell);
      return PDF_FALSE;
    @}

  /* Magic goes here */
  return PDF_TRUE;
@}
@end example
@end table
@end deftypefun


@deftypefun void pdf_prefix_error (pdf_error_t **@var{err}, const pdf_char_t *@var{format}, @var{...})

Does nothing if @var{err} is @code{NULL}. Also does nothing if @var{err} is not @code{NULL}
but *@var{err} is @code{NULL}. Otherwise, prepends the new message to the existing one.

@table @strong
@item Parameters
@table @var
@item err
a pointer to a @code{pdf_error_t}
@item format
string format for the message
@item ...
format's arguments
@end table
@item Usage example
@example
pdf_bool_t
pdf_magic (pdf_char_t   *spell,
           pdf_error_t **error)
@{
  if (!pdf_magic_is_spell_known (spell, error))
    @{
      pdf_prefix_error (error,
                        "couldn't run spell: '%s'",
                        spell);
      return PDF_FALSE;
    @}

  /* Magic goes here */
  return PDF_TRUE;
@}
@end example
@end table
@end deftypefun


@deftypefun void pdf_clear_error (pdf_error_t **@var{err})

Does nothing if @var{err} is @code{NULL}. If @var{err} is not @code{NULL},
then it will dispose the @code{pdf_error_t} in *@var{err}, if any; and
set *@var{err} to @code{NULL}.

@table @strong
@item Parameters
@table @var
@item err
a pointer to a @code{pdf_error_t}
@end table
@item Usage example
@example
pdf_bool_t
pdf_magic (pdf_char_t   *spell,
           pdf_error_t **error)
@{
  /* Yes, it is a weird example, I know */
  pdf_set_error (error,
                 PDF_EDOMAIN_UNDEFINED,
                 PDF_EBADDATA,
                 "Wrong or unknown spell: '%s'",
                 spell);

  if (pdf_magic_is_spell_known (spell))
    @{
      pdf_clear_error (error);

      /* Magic goes here */
      return PDF_TRUE;
    @}

  return PDF_FALSE;
@}
@end example
@end table
@end deftypefun

@deftypefun void pdf_propagate_error (pdf_error_t **@var{dest}, pdf_error_t *@var{src})

If @var{dest} is @code{NULL}, it will dispose @var{src}. Otherwise, moves
@var{src} to *@var{dest}.

@table @strong
@item Parameters
@table @var
@item dest
a pointer to a @code{pdf_error_t}
@item src
a @code{pdf_error_t}
@end table
@item Usage example
@example
pdf_bool_t
pdf_magic (pdf_char_t   *spell,
           pdf_error_t **error)
@{
  pdf_error_t *inner_error = NULL;

  if (!pdf_magic_execute (spell, &inner_error))
    @{
      /* Report up all errors except for PDF_EAGAIN... */
      if (pdf_error_get_status (inner_error) != PDF_EAGAIN)
        @{
          pdf_propagate_error (error, inner_error);
          return PDF_FALSE;
        @}
      pdf_error_destroy (inner_error);
    @}

  return PDF_TRUE;
@}
@end example
@end table
@end deftypefun

@deftypefun void pdf_propagate_error_dup (pdf_error_t **@var{dest}, const pdf_error_t *@var{src})

If @var{dest} is @code{NULL}, nothing is done. Otherwise, duplicates @var{src} in *@var{dest}.

@table @strong
@item Parameters
@table @var
@item dest
a pointer to a @code{pdf_error_t}
@item src
a constant @code{pdf_error_t}
@end table
@item Usage example
@example
pdf_bool_t
pdf_magic (pdf_something_t  *spell,
           pdf_error_t     **error)
@{
  if (spell->error)
    @{
      /* Propagate a copy of an internally stored error */
      pdf_propagate_error_dup (error, spell->error);
      return PDF_FALSE;
    @}

  return PDF_TRUE;
@}
@end example
@end table
@end deftypefun

@node Error Printing procedures
@subsection Error Printing procedures

@deftypefun void pdf_perror (const pdf_status_t @var{status}, const char *@var{str})

Prints the message corresponding to @var{status} to stderr followed by @var{str}.

@table @strong
@item Parameters
@table @var
@item status
status code
@item str
a user-defined message
@end table
@item Returns
nothing
@item Usage example
@example
pdf_status_t st;

pdf_i64_add (dest, addend_1, addend_2, &st);

if (st != PDF_OK)
@{
        pdf_perror (st, "Couldn't do i64 addition");
@}
@end example
@end table
@end deftypefun

@deftypefun void pdf_error (const pdf_status_t @var{status}, FILE *@var{fd}, const char *@var{format}, @var{...})

Prints a message with `fprintf (@var{fd}, @var{format}, ...)';
if @var{status} is nonzero, also prints the corresponding message.

@table @strong
@item Parameters
@table @var
@item status
status code
@item fd
file descriptor open for writing
@item format
string format for the message
@item ...
format's arguments
@end table
@item Returns
nothing
@item Usage example
@example
pdf_status_t st;

pdf_i64_add (dest, addend_1, addend_2, &st);

if (st != PDF_OK)
@{
        pdf_error (st, logfd, "couldn't do i64 addition");
@}
@end example
@end table
@end deftypefun


@subheading Output format
The output format for these macros is,

@example
GNU PDF:***DEBUG <layer>***:<file-name>:<line-number>: <message>.
@end example

For example,

@example
GNU PDF:***DEBUG BASE***:pdf-fp-func.c:344: division by zero.
@end example

@node Memory Allocation
@section Memory Allocation

The memory allocation module provides system-independent heap memory
allocation and deallocation. The usual malloc/free/realloc schema is
used to provide this service.

@deftypefun void* pdf_alloc (const pdf_size_t @var{size})

Allocates heap memory.

@table @strong
@item Parameters

@table @var
@item size
The requested number of octets to allocate.  If this value is
@code{0} then no memory is allocated and @code{NULL} is returned.
@end table

@item Returns
A pointer to the newly allocated memory.

If there is not enough available memory to satisfy the petition then
@code{NULL} is returned.
@item Usage example
@example
int *p;

p = (int *) pdf_alloc (sizeof(int));
*p = 666;
@end example
@end table


@end deftypefun

@deftypefun void pdf_dealloc (const void *@var{pointer})

Deallocates heap memory.

@table @strong
@item Parameters

@table @var
@item pointer
A pointer pointing to the memory we want to deallocate. The memory to
deallocate should have been previously allocated using
@code{pdf_alloc}.
@end table

@item Returns
None.
@item Usage Example

@example
char *p;

p = (char *) pdf_alloc (21);
pdf_dealloc (p);
@end example
@end table
@end deftypefun

@deftypefun void* pdf_realloc (const void *@var{pointer}, const pdf_size_t @var{size})

Reallocates memory.

@table @strong
@item Parameters

@table @var
@item pointer
A pointer to previously allocated memory.

The memory to reallocate should have been allocated using
@code{pdf_alloc} or @code{pdf_realloc}.
@item size
The new size of the allocated memory chunk.

If the requested size is shorter than the original size of the
allocated memory then it is truncated. Any previous contents in the
memory will be lost.

If the requested size is larger or equal than the original size of the
allocated memory then the previous contents of the allocated memory
remains. The contents of newly allocated memory are undetermined.

If there is not enough available memory to satisfy the request, then a
fatal error is signaled killing the current process. An error status
is returned to the operating system.
@end table

@item Returns
A pointer to the reallocated memory.
@item Usage Example
@example
char *p;

p = (char *) pdf_alloc (4);
strncpy (p, "abcd", 4);

/* p now points to "abcd" */

p = (char *) pdf_realloc (5);
p[4] = 'e';

/* p now points to "abcde" */

p = (char *) pdf_realloc (4);

/* p now points to "abcd" */

pdf_dealloc (p);
@end example
@end table
@end deftypefun

@node Basic Types
@section Basic Types

@menu
* Boolean Types::           The true/false boolean operators.
* Numeric Types::           Signed and unsigned 32bit integers.
* Size and Position Types:: Types to represent sizes and positions.
* Character Types::         Signed and unsigned bytes.
* Memory Buffers::          Operations on simple memory buffers.
@comment * Progress Monitors::   Following the progress of operations.
* UUIDs::                   Universal Unique Identifiers.
@end menu

@node Boolean Types
@subsection Boolean Types

@deftp {Data Type} pdf_bool_t
A boolean value.
@end deftp

The following constants define the valid values to be held in a
@code{pdf_bool_t} variable:

@deftp {Constant} PDF_TRUE
Logical true.
@end deftp

@deftp {Constant} PDF_FALSE
Logical false.
@end deftp

@node Numeric Types
@subsection Numeric Types

The library provides scalar types of 16, 32 and 64 bits.

@deftp {Data Type} pdf_i16_t
Signed 16 bits integer.
@end deftp

@deftp {Data Type} pdf_u16_t
Unsigned 16 bits integer.
@end deftp

@deftp {Data Type} pdf_i32_t
Signed 32 bits integer.
@end deftp

@deftp {Data Type} pdf_u32_t
Unsigned 32 bits integer.
@end deftp

@deftp {Data Type} pdf_i64_t
Signed 64 bits integer.
@end deftp

@deftp {Data Type} pdf_u64_t
Unsigned 64 bits integer.
@end deftp

The following constants specify the valid ranges for these data types:

@deftp {Constant} PDF_I32_MAX
Maximum value able to be stored in a @code{pdf_i32_t} variable.
@end deftp

@deftp {Constant} PDF_I32_MIN
Minimum value able to be stored in a @code{pdf_i32_t} variable.
@end deftp

@deftp {Constant} PDF_U32_MAX
Maximum value able to be stored in a @code{pdf_u32_t} variable.
@end deftp

@deftp {Constant} PDF_U32_MIN
Minimum value able to be stored in a @code{pdf_u32_t} variable.
@end deftp

@deftp {Constant} PDF_I64_MAX
Maximum value able to be stored in a @code{pdf_u64_t} variable.
@end deftp

@deftp {Constant} PDF_I64_MIN
Minimum value able to be stored in a @code{pdf_u64_t} variable.
@end deftp

@deftp {Constant} PDF_U64_MAX
Maximum value able to be stored in a @code{pdf_u64_t} variable.
@end deftp

@deftp {Constant} PDF_U64_MIN
Minimum value able to be stored in a @code{pdf_u64_t} variable.
@end deftp

@node Size and Position Types
@subsection Size and Position Types

The library provides several types intended to manage sizes and offsets

@deftp {Data Type} pdf_size_t
Unsigned size type
@end deftp

@deftp {Data Type} pdf_ssize_t
Signed size type
@end deftp

@deftp {Data Type} pdf_off_t
Type to represent a byte offset. It is assured to be a signed scalable one,
but its size may be wider than a long.
@end deftp

@node Character Types
@subsection Character Types

The library provides two types intended to hold character codes.

@deftp {Data Type} pdf_char_t
A character code.
@end deftp

Note that @code{pdf_char_t} values may be signed or unsigned depending
on the system running in the host, and they shall not be manipulated
numerically. The following type shall be used instead in those cases.

@deftp {Data Type} pdf_uchar_t
A character code in the range @code{0..255}.
@end deftp

@node Memory Buffers
@subsection Memory Buffers

@deftp {Data Type} {struct pdf_buffer_s}

This structure contains the data associated to a simple memory
buffer.

@table @code
@item data
Pointer to the buffer contents.
@item size
Number of octets allocated in @code{data}.
@item rp
Current read pointer.
@item wp
Current write pointer.
@end table
@end deftp

@deftp {Data Type} pdf_buffer_t
Pointer to a @code{pdf_buffer_s} structure.
@end deftp

@deftypefun {pdf_buffer_t *}pdf_buffer_new (pdf_size_t @var{size}, pdf_error_t **@var{error})

Create a new memory buffer.

@table @strong
@item Parameters
@table @var
@item size
The size of the new buffer, in octets.
@item error
A @code{pdf_error_t} to report errors or @code{NULL}.
@table @code
@item PDF_ENOMEM
Not enough memory to create the buffer.
@end table
@end table
@item Returns
A newly created @code{pdf_buffer_t}, or @code{NULL} if an error happened.
@item Usage example
@example
pdf_buffer_t *buffer;
pdf_error_t *error = NULL;

buffer = pdf_buffer_new (1024, &error);
if (!buffer)
  @{
    /* Not enough memory */
    pdf_error_destroy (error);
  @}
@end example
@end table
@end deftypefun

@deftypefun void pdf_buffer_destroy (pdf_buffer_t *@var{buffer})

Destroy a memory buffer.

@table @strong
@item Parameters
@table @var
@item buffer
A valid @code{pdf_buffer_t}.
@end table
@item Usage example
@example
pdf_buffer_t *buffer;

buffer = pdf_buffer_new (1024, NULL);
pdf_buffer_destroy (buffer);
@end example
@end table
@end deftypefun

@deftypefun pdf_bool_t pdf_buffer_full_p (pdf_buffer_t *@var{buffer})

Determine whether a memory buffer is full.

@table @strong
@item Parameters
@table @var
@item buffer
A valid @code{pdf_buffer_t}.
@end table
@item Returns
@code{PDF_TRUE} if buffer is full, @code{PDF_FALSE} otherwise.
@item Usage example
@example
int i;
pdf_buffer_t *buffer;

/* Create a new buffer */
buffer = pdf_buffer_new (1024, NULL);

/* Fill the entire buffer */
for (i = 0; i < 1024; i++)
  @{
    buffer->data[buffer->wp++] = 'a';
  @}

/* The buffer should be full now */
if (pdf_buffer_full_p (buffer))
  @{
    /* Buffer full */
  @}

pdf_buffer_destroy (buffer);
@end example
@end table
@end deftypefun

@deftypefun pdf_bool_t pdf_buffer_eob_p (pdf_buffer_t *@var{buffer})

Determine whether a memory buffer is in an end-of-buffer state.

@table @strong
@item Parameters
@table @var
@item buffer
A valid @code{pdf_buffer_t}.
@end table
@item Returns
@code{PDF_TRUE} if the buffer is in an end-of-buffer state, @code{PDF_FALSE} otherwise.
@item Usage example
@example
pdf_buffer_t *buffer;
pdf_char_t my_char;

/* Create a new buffer */
buffer = pdf_buffer_new (3, NULL);

/* Copy some contents into the buffer, filling it entirely */
strncpy (buffer->data, "abc", 3);
buffer->wp += 3;

/* Read data from the buffer until an eob condition */
while (!pdf_buffer_eob_p (buffer))
  @{
    my_char = buffer->data[buffer->rp++];
  @}
@end example
@end table
@end deftypefun

@deftypefun pdf_bool_t pdf_buffer_resize (pdf_buffer_t *@var{buffer}, pdf_size_t @var{newsize}, pdf_error_t **@var{error})

Resize a memory buffer.

@table @strong
@item Parameters
@table @var
@item buffer
A valid @code{pdf_buffer_t}.
@item newsize
The new size (in octets) for the buffer.
@item error
A @code{pdf_error_t} to report errors or @code{NULL}.
@table @code
@item PDF_ENOMEM
Not enough memory to resize the buffer.
@end table
@end table
@item Returns
@code{PDF_TRUE} if buffer properly resized, @code{PDF_FALSE} otherwise.
@item Usage example
@example
pdf_buffer_t *my_buffer;
pdf_char_t my_char;
pdf_char_t *my_string;
pdf_size_t my_string_size;
pdf_size_t written_bytes;

/* Create a string */
my_string_size = 10;
my_string = pdf_alloc (my_string_size + 1);
strncpy (my_string, "0123456789", 10);
my_string[10] = 0;

/* Create a new buffer */
my_buffer = pdf_buffer_new (4, NULL);

/* Copy the contents of my_string into my_buffer
 * making it larger in chunks of 4 bytes */
written_bytes = 0;
while (written_bytes < my_string_size)
  @{
    if (pdf_buffer_full_p (my_buffer))
      @{
        /* Grow the buffer */
        pdf_buffer_resize (my_buffer,
                           my_buffer->wp + 5);
      @}
    my_buffer->data[my_buffer->wp] =
      my_string[my_buffer->wp];
    my_buffer->wp++;
  @}

/* Adjust the buffer size */
pdf_buffer_resize (my_buffer, my_string_size);
@end example
@end table
@end deftypefun

@deftypefun void pdf_buffer_rewind (pdf_buffer_t *@var{buffer})

Rewind a memory buffer.

@table @strong
@item Parameters
@table @var
@item buffer
A valid @code{pdf_buffer_t}.
@end table
@item Usage example
@example
pdf_buffer_t *buffer;

/* Create a new buffer and initialize its contents */
buffer = pdf_buffer_new (3, NULL);
strncpy (buffer->data, "abc", 3);
buffer->wp += 3;

/* Replace the contents */
pdf_buffer_rewind (buffer);
strncpy (buffer->data, "ABC", 3);
buffer->wp += 3;
@end example
@end table
@end deftypefun

@comment @node Progress Monitors
@comment @subsection Progress Monitors
@comment
@comment The client application of the library may want to monitor the progress
@comment of some operations, such as the saving of a document. The @code{struct
@comment pdf_pm_s} structure provides a way for the client application to
@comment specify callbacks implemented by a progress monitor.
@comment
@comment @deftp {Data Type} {struct pdf_pm_s}
@comment
@comment Structure containing several callbacks to be called as an operation
@comment progress.
@comment
@comment @table @code
@comment @item pdf_pm_begin_operation_fn_t begin_operation_fn
@comment @item pdf_pm_end_operation_fn_t end_operation_fn
@comment @item pdf_pm_get_duration_fn_t get_duration_fn
@comment @item pdf_pm_set_duration_fn_t set_duration_fn
@comment @item pdf_pm_get_current_value_fn_t get_current_value_fn_t
@comment @item pdf_pm_set_current_value_fn_t set_current_value_fn_t
@comment @item pdf_pm_set_text_fn_t set_text_fn
@comment @end table
@comment @end deftp
@comment
@comment The type definitions for the callbacks follows.
@comment
@comment @deftp {Data Type} {pdf_status_t (*pdf_pm_begin_operation_fn_t) (void *@var{client_data})}
@comment Callback implemented by a progress monitor that initializes it to a
@comment current value of @code{0}.
@comment
@comment @table @strong
@comment @item Parameters
@comment @table @var
@comment @item client_data
@comment User supplied data.
@comment @end table
@comment @item Returns
@comment This callback should return @code{PDF_OK} to the caller.
@comment @end table
@comment @end deftp
@comment
@comment @deftp {Data Type} {pdf_status_t (*pdf_pm_end_operation_fn_t) (void *@var{client_data})}
@comment Callback implemented by a progress monitor. This callback is called at
@comment the end of the operation.
@comment
@comment @table @strong
@comment @item Parameters
@comment @table @var
@comment @item client_data
@comment User supplied data.
@comment @end table
@comment @item Returns
@comment This callback should return @code{PDF_OK} to the caller.
@comment @end table
@comment @end deftp
@comment
@comment @deftp {Data Type} {pdf_status_t (*pdf_pm_get_duration_fn_t) (void *@var{client_data}, void *@var{duration})}
@comment
@comment Callback implemented by a progress monitor.
@comment
@comment This callback is called to get the current value of the progress
@comment monitor duration.
@comment @table @strong
@comment @item Parameters
@comment @table @var
@comment @item client_data
@comment User supplied data.
@comment @item duration
@comment A pointer to a @var{pdf_time_span_t} variable to store the current
@comment duration of the progress monitor.
@comment @end table
@comment @item Returns
@comment This callback should return @code{PDF_OK} to the caller.
@comment @end table
@comment @end deftp
@comment
@comment @deftp {Data Type} {pdf_status_t (*pdf_pm_set_duration_fn_t) (void *@var{client_data}, void *@var{duration})}
@comment
@comment Callback implemented by a progress monitor.
@comment
@comment This callback is called to set the current value of the progress
@comment monitor duration.
@comment @table @strong
@comment @item Parameters
@comment @table @var
@comment @item client_data
@comment User supplied data.
@comment @item duration
@comment A pointer to a time span variable containing the new duration for the
@comment progress monitor.
@comment @end table
@comment @item Returns
@comment This callback should return @code{PDF_OK} to the caller.
@comment @end table
@comment @end deftp
@comment
@comment @deftp {Data Type} {pdf_status_t (*pdf_pm_get_current_value_fn_t) (void *@var{client_data}, void *@var{duration})}
@comment
@comment Callback implemented by a progress monitor.
@comment
@comment This callback is called to get the current value of the progress
@comment monitor duration.
@comment @table @strong
@comment @item Parameters
@comment @table @var
@comment @item client_data
@comment User supplied data.
@comment @item duration
@comment A pointer to a @var{pdf_time_span_t} variable to store the current
@comment duration of the progress monitor.
@comment @end table
@comment @item Returns
@comment This callback should return @code{PDF_OK} to the caller.
@comment @end table
@comment @end deftp
@comment
@comment @deftp {Data Type} {pdf_status_t (*pdf_pm_set_current_value_fn_t) (void *@var{client_data}, void *@var{duration})}
@comment
@comment Callback implemented by a progress monitor.
@comment
@comment This callback is called to set the current value of the progress
@comment monitor duration.
@comment @table @strong
@comment @item Parameters
@comment @table @var
@comment @item client_data
@comment User supplied data.
@comment @item duration
@comment A time span variable containing the new duration for the progress
@comment monitor.
@comment @end table
@comment @item Returns
@comment This callback should return @code{PDF_OK} to the caller.
@comment @end table
@comment @end deftp
@comment
@comment @deftp {Data Type} {pdf_status_t (*pdf_pm_set_text_fn_t) (void *@var{client_data}, void *@var{text})}
@comment
@comment Callback implemented by a progress monitor.
@comment
@comment This callback is called to set the description of the current status
@comment of the operation to the progress monitor.
@comment @table @strong
@comment @item Parameters
@comment @table @var
@comment @item client_data
@comment User supplied data.
@comment @item text
@comment A text variable containing the new description.
@comment @end table
@comment @item Returns
@comment This callback should return @code{PDF_OK} to the caller.
@comment @end table
@comment @end deftp

@node UUIDs
@subsection Universal Unique Identifiers

The basic types module provides an implementation of the ITU X.667
Recommendation for the generation of Universal Unique Identifiers,
also known as Globally Unique Identifiers or GUIDs.

Each UUID is a hexadecimal-coded ascii sequence composed by the
following fields, separated by the ascii hyphen-minus, 45 character,
except between the VariantAndClockSeqHigh and ClockSeqLow:

@itemize @minus
@item TimeLow (4 bytes => 8 hexadecimal digits)
@item TimeMid (2 bytes => 4 hexadecimal digits)
@item VersionAndTimeHigh (2 bytes => 4 hexadecimal digits)
@item VariantAndClockSeqHigh (1 byte => 2 hexadecimal digits)
@item ClockSeqLow (1 octet => 2 hexadecimal digits)
@item Node (6 octets => 12 hexadecimal digits)
@end itemize

An example of an UUID would be:

@example
00000000-0000-0000-0000-000000000000
@end example

There are three standardized ways to generate the values of those
fields:

@itemize @minus
@item time-based
@item random-based
@item name-based
@end itemize

Note that, according to the ITU recommendation, uuid generators should
produce lower-case letters in hexadecimal encoding.  On the other
hand, it is recommended for uuid consumers to be case-insensitive
regarding alphabetic characters in hexadecimal strings.  This
implementation follows both recommendations.

Note also that the time-based method makes use of the MAC address of
the primary network card installed in the system.  If the library is
running in a system where no such information is available then a
standardized alternative random method is used.

@deftp {Data Type} pdf_uuid_t
Opaque type representing an Universally Unique Identifier.
@end deftp

@deftp {Data Type} {enum pdf_uuid_type_e}
Type of an UUID:

@table @code
@item PDF_UUID_TIME
Time-based UUID as defined by ITU X.667.
@item PDF_UUID_RANDOM
Random-based UUID as defined by ITU X.667.
@item PDF_UUID_NAME
Name-based UUID as defined by ITU X.667.
@end table
@end deftp

@deftypefun pdf_uuid_t pdf_uuid_generate (enum pdf_uuid_type_e @var{type})

Generate a new UUID of the specified type.

@table @strong
@item Parameters
@table @var
@item type
The type of UUID to generate.
@end table
@item Returns
The generated UUID.
@item Usage example
@example
pdf_uuid_t uuid;

/* Generate a name-based UUID.  */
uuid = uuid_generate (PDF_UUID_NAME);
@end example
@end table
@end deftypefun

@deftypefun {pdf_char_t *} pdf_uuid_string (pdf_uuid_t @var{uuid}, pdf_char_t * @var{buffer}, pdf_size_t buffer_size)

Set and return an ASCII string with the printed representation of @var{uuid}.

@table @strong
@item Parameters
@table @var
@item uuid
A previously generated UUID.
@item buffer
A pointer to the output buffer. The given buffer should have at least PDF_UUID_SIZE (46) octets.
@item buffer_size
Size of @var{buffer}.
@end table
@item Returns
A null-terminated buffer containing the printed representation of @var{uuid}.
@item Usage example
@example
pdf_uuid_t uuid;
pdf_char_t uuid_str[PDF_UUID_SIZE];

uuid = pdf_uuid_generate (PDF_UUID_TIME);
printf ("The generated UUID: %s\n",
        pdf_uuid_string (uuid, uuid_str, PDF_UUID_SIZE);
@end example
@end table
@end deftypefun

@deftypefun pdf_bool_t pdf_uuid_equal_p (pdf_uuid_t @var{uuid1}, pdf_uuid_t @var{uuid2})

Determine if two given UUIDs are equal.

@table @strong
@item Parameters
@table @var
@item uuid1
The first UUID to compare.
@item uuid2
The second UUID to compare.
@end table
@item Returns
A PDF boolean indicating whether both UUIDs are equal.
@item Usage example
@example
pdf_uuid_t uuid1;
pdf_uuid_t uuid2;

uuid1 = pdf_uuid_generate (PDF_TIME);
uuid2 = pdf_uuid_generate (PDF_TIME);

if (pdf_uuid_equal_p (uuid1, uuid2))
@{
   /* Extremely unlikely!  */
@}
@end example
@end table
@end deftypefun

@node Lists
@section Lists

This section describes how to work with unsorted and sorted lists.

@menu
* List Data Types::
* Creating and Destroying Lists::
* Managing List Properties::
* Adding and Removing List Nodes in Unsorted Lists::
* Adding and Removing List Nodes in Sorted Lists::
* Setting and Getting Values from List Nodes::
* Searching List Elements in Unsorted Lists::
* Searching List Elements in Sorted Lists::
* Iterating Lists::
@end menu

@node List Data Types
@subsection List Data Types

@deftp {Data Type} pdf_list_t
A list composed by zero or more nodes.
@end deftp

@deftp {Data Type} pdf_list_node_t
A list node. Each node is able to contain a single value.
@end deftp

@deftp {Data Type} pdf_list_iterator_t
A list iterator.
@end deftp

@deftp {Data Type} {pdf_bool_t (*pdf_list_element_equals_fn_t) (const void *elt1, const void *elt2)}
A function type for comparing list elements equality. Should return PDF_TRUE in case they are equal and @code{PDF_FALSE} otherwise.
@end deftp

@deftp {Data Type} {void (*pdf_list_element_dispose_fn_t) (const void *elt)}
A function type for disposing list elements.
@end deftp

@deftp {Data Type} {int (*pdf_list_element_compar_fn_t) (const void *elt1, const void *elt2)}
A function type for comparing list elements. Should return an integer less than, equal to, or greater than zero corresponding to whether the first element is considered less than, equal to, or greater than the second element.
@end deftp

@deftp {Data Type} {pdf_size_t (*pdf_list_element_hashcode_fn_t) (const void *elt)}
A function type for calculating a Hash code given a list element. Should return the corresponding hash code.
@end deftp


@node Creating and Destroying Lists
@subsection Creating and Destroying Lists

@deftypefun {pdf_list_t *}pdf_list_new (pdf_list_element_equals_fn_t @var{equals_fn}, pdf_list_element_dispose_fn_t @var{dispose_fn}, const pdf_bool_t @var{allow_duplicates}, pdf_error_t **@var{error})

Create a new list containing no elements.

@table @strong
@item Parameters
@table @var
@item equals_fn
A function to compare list elements.
It is used in sort operations.
@item dispose_fn
A function to dispose list elements.
It is used when destroying list elements.
@item allow_duplicates
This parameter indicate if the list is allowed to contain duplicate
elements (elements for which @var{equals_fn} evaluate to
@code{PDF_TRUE}).
@item error
A @code{pdf_error_t} to report errors or @code{NULL}.
@table @code
@item PDF_ENOMEM
Not enough memory to create the list.
@end table
@end table
@item Returns
A newly allocated @code{pdf_list_t}.
@item Usage example
@example
pdf_list_t *mylist;
pdf_error_t *error = NULL;

mylist = pdf_list_new (list_element_equal_p,
                       list_element_destroy,
                       PDF_FALSE,
                       &error);
if (list == NULL)
  @{
    /* manage the error... */
    pdf_error_destroy (error);
  @}
@end example
@end table
@end deftypefun

@deftypefun void pdf_list_destroy (pdf_list_t *@var{list})

Destroy a list freeing all used resources.
The elements of the list are disposed first.

@table @strong
@item Parameters
@table @var
@item list
The list to be destroyed.
@end table
@item Usage example
@example
pdf_list_t *mylist;

mylist = pdf_list_new (NULL, NULL, PDF_TRUE, NULL);
if (mylist)
  pdf_list_destroy (mylist);
@end example
@end table
@end deftypefun

@node Managing List Properties
@subsection Managing List Properties

@deftypefun pdf_size_t pdf_list_size (const pdf_list_t *@var{list})

Get the number of elements contained into a given list.

@table @strong
@item Parameters
@table @var
@item list
A list.
@end table
@item Returns
The number of elements inside @var{list}.
@item Usage example
@example
pdf_list_t *mylist;
pdf_size_t num_elm;

/* ...insert some elements into `mylist'... */

num_elm = pdf_list_size (mylist);
@end example
@end table
@end deftypefun

@node Adding and Removing List Nodes in Unsorted Lists
@subsection Adding and Removing List Nodes in Unsorted Lists

@deftypefun {pdf_list_node_t *}pdf_list_add_first (pdf_list_t *@var{list}, const void *@var{element}, pdf_error_t **@var{error})

Add an element as the first element of the list.

@table @strong
@item Parameters
@table @var
@item list
A list.
@item element
The value to be stored as a list element.
@item error
A @code{pdf_error_t} to report errors or @code{NULL}.
@table @code
@item PDF_ENOMEM
Not enough memory to perform the operation.
@end table
@end table
@item Returns
A valid @code{pdf_list_node_t} if the element was correctly added to the list, @code{NULL} otherwise.
@item Usage example
@example
pdf_list_t *list;
pdf_list_t *sublist;
pdf_error_t *error = NULL;

/* Create empty lists.  */
list = pdf_list_new (NULL, NULL, PDF_FALSE, NULL);
sublist = pdf_list_new (NULL, NULL, PDF_FALSE, NULL);

/* Set the sublist as the first element of the list.  */
if (pdf_list_add_first (list, (void *) &sublist, &error) != NULL)
  @{
    /* Error adding the element to the list.  */
    if (error)
      pdf_error_destroy (error);
  @}
@end example
@end table
@end deftypefun

@deftypefun {pdf_list_node_t *}pdf_list_add_last (pdf_list_t *@var{list}, const void *@var{element}, pdf_error_t **@var{error})

Add an element as the last element of the list.

@table @strong
@item Parameters
@table @var
@item list
A list.
@item element
The value to be stored as a list element.
@item error
A @code{pdf_error_t} to report errors or @code{NULL}.
@table @code
@item PDF_ENOMEM
Not enough memory to perform the operation.
@end table
@end table
@item Returns
A valid @code{pdf_list_node_t} if the element was correctly added to the list, @code{NULL} otherwise.
@item Usage example
@example
pdf_list_t *list;
my_t *my_var;
pdf_error_t *error = NULL;

/* Append my_var to 'list'.  */
if (pdf_list_add_last (list, (void *) my_var, &error) != NULL)
  @{
    /* Error appending the element to the list.  */
    if (error)
      pdf_error_destroy (error);
  @}
@end example
@end table
@end deftypefun

@deftypefun {pdf_list_node_t *}pdf_list_add_at (pdf_list_t *@var{list}, const pdf_size_t @var{position}, const void *@var{element}, pdf_error_t **@var{error})

Add an element at a given position in the list, shifting one position all next elements.

@table @strong
@item Parameters
@table @var
@item list
A list.
@item position
A position in the list.
Should be @code{>= 0} and @code{<= pdf_list_size (list)}.
@item element
The value to be stored as a list element.
@item error
A @code{pdf_error_t} to report errors or @code{NULL}.
@table @code
@item PDF_EINVRANGE
Invalid range of given @var{position}.
@item PDF_ENOMEM
Not enough memory to perform the operation.
@end table
@end table
@item Returns
A valid @code{pdf_list_node_t} if the element was correctly added to the list, @code{NULL} otherwise.
@item Usage example
@example
pdf_list_t *list;
pdf_error_t *error = NULL;
int a = 1, b = 2, c = 3;

/* Create the list and add some elements to it...  */
list = pdf_list_new (NULL, NULL, PDF_FALSE, NULL);

if (pdf_list_add_at (list, 0, (void *) &a, &error) == NULL || /* (a) */
    pdf_list_add_at (list, 1, (void *) &c, &error) == NULL || /* (a c) */
    pdf_list_add_at (list, 1, (void *) &b, &error) == NULL)   /* (a b c) */
  @{
    /* Error adding the element to the list.  */
    if (error)
      pdf_error_destroy (error);
  @}
@end example
@end table
@end deftypefun


@deftypefun pdf_bool_t pdf_list_remove_node (pdf_list_t *@var{list}, const pdf_list_node_t *@var{node})

Remove a node from the list.

@table @strong
@item Parameters
@table @var
@item list
A list.
@item node
The node to be removed.
@end table
@item Returns
@code{PDF_TRUE} if the node was correctly removed, @code{PDF_FALSE} otherwise.
@item Usage example
@example
pdf_list_t *list;
pdf_list_node_t *node;
int elem1 = 1;
int elem2 = 2;
int elem3 = 3;

list = pdf_list_new (NULL, NULL, PDF_FALSE, NULL);
if (list != NULL)
 @{
   /* Add some elements to the list.  */
   pdf_list_add_last (list, (void *) &elem1, NULL);
   pdf_list_add_last (list, (void *) &elem2, NULL);
   pdf_list_add_last (list, (void *) &elem3, NULL);

   /* Remove the element containing 'elem2' from 'list'.  */
   node = pdf_list_search (list, (void *) &elem2);
   if (pdf_list_remove_node (list, node) != PDF_TRUE)
     @{
       /* Error removing the node from the list.  */
     @}
 @}
@end example
@end table
@end deftypefun

@deftypefun pdf_bool_t pdf_list_remove_at (pdf_list_t *@var{list}, const pdf_size_t @var{position}, pdf_error_t **@var{error})

Remove the node at a given position from the list.

@table @strong
@item Parameters
@table @var
@item list
A list.
@item position
A position in @var{list}.
Must be @code{>= 0} and @code{< pdf_list_size (list)}.
@item error
A @code{pdf_error_t} to report errors or @code{NULL}.
@table @code
@item PDF_EINVRANGE
Invalid @var{position} range.
@end table
@end table
@item Returns
@code{PDF_TRUE} if the node was correctly removed, @code{PDF_FALSE} otherwise.
@item Usage example
@example
pdf_error_t *error = NULL;
pdf_list_t *list;
int elem1 = 1;
int elem2 = 2;
int elem3 = 3;

list = pdf_list_new (NULL, NULL, PDF_FALSE, NULL);
if (list != NULL)
  @{
    /* Add some elements to the list.  */
    pdf_list_add_last (list, (void *) &elem1, NULL);
    pdf_list_add_last (list, (void *) &elem2, NULL);
    pdf_list_add_last (list, (void *) &elem3, NULL);

    /* Remove the element containing 'elem2' from 'list'.  */
    if (pdf_list_remove_at (list, 1, &error) != PDF_TRUE)
    @{
      /* Error removing the node from the list.  */
    @}
  @}
@end example
@end table
@end deftypefun

@deftypefun pdf_bool_t pdf_list_remove (pdf_list_t *@var{list}, const void **@var{element})

Search a node given its value, and remove it from the list.

@table @strong
@item Parameters
@table @var
@item list
A list.
@item element
The value of the node to be removed.
@end table
@item Returns
@code{PDF_TRUE} if the node was correctly removed, @code{PDF_FALSE} otherwise.
@item Usage example
@example
pdf_list_t *list;
int elem1 = 1;
int elem2 = 2;
int elem3 = 3;

list = pdf_list_new (NULL, NULL, PDF_FALSE, NULL);
if (list != NULL)
@{
  /* Add some elements to the list.  */
  pdf_list_add_last (list, (void *) &elem1, NULL);
  pdf_list_add_last (list, (void *) &elem2, NULL);
  pdf_list_add_last (list, (void *) &elem3, NULL);

  /* Remove the element containing 'elem2' from 'list'.  */
  if (pdf_list_remove (list, (void *) &elem2) != PDF_TRUE)
  @{
    /* Error removing the node from the list.  */
  @}
@}
@end example
@end table
@end deftypefun

@node Adding and Removing List Nodes in Sorted Lists
@subsection Adding and Removing List Nodes in Sorted Lists

@deftypefun {pdf_list_node_t *}pdf_list_sorted_add (pdf_list_t *@var{list}, pdf_list_element_compar_fn_t @var{compar_fn}, const void *@var{element}, pdf_error_t **@var{error})

Add an element to the sorted list.

@table @strong
@item Parameters
@table @var
@item list
A list.
@item compar_fn
A comparison function.
@item element
The value to be stored as a list element.
@item error
A @code{pdf_error_t} to report errors or @code{NULL}.
@table @code
@item PDF_ENOMEM
Not enough memory to perform the operation.
@end table
@end table
@item Returns
A valid @code{pdf_list_node_t} if the element was correctly added to the list, @code{NULL} otherwise.
@item Usage example
@example
int
element_compare_fn (const void *elt1, const void *elt2)
@{
  return *((int *)elt1) - *((int *)elt2);
@}

int main (int argc, char **argv)
@{
  pdf_list_t *list;
  pdf_error_t *error = NULL;
  int a = 1;
  int b = 2;
  int c = 3;

  /* Create the list and add some elements to it...  */
  list = pdf_list_new (NULL, NULL, PDF_FALSE, NULL);

  if (pdf_list_sorted_add (list,
                           element_compare_fn,
                           (void *) &b,
                           &error) == NULL || /* (b) */
      pdf_list_sorted_add (list,
                           element_compare_fn,
                           (void *) &a,
                           &error) == NULL || /* (a b) */
      pdf_list_sorted_add (list,
                           element_compare_fn,
                           (void *) &c,
                           &error) == NULL)   /* (a b c) */
  @{
    /* Error adding the element to the list.  */
    if (error)
      pdf_error_destroy (error);
  @}
@end example
@end table
@end deftypefun

@deftypefun pdf_bool_t pdf_list_sorted_remove (pdf_list_t *@var{list}, pdf_list_element_compar_fn_t @var{compar_fn}, const void *@var{element})

Search a node given its value, and remove it from the list.

@table @strong
@item Parameters
@table @var
@item list
A list.
@item compar_fn
A comparison function.
@item element
The value of the node to be removed.
@end table
@item Returns
@code{PDF_TRUE} if the node was correctly removed, @code{PDF_FALSE} otherwise.
@item Usage example
@example
int
element_compare_fn (const void *elt1, const void *elt2)
@{
  return *((int *)elt1) - *((int *)elt2);
@}

int main (int argc, char **argv)
@{
  pdf_list_t *list;
  pdf_error_t *error = NULL;
  int a = 1;
  int b = 2;
  int c = 3;

  /* Create the list and add some elements to it...  */
  list = pdf_list_new (NULL, NULL, PDF_FALSE, NULL);

  if (pdf_list_sorted_add (list,
                           element_compare_fn,
                           (void *) &b,
                           &error) == NULL || /* (b) */
      pdf_list_sorted_add (list,
                           element_compare_fn,
                           (void *) &a,
                           &error) == NULL || /* (a b) */
      pdf_list_sorted_add (list,
                           element_compare_fn,
                           (void *) &c,
                           &error) == NULL)   /* (a b c) */
  @{
    /* Error adding the element to the list.  */
    if (error)
      pdf_error_destroy (error);
  @}

  if (pdf_list_sorted_remove (list,
                              element_compare_fn,
                              (void *)&b) != PDF_TRUE)
  @{
    /* Error removing the element to the list.  */
  @}

@end example
@end table
@end deftypefun

@node Setting and Getting Values from List Nodes
@subsection Setting and Getting Values from List Nodes

@deftypefun {void *} pdf_list_node_value (const pdf_list_t *@var{list}, const pdf_list_node_t *@var{node})

Get the element value represented by a list node.

@table @strong
@item Parameters
@table @var
@item list
A list.
@item node
A node of @var{list}.
@end table
@item Returns
The element value represented by @var{node}.
@item Usage example
@example
pdf_list_t *list;
int elem1 = 1;
int *pointer_to_elem1;

list = pdf_list_new (list_element_equal_p,
                     list_element_destroy,
                     PDF_FALSE,  /* Allow duplicates */
                     NULL);
if (list != NULL)
   @{
      pdf_list_node_t *node;

      /* Insert an element into the list */
      pdf_list_add_last (list, (void *) &elem1, NULL);

      /* Get the node of the element of the list */
      node = pdf_list_search (list, (void *) &elem1);

      /* Get the value out of the node */
      pointer_to_elem1 = (int *) pdf_list_node_value (list, node);
   @}
@end example
@end table
@end deftypefun

@deftypefun {const void *} pdf_list_get_at (const pdf_list_t *@var{list}, const pdf_size_t @var{position}, pdf_error_t **@var{error})

Get the element value at a given position in the list.

@table @strong
@item Parameters
@table @var
@item list
A list.
@item position
A valid position in @var{list}.
Must be @code{>= 0} and @code{< pdf_list_size (list)}.
@item error
A @code{pdf_error_t} to report errors or @code{NULL}.
@table @code
@item PDF_EINVRANGE
Invalid @var{position}
@end table
@end table
@item Returns
The element value at @var{position}

@item Usage example
@example
pdf_list_t *list;
int elem1 = 1;
int *pointer_to_elem1;

list = pdf_list_new (list_element_equal_p,
                     list_element_destroy,
                     PDF_FALSE,  /* Allow duplicates */
                     NULL);
if (list != NULL)
   @{
      /* Insert an element into the list */
      pdf_list_add_last (list, (void *) &elem1, NULL);

      /* Get the first element of the list */
      pointer_to_elem_1 = pdf_list_get_at (list, 0);
   @}
@end example
@end table
@end deftypefun

@deftypefun {pdf_list_node_t *}pdf_list_set_at (pdf_list_t *@var{list}, const pdf_size_t @var{position}, const void *@var{element}, pdf_error_t **@var{error})

Replace the element at a given position in a list.

@table @strong
@item Parameters
@table @var
@item list
A list.
@item position
A position in @var{list}.
Must be @code{>= 0} and @code{< pdf_list_size (list)}.
@item element
The new element value.
@item error
A @code{pdf_error_t} to report errors or @code{NULL}.
@table @code
@item PDF_EINVRANGE
Invalid @var{position}.
@var{element}.
@item PDF_ENOMEM
Not enough memory to perform the operation.
@end table
@end table
@item Returns
The @code{pdf_list_node_t} if correctly replaced or @code{NULL} otherwise.
@item Usage example
@example
pdf_list_t *list;
pdf_u32_t a = 1;
pdf_u32_t b = 2;
pdf_u32_t c = 3;
pdf_u32_t x = 100;

/* Create a list of integer addresses */
list = pdf_list_new (NULL,
                     NULL,
                     PDF_FALSE, /* Allow duplicates */
                     NULL);
if (list != NULL)
   @{
      /* Insert the elements into the list */
      pdf_list_add_last (list, (void *) &a, NULL);
      pdf_list_add_last (list, (void *) &b, NULL);
      pdf_list_add_last (list, (void *) &c, NULL);

      /* Now the list contains abc */

      if (pdf_list_set_at (list, 1, (void *) &x, &error) == NULL)
         @{
            /* Handle error */
            if (error)
               pdf_error_destroy (error);
         @}
   @}
@end example
@end table
@end deftypefun

@node Searching List Elements in Unsorted Lists
@subsection Searching List Elements in Unsorted Lists

@deftypefun {pdf_list_node_t *}pdf_list_search (const pdf_list_t *@var{list}, const void *@var{element})

Search whether an element is already in the list.

@table @strong
@item Parameters
@table @var
@item list
A list.
@item element
The element to look for.
@end table
@item Returns
A valid @code{pdf_list_node_t} if the element is found in the list, @code{NULL} otherwise.
@item Usage example
@example
pdf_list_t *list;
pdf_error_t *error = NULL;
int elem = 34;

/* Create the list */
list = pdf_list_new (list_element_equal_p,
                     list_element_destroy,
                     PDF_FALSE,  /* Allow duplicates */
                     &error);
if (list != NULL)
   @{
      pdf_list_node_t *node;

      /* Insert an element into the list */
      pdf_list_add_first (list, (void *) &elem, NULL);

      /* Look for that element into the list */
      node = pdf_list_search (list, (void *) &elem);
      if (node != NULL)
         @{
            /* The program should reach this place */
         @}
   @}
@end example
@end table
@end deftypefun

@deftypefun {pdf_list_node_t *} pdf_list_search_from (const pdf_list_t *@var{list}, const pdf_size_t @var{start_index}, const void *@var{element}, pdf_error_t **@var{error})

Search whether an element is already in the list, at a position >= @var{start_index}.

@table @strong
@item Parameters
@table @var
@item list
A list.
@item start_index
Index indicating the begin of the search.
@item element
The element to look for.
@item error
A @code{pdf_error_t} to report errors or @code{NULL}.
@table @code
@item PDF_EINVRANGE
@var{start_index} is greater than the list size.
@end table
@end table
@item Returns
A valid @code{pdf_list_node_t} if the element is found in the list, @code{NULL} otherwise.
@item Usage example
@example
pdf_list_t *list;
pdf_error_t *error = NULL;
int elem1 = 1;
int elem2 = 2;
int elem3 = 3;

list = pdf_list_new (list_element_equal_p,
                     list_element_destroy,
                     PDF_FALSE,  /* Allow duplicates */
                     NULL);
if (list != NULL)
   @{
      pdf_list_node_t *node;

      /* Insert several elements into the list */
      pdf_list_add_last (list, (void *) &elem1, NULL);
      pdf_list_add_last (list, (void *) &elem2, NULL);
      pdf_list_add_last (list, (void *) &elem3, NULL);

      /* look for an element into the list */
      node = pdf_list_search_from (list,
                                   (void *) &elem1,
                                   1,
                                   &error);
      if (node != NULL)
         @{
            /* The program should never reach this place,
               since elem1 occupies the first position (0)
               in the list */
         @}
   @}
@end example
@end table
@end deftypefun

@deftypefun {pdf_list_node_t *}pdf_list_search_from_to (const pdf_list_t *@var{list}, const pdf_size_t @var{start_index}, const pdf_size_t @var{end_index}, const void *@var{element}, pdf_error_t **@var{error})

Search whether an element is already in the list, at a position >=
@var{start_index} and < @var{end_index}.

@table @strong
@item Parameters
@table @var
@item list
A list.
@item start_index
Index to the first list position to be searched.
@item end_index
Index to the last list position to be searched.
@item element
The element to look for.
@item error
A @code{pdf_error_t} to report errors or @code{NULL}.
@table @code
@item PDF_EINVRANGE
@var{start_index} and/or @var{end_index} are greater than the list size.
@end table
@end table
@item Returns
A valid @code{pdf_list_node_t} if the element is found in the list, @code{NULL} otherwise.
@item Usage example
@example
pdf_list_t *list;
pdf_error_t *error;
int elem1 = 1;
int elem2 = 2;
int elem3 = 3;
int elem4 = 4;

list = pdf_list_new (list_element_equal_p,
                     list_element_destroy,
                     PDF_FALSE,  /* Allow duplicates */
                     NULL);
if (list != NULL)
   @{
      pdf_list_node_t *node;

      /* Insert several elements into the list */
      pdf_list_add_last (list, (void *) &elem1, NULL);
      pdf_list_add_last (list, (void *) &elem2, NULL);
      pdf_list_add_last (list, (void *) &elem3, NULL);
      pdf_list_add_last (list, (void *) &elem4, NULL);

      /* look for an element into the list */
      node = pdf_list_search_from_to (list,
                                      (void *) &elem4,
                                      1, 3,
                                      &error);
      if (node != NULL)
         @{
            /* The program should never reach this place,
               since elem4 occupies the last position (3)
               in the list */
         @}
   @}
@end example
@end table
@end deftypefun

@deftypefun {pdf_list_node_t *}pdf_list_next_node (const pdf_list_t *@var{list}, const pdf_list_node_t *@var{node})

Return the node immediately after the given node in the list, or @code{NULL} if it is the last one.

@table @strong
@item Parameters
@table @var
@item list
A list.
@item node
A node contained in @var{list}.
@end table
@item Returns
A valid @code{pdf_list_node_t}, or @code{NULL} if there are no more elements in the list.
@item Usage example
@example
pdf_list_t *list;
pdf_list_node_t *node_first;
pdf_list_node_t *node_second;
int elem1 = 1;
int elem2 = 2;

list = pdf_list_new (list_element_equal_p,
                     list_element_destroy,
                     PDF_FALSE,  /* Allow duplicates */
                     NULL);
if (list != NULL)
   @{
      /* Insert several elements into the list */
      pdf_list_add_last (list, (void *) &elem1, NULL);
      pdf_list_add_last (list, (void *) &elem2, NULL);

      /* Get the node containing "elem1" */
      node_first = pdf_list_search (list, (void *) &elem1);

      /* Get the next node in the list */
      node_second = pdf_list_next_node (list, first_node);

      /* Now node_second is the node containing elem2 */
   @}
@end example
@end table
@end deftypefun

@deftypefun {pdf_list_node_t *}pdf_list_previous_node (const pdf_list_t *@var{list}, const pdf_list_node_t *@var{node})

Return the node immediately before the given node in the list, or @code{NULL} if is the first one.

@table @strong
@item Parameters
@table @var
@item list
A list.
@item node
A node contained in @var{list}.
@end table
@item Returns
A valid @code{pdf_list_node_t}, or @code{NULL} if there are no more previous elements in the list.
@item Usage example
@example
pdf_list_t *list;
pdf_list_node_t *node_first;
pdf_list_node_t *node_second;
int elem1 = 1;
int elem2 = 2;

list = pdf_list_new (list_element_equal_p,
                     list_element_destroy,
                     PDF_FALSE,  /* Allow duplicates */
                     NULL);
if (list != NULL)
   @{
      /* Insert several elements into the list */
      pdf_list_add_last (list, (void *) &elem1, NULL);
      pdf_list_add_last (list, (void *) &elem2, NULL);

      /* Get the node containing "elem2" */
      node_second = pdf_list_search (list, (void *) &elem2);

      /* Get the previous node in the list */
      node_first = pdf_list_previous_node (list, second_node);

      /* Now node_first is the node containing elem2 */
   @}
@end example
@end table
@end deftypefun

@deftypefun pdf_size_t pdf_list_indexof (const pdf_list_t *@var{list}, const void *@var{element})

Search whether an element is already in the list, and return its position if found.

@table @strong
@item Parameters
@table @var
@item list
A list.
@item element
The element to look for.
@end table
@item Returns
The element position if found, or @code{(pdf_size_t)-1} otherwise.
@item Usage Example
@example
pdf_list_t *list;
pdf_list_node_t *node_first;
pdf_list_node_t *node_second;
int elem1 = 1;
int elem2 = 2;
pdf_size_t index_of_elem2;

list = pdf_list_new (list_element_equal_p,
                     list_element_destroy,
                     PDF_FALSE,  /* Allow duplicates */
                     NULL);
if (list != NULL)
   @{
      /* Insert several elements into the list */
      pdf_list_add_last (list, (void *) &elem1, NULL);
      pdf_list_add_last (list, (void *) &elem2, NULL);

      /* Get the index of elem2 */
      index_of_elem2 = pdf_list_indexof (list, (void *) &elem2);

      /* Now index_of_elem2 contains 1 */
   @}
@end example
@end table
@end deftypefun

@deftypefun pdf_size_t pdf_list_indexof_from (const pdf_list_t *@var{list}, const pdf_size_t @var{start_index}, const void *@var{element}, pdf_error_t **@var{error})

Search whether an element is already in the list, at a position >= @var{start_index}.

@table @strong
@item Parameters
@table @var
@item list
A list.
@item start_index
An index to a position in @var{list}.
@item element
The element to look for.
@item error
A @code{pdf_error_t} to report errors or @code{NULL}.
@table @code
@item PDF_EINVRANGE
@var{start_index} or @var{end_index} is greater than the list size.
@end table
@end table
@item Returns
The element position if found, or @code{(pdf_size_t)-1} otherwise.
@item Usage example
@example
pdf_list_t *list;
pdf_list_node_t *node_first;
pdf_list_node_t *node_second;
int elem1 = 1;
int elem2 = 2;
int elem3 = 3;
int elem4 = 4;
pdf_size_t index_of_elem1;
pdf_error_t *error = NULL;

list = pdf_list_new (list_element_equal_p,
                     list_element_destroy,
                     PDF_FALSE,  /* Allow duplicates */
                     NULL);
if (list != NULL)
   @{
      /* Insert several elements into the list */
      pdf_list_add_last (list, (void *) &elem1, NULL);
      pdf_list_add_last (list, (void *) &elem2, NULL);
      pdf_list_add_last (list, (void *) &elem3, NULL);
      pdf_list_add_last (list, (void *) &elem4, NULL);

      /* Get the index of elem1 */
      index_of_elem1 = pdf_list_indexof_from (list,
                                              1,
                                              (void *) &elem1,
                                              &error);
      if (index_of_elem1 != (pdf_size_t)-1)
         @{
            /* The program reaches this point, since elem1 occupies
               the first position into the list */
         @}
   @}
@end example
@end table
@end deftypefun

@deftypefun pdf_size_t pdf_list_indexof_from_to (const pdf_list_t *@var{list}, const pdf_size_t @var{start_index}, const pdf_size_t @var{end_index}, const void *@var{element}, pdf_error_t **@var{error})

Search whether an element is already in the list, at a position >= @var{start_index} and < @var{end_index}.

@table @strong
@item Parameters
@table @var
@item list
A list.
@item start_index
A position in @var{list}.
@item end_index
A position in @var{list}.
@item element
The element to look for.
@item error
A @code{pdf_error_t} to report errors or @code{NULL}.
@table @code
@item PDF_EINVRANGE
@var{start_index} or @var{end_index} is greater than the list size or less than 0.
@end table
@end table
@item Returns
The element position if found, or @code{(pdf_size_t)-1} otherwise.
@item Usage example
@example
pdf_list_t *list;
pdf_list_node_t *node_first;
pdf_list_node_t *node_second;
int elem1 = 1;
int elem2 = 2;
int elem3 = 3;
int elem4 = 4;
pdf_size_t index_of_elem4;
pdf_error_t *error = NULL;

list = pdf_list_new (list_element_equal_p,
                     list_element_destroy,
                     PDF_FALSE,  /* Allow duplicates */
                     NULL);
if (list != NULL)
   @{
      /* Insert several elements into the list */
      pdf_list_add_last (list, (void *) &elem1, NULL);
      pdf_list_add_last (list, (void *) &elem2, NULL);
      pdf_list_add_last (list, (void *) &elem3, NULL);
      pdf_list_add_last (list, (void *) &elem4, NULL);

      /* Get the index of elem4 */
      index_of_elem4 = pdf_list_indexof_from_to (list,
                                                 1, 3,
                                                 (void *) &elem1,
                                                 &error);
      if (index_of_elem4 != (pdf_size_t)-1)
         @{
            /* The program reaches this point, since elem4 occupies
               the last position (3) into the list */
         @}
   @}
@end example
@end table
@end deftypefun

@node Searching List Elements in Sorted Lists
@subsection Searching List Elements in Sorted Lists

@deftypefun {pdf_list_node_t *}pdf_list_sorted_search (const pdf_list_t *@var{list}, pdf_list_element_compar_fn_t @var{compar_fn}, const void *@var{element})

Search whether an element is already in the sorted list.

@table @strong
@item Parameters
@table @var
@item list
A list.
@item compar_fn
A comparison function.
@item element
The element to look for.
@end table
@item Returns
A valid @code{pdf_list_node_t} if the element is found in the list, @code{NULL} otherwise.
@item Usage example
@example
int
element_compare_fn (const void *elt1, const void *elt2)
@{
  return *((int *)elt1) - *((int *)elt2);
@}

int main (int argc, char **argv)
@{
  pdf_list_node_t *node;
  pdf_list_t *list;
  pdf_error_t *error = NULL;
  int a = 1;
  int b = 2;

  /* Create the list and add some elements to it...  */
  list = pdf_list_new (NULL, NULL, PDF_FALSE, NULL);

  if (pdf_list_sorted_add (list,
                           element_compare_fn,
                           (void *)&b,
                           &error) != NULL && /* (b) */
      pdf_list_sorted_add (list,
                           element_compare_fn,
                           (void *)&a,
                           &error) != NULL) /* (a b) */
  @{
    node = pdf_list_sorted_search (list, element_compare_fn, (void *)&b);
    if (node != NULL &&
        b == *((int *)pdf_list_node_value (list, node)))
      @{
        /* Execution should reach this point */
      @}
  @}
@end example
@end table
@end deftypefun

@deftypefun {pdf_list_node_t *}pdf_list_sorted_search_from_to (const pdf_list_t *@var{list}, pdf_list_element_compar_fn_t @var{compar_fn}, const pdf_size_t @var{start_index}, const pdf_size_t @var{end_index}, const void *@var{element}, pdf_error_t **@var{error})

Search whether an element is already in the sorted list, at a position >=
@var{start_index} and < @var{end_index}.

@table @strong
@item Parameters
@table @var
@item list
A list.
@item compar_fn
A comparison function.
@item start_index
Index to the first list position to be searched.
@item end_index
Index to the last list position to be searched.
@item element
The element to look for.
@item error
A @code{pdf_error_t} to report errors or @code{NULL}.
@table @code
@item PDF_EINVRANGE
@var{start_index} and/or @var{end_index} are greater than the list size.
@end table
@end table
@item Returns
A valid @code{pdf_list_node_t} if the element is found in the list, @code{NULL} otherwise.
@item Usage example
@example
int
element_compare_fn (const void *elt1, const void *elt2)
@{
  return *((int *)elt1) - *((int *)elt2);
@}

int main (int argc, char **argv)
@{
  pdf_list_node_t *node;
  pdf_list_t *list;
  pdf_error_t *error = NULL;
  int a = 1;
  int b = 2;

  /* Create the list and add some elements to it...  */
  list = pdf_list_new (NULL, NULL, PDF_FALSE, NULL);

  if (pdf_list_sorted_add (list,
                           element_compare_fn,
                           (void *)&b,
                           &error) != NULL && /* (b) */
      pdf_list_sorted_add (list,
                           element_compare_fn,
                           (void *)&a,
                           &error) != NULL) /* (a b) */
  @{
    node = pdf_list_sorted_search_from_to (list,
                                           element_compare_fn,
                                           0, 1,
                                           (void *)&b);
    if (node == NULL)
      @{
        /* Execution should reach this point */
      @}
  @}
@end example
@end table
@end deftypefun

@deftypefun pdf_size_t pdf_list_sorted_indexof (const pdf_list_t *@var{list}, pdf_list_element_compar_fn_t @var{compar_fn}, const void *@var{element})

Search whether an element is already in the list, and return its position if found.

@table @strong
@item Parameters
@table @var
@item list
A list.
@item compar_fn
A comparision function.
@item element
The element to look for.
@end table
@item Returns
The element position if found, or @code{(pdf_size_t)-1} otherwise.
@item Usage Example
@example
int
element_compare_fn (const void *elt1, const void *elt2)
@{
  return *((int *)elt1) - *((int *)elt2);
@}

int main (int argc, char **argv)
@{
  pdf_list_node_t *node;
  pdf_list_t *list;
  pdf_error_t *error = NULL;
  int a = 1;
  int b = 2;

  /* Create the list and add some elements to it...  */
  list = pdf_list_new (NULL, NULL, PDF_FALSE, NULL);

  if (pdf_list_sorted_add (list,
                           element_compare_fn,
                           (void *)&b,
                           &error) != NULL && /* (b) */
      pdf_list_sorted_add (list,
                           element_compare_fn,
                           (void *)&a,
                           &error) != NULL) /* (a b) */
  @{
    pdf_size_t index_of_a;

    /* Get the index of 'a' */
    index_of_a = pdf_list_sorted_indexof (list,
                                          element_compare_fn,
                                          &a);

    /* Now index_of_a contains 0 */
  @}
@end example
@end table
@end deftypefun

@deftypefun pdf_size_t pdf_list_sorted_indexof_from_to (const pdf_list_t *@var{list}, pdf_list_element_compar_fn_t @var{compar_fn}, const pdf_size_t @var{start_index}, const pdf_size_t @var{end_index}, const void *@var{element}, pdf_error_t **@var{error})

Search whether an element is already in the list, at a position
>= @var{start_index} and < @var{end_index}.

@table @strong
@item Parameters
@table @var
@item list
A list.
@item compar_fn
A comparision function.
@item start_index
A position in @var{list}.
@item end_index
A position in @var{list}.
@item element
The element to look for.
@item error
A @code{pdf_error_t} to report errors or @code{NULL}.
@table @code
@item PDF_EINVRANGE
@var{start_index} and/or @var{end_index} are greater than the list size.
@end table
@end table
@item Returns
The element position if found, or @code{(pdf_size_t)-1} otherwise.
@item Usage example
@example
int
element_compare_fn (const void *elt1, const void *elt2)
@{
  return *((int *)elt1) - *((int *)elt2);
@}

int main (int argc, char **argv)
@{
  pdf_list_node_t *node;
  pdf_list_t *list;
  pdf_error_t *error = NULL;
  int a = 1;
  int b = 2;

  /* Create the list and add some elements to it...  */
  list = pdf_list_new (NULL, NULL, PDF_FALSE, NULL);

  if (pdf_list_sorted_add (list,
                           element_compare_fn,
                           (void *)&b,
                           &error) != NULL && /* (b) */
      pdf_list_sorted_add (list,
                           element_compare_fn,
                           (void *)&a,
                           &error) != NULL) /* (a b) */
  @{
    pdf_size_t index_of_a;

    /* Get the index of 'a' */
    index_of_a = pdf_list_sorted_indexof_from_to (list,
                                                  element_compare_fn,
                                                  1, 2,
                                                  &a);

    /* Now index_of_a contains (pdf_size_t)-1 */
  @}
@end example
@end table
@end deftypefun


@node Iterating Lists
@subsection Iterating Lists

@deftypefun void pdf_list_iterator_init (pdf_list_iterator_t *@var{itr}, const pdf_list_t *@var{list})

Create an iterator traversing @var{list}.

The list contents must not be modified while the iterator is in use,
except for replacing or removing the last returned element.

@table @strong
@item Parameters
@table @var
@item itr
The address of an iterator to get initialized.
@item list
A list.
@end table
@item Usage example
@example
pdf_list_t *list;
pdf_list_iterator_t iter;

/* Create a list and insert some elements into it...  */

/* Initialize the iterator.  */
pdf_list_iterator_init (&iter, list);
@end example
@end table
@end deftypefun

@deftypefun pdf_bool_t pdf_list_iterator_init_from_to (pdf_list_iterator_t *@var{itr}, const pdf_list_t *@var{list}, const pdf_size_t @var{start_index}, const pdf_size_t @var{end_index}, pdf_error_t **@var{error})

Create an iterator traversing the list from nodes @var{start_index} to @var{end_index}.

The list contents must not be modified while the iterator is in use,
except for replacing or removing the last returned element.

@table @strong
@item Parameters
@table @var
@item itr
The address of an iterator to get initialized.
@item list
A list.
@item start_index
A position in @var{list}.
@item end_index
A position in @var{list}.
@item error
A @code{pdf_error_t} to report errors or @code{NULL}.
@table @code
@item PDF_EINVRANGE
@var{start_index} or @var{end_index} is greater than the list size or less than 0.
@end table
@end table
@item Returns
@code{PDF_TRUE} if the iterator was properly initialized, @code{PDF_FALSE} otherwise.
@item Usage example
@example
pdf_list_t *list;
pdf_list_iterator_t iter;
pdf_error_t *error = NULL;

/* Create a list containing 10 elements...  */

/* Get an iterator to traverse the last 5 elements.  */
if (pdf_list_iterator_init_from_to (&iter, list, 4, 9, &error) != PDF_TRUE)
@{
    /* Error creating the iterator.  */
@}
@end example
@end table
@end deftypefun

@deftypefun void pdf_list_iterator_deinit (pdf_list_iterator_t *@var{itr})

Deinitializes the iterator releasing any used resource.

@table @strong
@item Parameters
@table @var
@item itr
A valid list iterator.
@end table
@item Usage example
@example
pdf_list_t *mylist;
pdf_list_iterator_t iter;

/* ... Create and initialize mylist. */

pdf_list_iterator_init (&iter, mylist);

/* Work with the iterator.  */

/* Destroy the iterator.  */
pdf_list_iterator_deinit (&iter);
@end example
@end table
@end deftypefun

@deftypefun pdf_bool_t pdf_list_iterator_next (pdf_list_iterator_t *@var{itr}, const void **@var{element_pointer}, pdf_list_node_t **@var{node_pointer})

If there is a next node, advance the iterator and store the node address in
@var{node_pointer} (if given) and store the node value in @var{element_pointer}
if given.

@table @strong
@item Parameters
@table @var
@item itr
A valid list iterator.
@item element_pointer
A pointer where to store the value stored in the next node, or @code{NULL} if not needed.
@item node_pointer
A pointer where to store the address of the next node, or @code{NULL} if not needed.
@end table
@item Returns
@code{PDF_TRUE} if a next node is available, @code{PDF_FALSE} otherwise.
@item Usage example
@example
pdf_list_t *mylist;
pdf_list_iterator_t iter;
void *elem;

/* ... create and initialize mylist. */

pdf_list_iterator_init (&iter, mylist);

while (pdf_list_iterator_next (&iter, &elem, NULL))
  @{
     /* Process element.  */
  @}

/* Deinitialize the iterator.  */
pdf_list_iterator_deinit (&iter);
@end example
@end table
@end deftypefun

@node Hash Tables
@section Hash Tables

@menu
* Hash Table Types::
* Creating and Destroying Hash Tables::
* Hash Table Properties::
* Adding and Removing Elements::
* Working with Keys::
* Searching Elements::
* Iterating Hash Tables::
* Helper Functions::
@end menu

@node Hash Table Types
@subsection Hash Table Types

@deftp {Data Type} pdf_hash_t

A Hash Table able to store key/value pairs. A key may be any
NULL-terminated string.
@end deftp

@deftp {Data Type} pdf_hash_iterator_t

An iterator over the keys of a Hash Table.
@end deftp

@deftp {Data Type} {void (*pdf_hash_value_dispose_fn_t) (const void *value)}
A function type for disposing the values added to the hash table.
@end deftp

@node Creating and Destroying Hash Tables
@subsection Creating and Destroying Hash Tables

@deftypefun pdf_hash_t *pdf_hash_new (pdf_error_t **@var{error})

Create a new empty hash table.

@table @strong
@item Parameters
@table @var
@item error
A @code{pdf_error_t} to report errors or @code{NULL}.
@table @code
@item PDF_ENOMEM
Not enough memory.
@end table
@end table
@item Returns
A newly allocated @code{pdf_hash_t}
@item Usage example
@example
pdf_hash_t *hash;
pdf_error_t *error = NULL;

/* Create an instance of a hash table */
hash = pdf_hash_new (&error);
if (!hash)
   @{
     /* Error creating the hash table */
     if (error)
       pdf_error_destroy (error);
   @}
@end example
@end table
@end deftypefun

@deftypefun void pdf_hash_destroy (pdf_hash_t *@var{table})

Destroy a hash table. The elements and keys of the table are disposed first.

@table @strong
@item Parameters
@table @var
@item table
A hash table.
@end table
@item Usage example
@example
pdf_hash_t *hash;
pdf_error_t *error = NULL;

hash = pdf_hash_new (&error);
if (hash)
   @{
     pdf_hash_destroy (hash);
   @}
@end example
@end table
@end deftypefun

@node Hash Table Properties
@subsection Hash Table Properties

@deftypefun pdf_size_t pdf_hash_size (const pdf_hash_t *@var{table})

Returns the number of entries in @var{table}.

@table @strong
@item Parameters
@table @var
@item table
A hash table.
@end table
@item Returns
The number of entries.
@item Usage example
@example
pdf_hash_t *hash;
pdf_size_t hash_size;

/* Create a new hash */
hash = pdf_hash_new (NULL);
if (hash != NULL)
   @{
      /* This call should return 0 */
      hash_size = pdf_hash_size (hash);

      /* Add some elements to the hash */
      pdf_hash_add (hash,
                    "a-key",
                    strdup ("a-value"),
                    (pdf_hash_value_dispose_fn_t) pdf_dealloc,
                    NULL);

      /* This call should return 1 */
      hash_size = pdf_hash_size (hash);
   @}
@end example
@end table
@end deftypefun

@node Adding and Removing Elements
@subsection Adding and Removing Elements

@deftypefun pdf_bool_t pdf_hash_add (pdf_hash_t *@var{table}, const pdf_char_t *@var{key}, const void *@var{value}, pdf_hash_value_dispose_fn_t @var{value_disp_fn}, pdf_error_t **@var{error}))

Adds the element @var{value} with the associated key @var{key} to @var{table}. If @var{key} already exists nothing is done.

@table @strong
@item Parameters
@table @var
@item table
A hash table.
@item key
A valid @code{NUL}-terminated string key.
@item value
A pointer to the value being added.
@item value_disp_fn
A function called when @var{value} should be disposed. If @code{NULL} is given nothing is done.
@item error
A @code{pdf_error_t} to report errors or @code{NULL}.
@table @code
@item PDF_ENOMEM
Not enough memory.
@item PDF_EEXIST
The @var{key} already exists in @var{table}.
@end table
@end table
@item Returns
@code{PDF_TRUE} if the new item was correctly added, @code{PDF_FALSE} otherwise.
@item Usage example
@example
pdf_hash_t *hash;

/* Create a new hash */
hash = pdf_hash_new (NULL);
if (hash != NULL)
   @{
      /* Add some elements to the hash */
      pdf_hash_add (hash,
                    "first-key",
                    strdup ("first-value"),
                    (pdf_hash_value_dispose_fn_t) pdf_dealloc,
                    NULL);
      pdf_hash_add (hash,
                    "second-key",
                    strdup ("second-value"),
                    (pdf_hash_value_dispose_fn_t) pdf_dealloc,
                    NULL);
   @}
@end example
@end table
@end deftypefun

@deftypefun pdf_bool_t pdf_hash_replace (pdf_hash_t *@var{table}, const pdf_char_t *@var{key}, const void *@var{value}, pdf_hash_value_dispose_fn_t @var{value_disp_fn}, pdf_error_t **@var{error}))

Adds the element @var{value} with the associated key @var{key} to @var{table}. If @var{key} already exists, the previous element is removed before the new one added.

@table @strong
@item Parameters
@table @var
@item table
A hash table.
@item key
A valid @code{NUL}-terminated string key.
@item value
A pointer to the value being added.
@item value_disp_fn
A function called when @var{value} should be disposed. If NULL is given nothing is done.
@item error
A @code{pdf_error_t} to report errors or @code{NULL}.
@table @code
@item PDF_ENOMEM
Not enough memory.
@end table
@end table
@item Returns
@code{PDF_TRUE} if the new item was correctly added, @code{PDF_FALSE} otherwise.
@item Usage example
@example
pdf_hash_t *hash;

/* Create a new hash */
hash = pdf_hash_new (NULL);
if (hash != NULL)
   @{
      /* Add some elements to the hash */
      pdf_hash_add (hash,
                    "magic-key",
                    strdup ("first-value"),
                    (pdf_hash_value_dispose_fn_t) pdf_dealloc,
                    NULL);
      pdf_hash_replace (hash,
                        "magic-key",
                        strdup ("second-value"),
                        (pdf_hash_value_dispose_fn_t) pdf_dealloc,
                        NULL);
   @}
@end example
@end table
@end deftypefun

@deftypefun pdf_bool_t pdf_hash_remove (pdf_hash_t *@var{table}, const pdf_char_t *@var{key})

Removes the element associated with @var{key} from @var{table}. The
element is disposed first.

@table @strong
@item Parameters
@table @var
@item table
A hash table.
@item key
A valid @code{NUL}-terminated string key.
@end table
@item Returns
@code{PDF_TRUE} if the element was correctly removed, @code{PDF_FALSE} otherwise.
@item Usage example
@example
pdf_hash_t *hash;

/* Create a new hash */
hash = pdf_hash_new (NULL);
if (hash != NULL)
   @{
      /* Add an element to the hash... */
      pdf_hash_add (hash,
                    "a-key",
                    strdup ("a-value"),
                    (pdf_hash_value_dispose_fn_t) pdf_dealloc,
                    NULL);

      /* And remove it */
      pdf_hash_remove (hash, "a-key");
   @}
@end example
@end table
@end deftypefun

@node Working with Keys
@subsection Working with Keys

@deftypefun pdf_bool_t pdf_hash_key_p (const pdf_hash_t *@var{table}, const pdf_char_t *@var{key})

Returns a boolean value indicating whether an element with key
@var{key} exists in @var{table}.

@table @strong
@item Parameters
@table @var
@item table
A hash table.
@item key
A valid @code{NUL}-terminated string key.
@end table
@item Returns
@code{PDF_TRUE} if the element associated with @var{key} exists, @code{PDF_FALSE} otherwise.
@item Usage example
@example
pdf_hash_t *hash;

/* Create a new hash */
hash = pdf_hash_new (NULL);
if ((hash != NULL) &&
    (pdf_hash_add (hash, "a-key", "a-value", NULL, NULL)))
   @{
      if (pdf_hash_key_p (hash, "a-key"))
         @{
            /* The program enters here */
         @}
      if (pdf_hash_key_p (hash, "x-key"))
         @{
            /* The program doesnt reach this */
         @}
   @}
@end example
@end table
@end deftypefun

@deftypefun pdf_bool_t pdf_hash_rename_key (pdf_hash_t *@var{table}, const pdf_char_t *@var{key}, const pdf_char_t *@var{new_key}, pdf_error_t **@var{error})

Renames the key @var{key} to @var{new_key} in @var{table}.

@table @strong
@item Parameters
@table @var
@item table
A hash table.
@item key
A valid @code{NUL}-terminated string key.
@item new_key
A valid @code{NUL}-terminated string key.
@item error
A @code{pdf_error_t} to report errors or @code{NULL}.
@table @code
@item PDF_ENOMEM
Not enough memory to perform the operation.
@end table
@end table
@item Returns
@code{PDF_TRUE} if correctly renamed, @code{PDF_FALSE} otherwise.
@item Usage example
@example
pdf_hash_t *hash;

/* Create a new hash */
hash = pdf_hash_new (NULL);
if ((hash != NULL) &&
    (pdf_hash_add (hash, "a-key", "a-value", NULL, NULL)))
   @{
      /* Rename the key */
      pdf_hash_rename_key (hash, "a-key", "b-key");

      if (pdf_hash_key_p (hash, "a-key"))
         @{
            /* The program doesnt enter here */
         @}

      if (pdf_hash_key_p (hash, "b-key"))
         @{
            /* The program enters here */
         @}
   @}
@end example
@end table
@end deftypefun

@node Searching Elements
@subsection Searching Elements

@deftypefun {const void *}pdf_hash_get_value (const pdf_hash_t *@var{table}, const pdf_char_t *@var{key})

Returns the value of the element associated with the given @var{key} in @var{table}.

@table @strong
@item Parameters
@table @var
@item table
A hash table.
@item key
A valid @code{NUL}-terminated string key.
@end table
@item Returns
The value associated to @var{key}, or @code{NULL} if not found.
@item Usage example
@example
pdf_hash_t *hash;
const pdf_char_t *value;

/* Create a new hash */
hash = pdf_hash_new (NULL);
if (hash != NULL)
   @{
      /* Add an element to the hash... */
      pdf_hash_add (hash,
                    "a-key",
                    strdup ("a-value"),
                    (pdf_hash_value_dispose_fn_t) pdf_dealloc,
                    NULL);

      /* Get the element value from the hash */
      value = pdf_hash_get_value (hash, "a-key");
   @}
@end example
@end table
@end deftypefun

@node Iterating Hash Tables
@subsection Iterating Hash Tables

@deftypefun pdf_bool_t pdf_hash_iterator_init (pdf_hash_iterator_t *@var{itr}, const pdf_hash_t *@var{table})

Initializes the @var{itr} iterator over the keys of @var{table}. Keys are returned in the order imposed by the ``strcmp()'' function.

@table @strong
@item Parameters
@table @var
@item itr
The address of an iterator to get initialized.
@item table
A hash table.
@end table
@item Returns
@code{PDF_TRUE} if iterator is correctly initialized, @code{PDF_FALSE} otherwise.
@item Usage example
@example
pdf_hash_t *hash;
pdf_hash_iterator_t hash_iter;

/* Create a new hash */
hash = pdf_hash_new (NULL);
if (hash != NULL)
   @{
      /* Add some elements to the hash */
      pdf_hash_add (hash,
                    "first-key",
                    strdup ("first-value"),
                    (pdf_hash_value_dispose_fn_t) pdf_dealloc,
                    NULL);
      pdf_hash_add (hash,
                    "second-key",
                    strdup ("second-value"),
                    (pdf_hash_value_dispose_fn_t) pdf_dealloc,
                    NULL);

      /* Get an iterator to the first element of
         the hash */
      pdf_hash_iterator_init (&hash_iter, table);
   @}
@end example
@end table
@end deftypefun

@deftypefun pdf_bool_t pdf_hash_iterator_next (pdf_hash_iterator_t *@var{itr}, const pdf_char_t **@var{key}, const void **@var{value})

Retrieves the next key and value from @var{itr}.

@table @strong
@item Parameters
@table @var
@item itr
A valid iterator.
@item key
A pointer where to save the key.
@item value
A pointer where to save the value.
@end table
@item Returns
@code{PDF_TRUE} if a valid next element was found, @code{PDF_FALSE} otherwise.
@item Usage example
@example
pdf_hash_t *hash;
pdf_hash_iterator_t hash_iter;

/* Create a new hash */
hash = pdf_hash_new (NULL);
if (hash != NULL)
   @{
      pdf_char_t *key = NULL;
      void *value = NULL;

      pdf_hash_add (hash,
                    "first-key",
                    strdup ("first-value"),
                    (pdf_hash_value_dispose_fn_t) pdf_dealloc,
                    NULL);
      pdf_hash_add (hash,
                    "second-key",
                    strdup ("second-value"),
                    (pdf_hash_value_dispose_fn_t) pdf_dealloc,
                    NULL);

      /* Get an iterator to the first element of
         the hash */
      pdf_hash_iterator_init (&hash_iter, table);
      while (pdf_hash_iterator_next (hash_iter, &key, &value))
         @{
             /* key contains the next key, and value contains the value
              * associated with key */
         @}
   @}
@end example
@end table
@end deftypefun

@deftypefun void pdf_hash_iterator_deinit (pdf_hash_iterator_t *@var{itr})

Free all resources used by @var{itr}.

@table @strong
@item Parameters
@table @var
@item itr
A valid iterator.
@end table
@item Usage example
@example
pdf_hash_t *hash;
pdf_hash_iterator_t hash_iter;

/* Create a new hash */
hash = pdf_hash_new (NULL);
if (hash)
   @{
      if (pdf_hash_iterator_init (&hash_iter, hash))
         @{
            pdf_hash_iterator_deinit (&hash_iter);
         @}
   @}
@end example
@end table
@end deftypefun

@node Helper Functions
@subsection Helper Functions

These are specific functions for adding and getting different types of
elements (types defined by the library). Three different kind of functions are
provided:
@table @strong
@item Standard
The hash table takes ownership of the variables received as argument, and guarantees that the correct disposal function is called when the items are removed or the hash table fully destroyed.
@item Duplicated
The hash table duplicates the input variable, and keeps ownership of the heap-allocated duplicated variable.
@item Static
The hash table stores the input variable, which should be valid as long as the hash table exists. For example, use this method to add static constant variables in stack.
@end table


@deftypefun pdf_bool_t pdf_hash_add_string (pdf_hash_t *@var{table}, const pdf_char_t *@var{key}, const pdf_char_t *@var{value}, pdf_error_t **@var{error})

Adds the @var{value} string with the associated key @var{key} to @var{table}. If @var{key} already exists nothing is done. The string will be owned by the hash table, and disposed when the hash table is destroyed.

Note: @var{value} must have been heap-allocated.

@table @strong
@item Parameters
@table @var
@item table
A hash table.
@item key
A valid @code{NUL}-terminated string key.
@item value
A valid @code{NUL}-terminated heap-allocated string value.
@item error
A @code{pdf_error_t} to report errors or @code{NULL}.
@end table
@item Returns
@code{PDF_TRUE} if correctly added, @code{PDF_FALSE} otherwise.
@item Usage example
@example
pdf_hash_t *hash;
pdf_error_t *error = NULL;

/* Create a new hash */
hash = pdf_hash_new (NULL);
if (hash != NULL)
   @{
      if (pdf_hash_add_string (hash,
                               "a-key",
                               strdup ("a-value"),
                               &error))
         @{
            pdf_error_destroy (error);
         @}

      /* Destroy the hash */
      pdf_hash_destroy (hash);
   @}
@end example
@end table
@end deftypefun

@deftypefun pdf_bool_t pdf_hash_add_duplicated_string (pdf_hash_t *@var{table}, const pdf_char_t *@var{key}, const pdf_char_t *@var{value}, pdf_error_t **@var{error})

Duplicates @var{value} in heap and adds it with the associated key @var{key} to @var{table}. If @var{key} already exists nothing is done. The internally duplicated string will be owned by the hash table, and disposed when the hash table is destroyed.

@table @strong
@item Parameters
@table @var
@item table
A hash table.
@item key
A valid @code{NUL}-terminated string key.
@item value
A valid @code{NUL}-terminated string value.
@item error
A @code{pdf_error_t} to report errors or @code{NULL}.
@end table
@item Returns
@code{PDF_TRUE} if correctly added, @code{PDF_FALSE} otherwise.
@item Usage example
@example
pdf_hash_t *hash;
pdf_error_t *error = NULL;

/* Create a new hash */
hash = pdf_hash_new (NULL);
if (hash != NULL)
   @{
      if (pdf_hash_add_duplicated_string (hash,
                                          "a-key",
                                          "a-value",
                                          &error))
         @{
            pdf_error_destroy (error);
         @}

      /* Destroy the hash */
      pdf_hash_destroy (hash);
   @}
@end example
@end table
@end deftypefun

@deftypefun pdf_bool_t pdf_hash_add_static_string (pdf_hash_t *@var{table}, const pdf_char_t *@var{key}, const pdf_char_t *@var{value}, pdf_error_t **@var{error})

Adds the static and constant @var{value} string with the associated key @var{key} to @var{table}. If @var{key} already exists nothing is done. Only use this method if @var{value} will always exist. It can be used with statically allocated strings in the main program, but not with statically allocated strings in dynamically loadable modules (as they may be unloaded during the program execution).

@table @strong
@item Parameters
@table @var
@item table
A hash table.
@item key
A valid @code{NUL}-terminated string key.
@item value
A valid static and constant @code{NUL}-terminated string value.
@item error
A @code{pdf_error_t} to report errors or @code{NULL}.
@end table
@item Returns
@code{PDF_TRUE} if correctly added, @code{PDF_FALSE} otherwise.
@item Usage example
@example
pdf_hash_t *hash;
pdf_error_t *error = NULL;
static const pdf_char_t *a_value = "a-value";

/* Create a new hash */
hash = pdf_hash_new (NULL);
if (hash != NULL)
   @{
      if (pdf_hash_add_static_string (hash, "a-key", a_value, &error))
         @{
            pdf_error_destroy (error);
         @}

      /* Destroy the hash */
      pdf_hash_destroy (hash);
   @}
@end example
@end table
@end deftypefun

@deftypefun {const pdf_char_t *}pdf_hash_get_string (const pdf_hash_t *@var{table}, const pdf_char_t *@var{key})

Get a string variable from a hash table. Output string is not duplicated.

@table @strong
@item Parameters
@table @var
@item table
The hash table to get the value from.
@item key
A valid @code{NUL}-terminated string key.
@end table
@item Returns
The string associated with @var{key}.
@item Usage example
@example
const pdf_char_t *str;

/* ... insert a string variable into the hash ... */

str = pdf_hash_get_string (table, "a-key");

@end example
@end table
@end deftypefun

@deftypefun pdf_bool_t pdf_hash_add_text (pdf_hash_t *@var{table}, const pdf_char_t *@var{key}, const pdf_text_t *@var{value}, pdf_error_t **@var{error})

Adds the @var{value} text with the associated key @var{key} to @var{table}. If @var{key} already exists nothing is done. The text will be owned by the hash table, and disposed when the hash table is destroyed.

@table @strong
@item Parameters
@table @var
@item table
A hash table.
@item key
A valid @code{NUL}-terminated string key.
@item value
A valid @code{pdf_text_t}.
@item error
A @code{pdf_error_t} to report errors or @code{NULL}.
@end table
@item Returns
@code{PDF_TRUE} if correctly added, @code{PDF_FALSE} otherwise.
@item Usage example
@example
pdf_hash_t *hash;
pdf_text_t *elem;
pdf_error_t *error = NULL;

/* Create a new hash */
hash = pdf_hash_new (NULL);
if (hash != NULL)
   @{
      /* Create the element for the hash */
      elem = pdf_text_new_from_unicode ("abc", 3,
                                        PDF_TEXT_UTF8,
                                        &error);
      if (!elem)
         @{
            pdf_error_destroy (error);
         @}
      else if (!pdf_hash_add_text (hash,
                                   "a-key",
                                   elem,
                                   &error))
         @{
            pdf_text_destroy (&elem);
            pdf_error_destroy (error);
         @}
      else
         @{
            /* The text is now owned by the hash */
         @}

      /* Destroy the hash */
      pdf_hash_destroy (hash);
   @}
@end example
@end table
@end deftypefun

@deftypefun pdf_bool_t pdf_hash_add_duplicated_text (pdf_hash_t *@var{table}, const pdf_char_t *@var{key}, const pdf_text_t *@var{value}, pdf_error_t **@var{error})

Duplicates the @var{value} text in heap and adds it with the associated key @var{key} to @var{table}. If @var{key} already exists nothing is done. The internally duplicated text will be owned by the hash table, and disposed when the hash table is destroyed.

@table @strong
@item Parameters
@table @var
@item table
A hash table.
@item key
A valid @code{NUL}-terminated string key.
@item value
A valid @code{pdf_text_t}.
@item error
A @code{pdf_error_t} to report errors or @code{NULL}.
@end table
@item Returns
@code{PDF_TRUE} if correctly duplicated and added, @code{PDF_FALSE} otherwise.
@item Usage example
@example
pdf_hash_t *hash;
pdf_text_t *elem;
pdf_error_t *error = NULL;

/* Create a new hash */
hash = pdf_hash_new (NULL);
if (hash != NULL)
   @{
      /* Create the element */
      elem = pdf_text_new_from_unicode ("abc", 3,
                                        PDF_TEXT_UTF8,
                                        &error);
      if (!elem)
         @{
            pdf_error_destroy (error);
         @}
      else if (pdf_hash_add_duplicated_text (hash,
                                             "a-key",
                                             elem,
                                             &error))
         @{
            pdf_error_destroy (error);
         @}

      /* The hash has a duplicated text,
       * we should destroy the original text */
      pdf_text_destroy (elem);

      /* Destroy the hash */
      pdf_hash_destroy (hash);
   @}
@end example
@end table
@end deftypefun

@deftypefun {const pdf_text_t *} pdf_hash_get_text (const pdf_hash_t *@var{table}, const pdf_char_t *@var{key})

Get a text variable from a hash table.

@table @strong
@item Parameters
@table @var
@item table
The hash table to get the value from.
@item key
A valid @code{NUL}-terminated string key.
@end table
@item Returns
The @code{pdf_text_t} associated with @var{key}.
@item Usage example
@example
pdf_text_t *text;

/* ... insert a text variable into the hash ... */

text = pdf_hash_get_text (table, "a-key");

@end example
@end table
@end deftypefun

@deftypefun pdf_bool_t pdf_hash_add_time (pdf_hash_t *@var{table}, const pdf_char_t *@var{key}, const pdf_time_t *@var{value}, pdf_error_t **@var{error})

Adds the @var{value} time with the associated key @var{key} to @var{table}. If @var{key} already exists nothing is done. The time will be owned by the hash table, and disposed when the hash table is destroyed.

Note: @var{value} must have been created with pdf_time_new(), this is, available in heap.

@table @strong
@item Parameters
@table @var
@item table
A hash table.
@item key
A valid @code{NUL}-terminated string key.
@item value
A valid @code{pdf_time_t}.
@item error
A @code{pdf_error_t} to report errors or @code{NULL}.
@end table
@item Returns
@code{PDF_TRUE} if correctly added, @code{PDF_FALSE} otherwise.
@item Usage example
@example
pdf_hash_t *hash;
pdf_time_t *elem;
pdf_error_t *error = NULL;

/* Create a new hash */
hash = pdf_hash_new (NULL);
if (hash != NULL)
   @{
      /* Create the element for the hash */
      elem = pdf_time_new (&error);
      if (!elem)
         @{
            pdf_error_destroy (&error);
         @}
      else if (pdf_hash_add_time (hash,
                                  "a-key",
                                  elem,
                                  &error))
         @{
            pdf_time_destroy (&elem);
            pdf_error_destroy (error);
         @}
      else
         @{
            /* The time is now owned by the hash */
         @}

      /* Destroy the hash */
      pdf_hash_destroy (hash);
   @}
@end example
@end table
@end deftypefun

@deftypefun pdf_bool_t pdf_hash_add_duplicated_time (pdf_hash_t *@var{table}, const pdf_char_t *@var{key}, const pdf_time_t *@var{value}, pdf_error_t **@var{error})

Duplicates the @var{value} time in heap and adds it with the associated key @var{key} to @var{table}. If @var{key} already exists nothing is done. The internally duplicated time will be owned by the hash table, and disposed when the hash table is destroyed.

@table @strong
@item Parameters
@table @var
@item table
A hash table.
@item key
A valid @code{NUL}-terminated string key.
@item value
A valid @code{pdf_time_t}.
@item error
A @code{pdf_error_t} to report errors or @code{NULL}.
@end table
@item Returns
@code{PDF_TRUE} if correctly added, @code{PDF_FALSE} otherwise.
@item Usage example
@example
pdf_hash_t *hash;
pdf_time_t *elem;
pdf_error_t *error = NULL;

/* Create a new hash */
hash = pdf_hash_new (NULL);
if (hash != NULL)
   @{
      /* Create the element */
      elem = pdf_time_new (&error);
      if (!elem)
         @{
            pdf_error_destroy (&error);
         @}
      else if (pdf_hash_add_duplicated_time (hash,
                                             "a-key",
                                             elem,
                                             &error))
         @{
            pdf_error_destroy (error);
         @}

      /* The hash has a duplicated time,
       * we should destroy the original time */
      pdf_time_destroy (elem);

      /* Destroy the hash */
      pdf_hash_destroy (hash);
   @}
@end example
@end table
@end deftypefun

@deftypefun pdf_bool_t pdf_hash_add_static_time (pdf_hash_t *@var{table}, const pdf_char_t *@var{key}, const pdf_time_t *@var{value}, pdf_error_t **@var{error})

Adds the static and constant @var{value} time with the associated key @var{key} to @var{table}. If @var{key} already exists nothing is done. Only use this method if @var{value} will always exist. It can be used with statically allocated time objects in the main program, but not with statically allocated time objects in dynamically loadable modules (as they may be unloaded during the program execution).

@table @strong
@item Parameters
@table @var
@item table
A hash table.
@item key
A valid @code{NUL}-terminated string key.
@item value
A valid static and constant @code{pdf_time_t}.
@item error
A @code{pdf_error_t} to report errors or @code{NULL}.
@end table
@item Returns
@code{PDF_TRUE} if correctly added, @code{PDF_FALSE} otherwise.
@item Usage example
@example
pdf_hash_t *hash;
static pdf_time_t elem;
pdf_error_t *error = NULL;

/* Create a new hash */
hash = pdf_hash_new (NULL);
if (hash != NULL)
   @{
      /* Initialize time object in stack */
      pdf_time_init (&elem);

      if (pdf_hash_add_static_time (hash,
                                    "a-key",
                                    elem,
                                    &error))
         @{
            pdf_error_destroy (error);
         @}

      /* Destroy the hash */
      pdf_hash_destroy (hash);
   @}
@end example
@end table
@end deftypefun

@deftypefun {const pdf_time_t} pdf_hash_get_time (const pdf_hash_t *@var{table}, const pdf_char_t *@var{key})

Get a time variable from a hash table.

@table @strong
@item Parameters
@table @var
@item table
The hash table to get the value from.
@item key
A valid @code{NUL}-terminated string key.
@end table
@item Returns
The @code{pdf_time_t} associated with @var{key}.
@item Usage example
@example
pdf_time_t time;

/* ... insert a time variable into the hash ... */

time = pdf_hash_get_time (table, "a-key");

@end example
@end table
@end deftypefun


@deftypefun pdf_bool_t pdf_hash_add_list (pdf_hash_t *@var{table}, const pdf_char_t *@var{key}, const pdf_list_t *@var{value}, pdf_error_t **@var{error})

Adds the @var{value} list with the associated key @var{key} to @var{table}. If @var{key} already exists nothing is done. The list will be owned by the hash table, and disposed when the hash table is destroyed.

@table @strong
@item Parameters
@table @var
@item table
A hash table.
@item key
A valid @code{NUL}-terminated string key.
@item value
A valid @code{pdf_list_t}.
@item error
A @code{pdf_error_t} to report errors or @code{NULL}.
@end table
@item Returns
@code{PDF_TRUE} if correctly added, @code{PDF_FALSE} otherwise.
@item Usage example
@example
pdf_hash_t *hash;
pdf_list_t *elem;
pdf_error_t *error = NULL;

/* Create a new hash */
hash = pdf_hash_new (NULL);
if (hash != NULL)
   @{
      /* Create the element for the hash */
      elem = pdf_list_new (NULL);

      if (pdf_hash_add_list (hash,
                             "a-key",
                             elem,
                             &error))
         @{
            pdf_error_destroy (error);
         @}
      /* Destroy the hash */
      pdf_hash_destroy (hash);
   @}
@end example
@end table
@end deftypefun

@deftypefun {const pdf_list_t *}pdf_hash_get_list (const pdf_hash_t *@var{table}, const pdf_char_t *@var{key})

Get a list variable from a hash table.

@table @strong
@item Parameters
@table @var
@item table
The hash table to get the value from.
@item key
A valid @code{NUL}-terminated string key.
@end table
@item Returns
The @code{pdf_list_t} associated with @var{key}.
@item Usage example
@example
pdf_list_t *list;

/* ... insert a list variable into the hash ... */

list = pdf_hash_get_list (table, "a-key");

@end example
@end table
@end deftypefun


@deftypefun pdf_bool_t pdf_hash_add_hash (pdf_hash_t *@var{table}, const pdf_char_t *@var{key}, const pdf_hash_t *@var{value}, pdf_error_t **@var{error})

Adds the @var{value} hash with the associated key @var{key} to @var{table}. If @var{key} already exists nothing is done. The added hash table will be owned by the parent hash table, and disposed when the parent hash table is destroyed.

@table @strong
@item Parameters
@table @var
@item table
A hash table.
@item key
A valid @code{NUL}-terminated string key.
@item value
A valid @code{pdf_hash_t}.
@item error
A @code{pdf_error_t} to report errors or @code{NULL}.
@end table
@item Returns
@code{PDF_TRUE} if correctly added, @code{PDF_FALSE} otherwise.
@item Usage example
@example
pdf_hash_t *hash;
pdf_hash_t *elem;
pdf_error_t *error = NULL;

/* Create a new hash */
hash = pdf_hash_new (NULL);
if (hash != NULL)
   @{
      /* Create the element for the hash */
      elem = pdf_hash_new (NULL);

      if (pdf_hash_add_hash (hash,
                             "a-key",
                             elem,
                             &error))
         @{
            pdf_error_destroy (error);
         @}
      /* Destroy the hash */
      pdf_hash_destroy (hash);
   @}
@end example
@end table
@end deftypefun

@deftypefun {const pdf_hash_t *}pdf_hash_get_hash (const pdf_hash_t *@var{table}, const pdf_char_t *@var{key})

Get a hash variable from a hash table.

@table @strong
@item Parameters
@table @var
@item table
The hash table to get the value from.
@item key
A valid @code{NUL}-terminated string key.
@end table
@item Returns
The @code{pdf_hash_t} associated with @var{key}.
@item Usage example
@example
pdf_hash_t *hash;

/* ... insert a hash variable into the hash ... */

hash = pdf_hash_get_hash (table, "a-key");

@end example
@end table
@end deftypefun


@deftypefun pdf_bool_t pdf_hash_add_stm (pdf_hash_t *@var{table}, const pdf_char_t *@var{key}, const pdf_stm_t *@var{value}, pdf_error_t **@var{error})

Adds the @var{value} stream with the associated key @var{key} to @var{table}. If @var{key} already exists nothing is done. The stream will be owned by the hash table, and disposed when the hash table is destroyed.

@table @strong
@item Parameters
@table @var
@item table
A hash table.
@item key
A valid @code{NUL}-terminated string key.
@item value
A valid @code{pdf_stm_t}.
@item error
A @code{pdf_error_t} to report errors or @code{NULL}.
@end table
@item Returns
@code{PDF_TRUE} if correctly added, @code{PDF_FALSE} otherwise.
@item Usage example
@example
pdf_hash_t *hash;
pdf_stm_t *elem;
pdf_char_t *buf;
pdf_error_t *error = NULL;

/* Create a new hash */
hash = pdf_hash_new (NULL);
if (hash != NULL)
   @{
      /* Create the element for the hash */
      buf = pdf_alloc (10);
      stm = pdf_stm_mem_new (buf,
                             10,
                             0,
                             PDF_STM_READ,
                             &error);

      if (!stm)
         @{
            pdf_error_destroy (error);
         @}
      else if (pdf_hash_add_stm (hash,
                                 "a-key",
                                 stm,
                                 &error))
         @{
            pdf_error_destroy (error);
         @}

      /* Destroy the hash */
      pdf_hash_destroy (hash);
      /* Destroy the memory buffer */
      pdf_dealloc (buf);
   @}
@end example
@end table
@end deftypefun

@deftypefun {const pdf_stm_t *} pdf_hash_get_stm (const pdf_hash_t *@var{table}, const pdf_char_t *@var{key})

Get a stm variable from a hash table.

@table @strong
@item Parameters
@table @var
@item table
The hash table to get the value from.
@item key
A valid @code{NUL}-terminated string key.
@end table
@item Returns
The @code{pdf_stm_t} associated with @var{key}.
@item Usage example
@example
pdf_stm_t *stm;

/* ... insert a stm variable into the hash ... */

stm = pdf_hash_get_stm (table, "a-key");

@end example
@end table
@end deftypefun

@deftypefun pdf_bool_t pdf_hash_add_size (pdf_hash_t *@var{table}, const pdf_char_t *@var{key}, const pdf_size_t @var{value}, pdf_error_t **@var{error})

Adds the @var{value} stream with the associated key @var{key} to @var{table}. If @var{key} already exists nothing is done.

@table @strong
@item Parameters
@table @var
@item table
A hash table.
@item key
A valid @code{NUL}-terminated string key.
@item value
A valid @code{pdf_size_t}.
@item error
A @code{pdf_error_t} to report errors or @code{NULL}.
@end table
@item Returns
@code{PDF_TRUE} if correctly added, @code{PDF_FALSE} otherwise.
@item Usage example
@example
pdf_hash_t *hash;
pdf_error_t *error = NULL;

/* Create a new hash */
hash = pdf_hash_new (NULL);
if (hash != NULL)
   @{
      if (pdf_hash_add_size (hash,
                             "a-key",
                             (pdf_size_t)5,
                             &error))
         @{
            pdf_error_destroy (error);
         @}

      /* Destroy the hash */
      pdf_hash_destroy (hash);
      /* Destroy the memory buffer */
      pdf_dealloc (buf);
   @}
@end example
@end table
@end deftypefun

@deftypefun {const pdf_size_t} pdf_hash_get_size (const pdf_hash_t *@var{table}, const pdf_char_t *@var{key})

Get a size variable from a hash table.

@table @strong
@item Parameters
@table @var
@item table
The hash table to get the value from.
@item key
A valid @code{NUL}-terminated string key.
@end table
@item Returns
The @code{pdf_size_t} associated with @var{key}.
@item Usage example
@example
pdf_size_t size;

/* ... insert a size variable into the hash ... */

size = pdf_hash_get_size (table, "a-key");

@end example
@end table
@end deftypefun

@node Filtered Streams
@section Filtered Streams

This module provides read/write streams of data to memory buffers and
open files adding the following functionality:

@itemize @minus
@item Filtering.
@item Buffering.
@end itemize

Several streams can be created to operate in the same open file. This
provides a convenient access to files with several parts requiring
different filters to read or write its contents.

Filters (such as the PDF standard ones) are supported for both reading
and writing. Many filters may be used in a single stream (those
filters are applied in an order when writing and in the inverse order
when reading).

The file streams maintain a buffer for both reading and writing. The
size of the buffer is specified by the client in creation time. This
is used, for example, to provide efficient character-based I/O.

Note that the streams operating in memory buffers do not provide
buffering.

@menu
* Stream Types::
* Creating and Destroying Streams::
* Getting and Setting Stream Properties::
* Managing the Filter Chain::
* Reading and Writing Data::
* Stream Positioning::
@end menu

@node Stream Types
@subsection Stream Types

@deftp {Data Type} pdf_stm_t
A stream object, used to read or write in file or memory buffers.

This data type must be initialized before being used, and destroyed afterwards.
@end deftp

@deftp {Data Type} {enum pdf_stm_mode_e}
The operation mode of a stm object.

@table @code
@item PDF_STM_UNKNOWN
Unknown operation mode.
@item PDF_STM_READ
The stm will be used to read data from the open file or memory buffer.
@item PDF_STM_WRITE
The stm will be used to write data into the open file or memory buffer.
@end table
@end deftp

@deftp {Data Type} {enum pdf_stm_filter_type_e}
The several types of supported stream filters.

@table @code
@item PDF_STM_FILTER_AHEX_ENC
ASCII-Hex encoder.
@item PDF_STM_FILTER_AHEX_DEC
ASCII-Hex decoder.
@item PDF_STM_FILTER_A85_ENC
ASCII-85 encoder.
@item PDF_STM_FILTER_A85_DEC
ASCII-85 decoder.
@item PDF_STM_FILTER_LZW_ENC
LZW encoder.
@item PDF_STM_FILTER_LZW_DEC
LZW decoder.
@item PDF_STM_FILTER_FLATE_ENC
Flate (zlib) encoder.
@item PDF_STM_FILTER_FLATE_DEC
Flate (zlib) decoder.
@item PDF_STM_FILTER_RL_ENC
Run-Length encoder.
@item PDF_STM_FILTER_RL_DEC
Run-Length decoder.
@item PDF_STM_FILTER_CCITTFAX_ENC
CCITT Fax encoder.
@item PDF_STM_FILTER_CCITTFAX_DEC
CCITT Fax decoder.
@item PDF_STM_FILTER_JBIG2_ENC
JBIG2 encoder.
@item PDF_STM_FILTER_DCT_DEC
DCT decoder.
@item PDF_STM_FILTER_DCT_ENC
DCT encoder.
@item PDF_STM_FILTER_JPX_DEC
JPX decoder.
@item PDF_STM_FILTER_JPX_ENC
JPX encoder.
@item PDF_STM_FILTER_PRED_DEC
Predictor decoder.
@item PDF_STM_FILTER_PRED_ENC
Predictor encoder.
@item PDF_STM_FILTER_JBIG2_DEC
JBIG2 decoder.
@item PDF_STM_FILTER_AESV2_ENC
AESV2 encoder.
@item PDF_STM_FILTER_AESV2_DEC
AESV2 decoder.
@item PDF_STM_FILTER_V2_ENC
V2 encoder.
@item PDF_STM_FILTER_V2_ENC
V2 decoder.
@item PDF_STM_FILTER_MD5_ENC
MD5 encoder.
@end table
@end deftp

@node Creating and Destroying Streams
@subsection Creating and Destroying Streams

@deftypefun {pdf_stm_t *}pdf_stm_file_new (pdf_fsys_file_t @var{file}, pdf_off_t @var{offset}, pdf_size_t @var{cache_size}, enum pdf_stm_mode_e @var{mode}, pdf_error_t *@var{error})

Create a new stream operating in a given file object.

@table @strong
@item Parameters
@table @var
@item file
An open file. This file object must exist as long as the stream object exists.
@item offset
Position into the file.
@item cache_size
The desired size for the stream cache, measured in octets. If it is
@code{0} then the default size (4kb) is used.
@item mode
The operation mode for the stream.
@item error
A @code{pdf_error_t} to report errors or @code{NULL}.
@table @code
@item PDF_ENOMEM
Not enough memory to create the stream object.
@end table
@end table
@item Returns
A newly created @code{pdf_stm_t}, or @code{NULL} if any error happened.
@item Usage example
@example

pdf_bool_t
foo_get_write_stm_from_filepath (pdf_text_t       *path,
                                 pdf_stm_t       **stm,
                                 pdf_fsys_file_t **file,
                                 pdf_error_t     **error)
@{
  /* Open new file */
  *file = pdf_fsys_file_open (PDF_FSYS_DISK,
                              path,
                              PDF_FSYS_OPEN_MODE_WRITE,
                              error);
  if (*file == NULL)
    return PDF_FALSE;

  /* Create the stream */
  *stm = pdf_stm_file_new (file,
                           0,
                           0, /* Use the default cache size */
                           PDF_STM_WRITE,
                           error);

  if (*stm == NULL)
    @{
      pdf_fsys_file_close (*file);
      *file = NULL;
    @}

  /* Note that we return also the file object along with the
   * stream object, so that we can control that the file is not
   * closed until the stream is destroyed. */
  return (*stm != NULL ? PDF_TRUE : PDF_FALSE);
@}

@end example
@end table
@end deftypefun

@deftypefun {pdf_stm_t *}pdf_stm_cfile_new (FILE *@var{file}, pdf_off_t @var{offset}, pdf_size_t @var{cache_size}, enum pdf_stm_mode_e @var{mode}, pdf_error_t *@var{error})

Create a new stream operating in a given C file handler.

@table @strong
@item Parameters
@table @var
@item file
A C file handler.
It must be kept open as long as the stream object exists.
@item offset
Position into the file.
@item cache_size
The desired size for the stream cache, measured in octets. If it is
@code{0} then the default size (4kb) is used.
@item mode
The operation mode for the stream.
@item error
A @code{pdf_error_t} to report errors or @code{NULL}.
@table @code
@item PDF_ENOMEM
Not enough memory to create the stream object.
@end table
@end table
@item Returns
A newly created @code{pdf_stm_t}, or @code{NULL} if any error happened.
@item Usage example
@example

pdf_bool_t
foo_get_write_stm_from_stdout (pdf_stm_t   **stm,
                               pdf_error_t **error)
@{
  /* Create the stream */
  *stm = pdf_stm_cfile_new (stdout,
                            0,
                            0, /* Use the default cache size */
                            PDF_STM_WRITE,
                            error);
  return (*stm != NULL ? PDF_TRUE : PDF_FALSE);
@}

@end example
@end table
@end deftypefun

@deftypefun {pdf_stm_t *}pdf_stm_mem_new (pdf_char_t *@var{buffer}, pdf_size_t @var{size}, pdf_size_t @var{cache_size}, enum pdf_stm_mode_e @var{mode}, pdf_error_t *@var{error})

Create a new stream operating in a memory buffer.

@table @strong
@item Parameters
@table @var
@item buffer
Memory buffer where the information will be written-to or readed-from.
This buffer must exist as long as the stream object exists.
@item size
The desired size for the memory buffer, measured in octets.
@item cache_size
The desired size for the stream cache, measured in octets. If it is
@code{0} then the default size (4kb) is used.
@item mode
The operation mode for the stream.
@item error
A @code{pdf_error_t} to report errors or @code{NULL}.
@table @code
@item PDF_ENOMEM
Not enough memory to create the stream object.
@end table
@end table
@item Returns
A newly created @code{pdf_stm_t}, or @code{NULL} if any error happened.
@item Usage example
@example

pdf_bool_t
foo_get_read_stm_from_buffer (pdf_text_t   *path,
                              pdf_char_t   *buffer,
                              pdf_size_t    buffer_size,
                              pdf_stm_t   **stm,
                              pdf_error_t **error)
@{
  /* Create the stream */
  *stm = pdf_stm_mem_new (buffer,
                          buffer_size,
                          0, /* Use the default cache size */
                          PDF_STM_WRITE,
                          error);

  return (*stm != NULL ? PDF_TRUE : PDF_FALSE);
@}

@end example
@end table
@end deftypefun

@deftypefun void pdf_stm_destroy (pdf_stm_t *@var{stm})

Destroy a stream freeing all the used resources.

@table @strong
@item Parameters
@table @var
@item stm
A stream.
@end table
@item Usage example
@example

pdf_stm_t *stm;

/* Create the stream */
stm = pdf_stm_cfile_new (stdout,
                         0,
                         0, /* Use the default cache size */
                         PDF_STM_WRITE,
                         error);
if (stm)
  pdf_stm_destroy (stm);

@end example
@end table
@end deftypefun

@node Getting and Setting Stream Properties
@subsection Getting and Setting Stream Properties

@deftypefun {enum pdf_stm_mode_e} pdf_stm_get_mode (pdf_stm_t *@var{stm})

Return the mode of a given stream @var{stm}.

@table @strong
@item Parameters
@table @var
@item stm
A stream.
@end table
@item Returns
The mode of the stream.
@item Usage example
@example

pdf_stm_t *stm;

stm = pdf_stm_mem_new (buffer,
                       2048,
                       0,     /* Use the default cache size */
                       PDF_STM_WRITE,
                       NULL);
if (stm &&
    pdf_stm_get_mode (stm) != PDF_STM_WRITE)
  @{
    /* Will never happen */
  @}

@end example
@end table
@end deftypefun

@node Managing the Filter Chain
@subsection Managing the Filter Chain

The following functions can be used to build the filter chain of a
given stream.

@deftypefun pdf_bool_t pdf_stm_supported_filter_p (enum pdf_stm_filter_type_e @var{filter_type})

Query whether a given filter type is supported by the current build.

@table @strong
@item Parameters
@table @var
@item filter_type
Type of filter.
@end table
@item Returns
@code{PDF_TRUE} if the filter type is supported, @code{PDF_FALSE} otherwise.
@item Usage example
@example

if (!pdf_stm_supported_filter_p (PDF_STM_FILTER_JBIG2_ENC) ||
    !pdf_stm_supported_filter_p (PDF_STM_FILTER_JBIG2_DEC))
  @{
    printf ("Sorry but you don't have full JBIG2 support\n");
  @}

@end example
@end table
@end deftypefun


@deftypefun pdf_bool_t pdf_stm_install_filter (pdf_stm_t *@var{stm}, enum pdf_stm_filter_type_e @var{filter_type}, const pdf_hash_t *@var{filter_params}, pdf_error_t **@var{error})

Install a new filter in the filter chain of a stream.

@table @strong
@item Parameters
@table @var
@item stm
A stream.
@item filter_type
The type of the filter to be installed.
@item filter_params
Hash table containing a set of key-value pairs with the parameters for
the filter, or @code{NULL} if none needed.
@table @code
@item "Key" (AESv2 and V2)
A memory buffer with the key to be used during encryption and decryption.
Note that it may not be NUL-terminated.
This buffer should exist as long as the stream holding the filter exists.
Mandatory in the AESv2 and V2 encoder and decoder filters.
@item "KeySize" (AESv2 and V2)
Size of the key provided in "Key".
Mandatory in the AESv2 and V2 encoder and decoder filters.
@item "EarlyChange" (LZW)
Boolean value, indicating when to increase the code length.
If @code{PDF_FALSE}, code length increases are postponed as long as possible.
If @code{PDF_TRUE} (default one if parameter not given), code length increases occur one code early.
Optional in the LZW encoder and decoder filters.
@item "ColorTransform" (DCT)
Boolean value, indicating whether color transformation (RGB->YCbCr, CMYK->YCCK) should be done in the DCT filter
when no Adobe marker is found. @code{PDF_TRUE} by default if parameter not given.
Optional in the DCT decoder filter.
@item "GlobalStreamsBuffer" (JBIG2)
A memory buffer holding the global streams context for the JBIG2 decoder.
The contents of this buffer are copied internally by the JBIG2 decoder module, so there is no need to keep this buffer existing as long as the stream holding the filter exists.
Optional in the JBIG2 decoder filter.
@item "GlobalStreamsSize" (JBIG2)
Size of the buffer provided in "GlobalStreamsBuffer".
Optional in the JBIG2 decoder filter.
@end table
@item error
A @code{pdf_error_t} to report errors or @code{NULL}.
@table @code
@item PDF_ENOMEM
Not enough memory to create the stream object.
@end table
@end table
@item Returns
@code{PDF_TRUE} if the filter was correctly installed, @code{PDF_FALSE} otherwise.
@item Usage example
@example

pdf_stm_t *
foo_get_read_stm_from_stdin (const pdf_char_t  *key,
                             pdf_size_t         keysize,
                             pdf_error_t      **error)
@{
  pdf_stm_t *stm;
  pdf_hash_t *filter_params;

  /* Create reading stream from standard input */
  stm = pdf_stm_cfile_new (stdin, 0, PDF_STM_READ, error);
  if (!stm)
    return NULL;

  /* Create an empty hash table for filter parameters */
  filter_params = pdf_hash_new (error);
  if (!filter_params)
    @{
      pdf_stm_destroy (stm);
      return NULL;
    @}

  /* Add the filter parameters to the hash table */
  if (!pdf_hash_add (filter_params, "Key", key, NULL, error) ||
      !pdf_hash_add_size (filter_params, "KeySize", keysize, error))
    @{
      pdf_hash_destroy (stm);
      pdf_stm_destroy (stm);
      return NULL;
    @}

  /* Install a new AESv2 Decoder filter */
  if (!pdf_stm_install_filter (stm,
                               PDF_STM_FILTER_AESV2_DEC,
                               filter_params,
                               &error))
    @{
      pdf_hash_destroy (stm);
      pdf_stm_destroy (stm);
      return NULL;
    @}

  /* Once installed, the hash table can be safely destroyed */
  pdf_hash_destroy (stm);

  return stm;
@}

@end example
@end table
@end deftypefun

@node Reading and Writing Data
@subsection Reading and Writing Data

@deftypefun pdf_bool_t pdf_stm_read (pdf_stm_t *@var{stm}, pdf_uchar_t *@var{buf}, pdf_size_t @var{bytes}, pdf_size_t *@var{read_bytes}, pdf_error_t **@var{error})

Read a chunk of data from a given stream.

@table @strong
@item Parameters
@table @var
@item stm
A stream.
@item buf
The buffer to hold the read data.
@item bytes
The number of octets to be read.
@item read_bytes
The number of octets actually read after the operation. May be less than @var{bytes} if an error is detected or on EOF condition.
@item error
A @code{pdf_error_t} to report errors or @code{NULL}.
@table @code
@item PDF_EINVOP
Cannot read from a writing stream.
@item PDF_EINVRANGE
Invalid offset in the backend.
@item PDF_ERROR
Generic error while reading from the backend.
@end table
@end table
@item Returns
@code{PDF_TRUE} if all @var{bytes} were read. @code{PDF_FALSE} is returned both on EOF and upon detecting an error, but the @var{error} variable will not be set on EOF.
@item Usage example
@example

pdf_bool_t
foo_read_from_buffer (const pdf_uchar_t  *input_buffer,
                      pdf_size_t          input_buffer_size,
                      pdf_uchar_t       **output_buffer,
                      pdf_size_t         *output_buffer_size,
                      pdf_error_t       **error)
@{
  pdf_uchar_t *buffer;
  pdf_size_t read_bytes;
  pdf_error_t *inner_error = NULL;

  /* Create the memory stream */
  stm = pdf_stm_mem_new (input_buffer,
                         input_buffer_size,
                         0, /* Use the default cache size */
                         PDF_STM_READ,
                         error);
  if (!stm)
    return PDF_FALSE;

  /* Read up to 100 bytes from the input buffer */
  output_buffer = pdf_alloc (100);
  read_bytes = 0;
  if (!pdf_stm_read (stm,
                     output_buffer,
                     100,
                     &read_bytes,
                     &inner_error) &&
      inner_error)
    @{
      pdf_propagate_error (error, inner_error);
      pdf_stm_destroy (stm);
      return PDF_FALSE;
    @}

  pdf_stm_destroy (stm);

  *output_buffer_size = read_bytes;
  *output_buffer = buffer;

  return PDF_TRUE;
@}

@end example
@end table
@end deftypefun

@deftypefun pdf_bool_t pdf_stm_write (pdf_stm_t *@var{stm}, const pdf_uchar_t *@var{buf}, pdf_size_t @var{bytes}, pdf_size_t *@var{written_bytes}, pdf_error_t *@var{error})

Write a chunk of data into a given stream.

@table @strong
@item Parameters
@table @var
@item stm
A stream.
@item buf
The buffer containing the written information.
@item bytes
The number of octets to be written into the stream.
@item written_bytes
The number of octets actually written after the operation. May be less than @var{bytes} if an error is detected or on EOF condition.
@item error
A @code{pdf_error_t} to report errors or @code{NULL}.
@table @code
@item PDF_EINVOP
Cannot write into a reading stream.
@item PDF_EINVRANGE
Invalid offset in the backend.
@item PDF_ERROR
Generic error while writing into the backend.
@end table
@end table
@item Returns
@code{PDF_TRUE} if all @var{bytes} were written. @code{PDF_FALSE} is returned both on EOF and upon detecting an error, but the @var{error} variable will not be set on EOF.
@item Usage example
@example

pdf_bool_t
foo_write_to_buffer (const pdf_uchar_t  *input_buffer,
                     pdf_size_t          input_buffer_size,
                     pdf_uchar_t        *output_buffer,
                     pdf_size_t          output_buffer_size,
                     pdf_size_t         *written_bytes,
                     pdf_error_t       **error)
@{
  pdf_error_t *inner_error = NULL;

  /* Create the memory stream */
  stm = pdf_stm_mem_new (output_buffer,
                         output_buffer_size,
                         0, /* Use the default cache size */
                         PDF_STM_WRITE,
                         error);
  if (!stm)
    return PDF_FALSE;

  /* Write up to 100 bytes to the output buffer */
  written_bytes = 0;
  if (!pdf_stm_write (stm,
                      input_buffer,
                      (input_buffer_size > 100 ?
                       100 : input_buffer_size),
                      written_bytes,
                      &inner_error) &&
      inner_error)
    @{
      pdf_propagate_error (error, inner_error);
      pdf_stm_destroy (stm);
      return PDF_FALSE;
    @}

  pdf_stm_destroy (stm);

  return PDF_TRUE;
@}

@end example
@end table
@end deftypefun

@deftypefun pdf_bool_t pdf_stm_read_char (pdf_stm_t *@var{stm}, pdf_uchar_t *@var{read_char}, pdf_error_t **@var{error})

Read a character from a given stream.

@table @strong
@item Parameters
@table @var
@item stm
A stream.
@item read_char
The address of where to store the read character.
@item error
A @code{pdf_error_t} to report errors or @code{NULL}.
@table @code
@item PDF_EINVOP
Cannot read from a writing stream.
@item PDF_EINVRANGE
Invalid offset in the backend.
@item PDF_ERROR
Generic error while reading from the backend.
@end table
@end table
@item Returns
@code{PDF_TRUE} if the character was properly read, @code{PDF_FALSE} otherwise.
@item Usage example
@example

pdf_bool_t
foo_read_byte_per_byte (pdf_stm_t    *stm,
                        pdf_error_t **error)
@{
  pdf_uchar_t c;
  pdf_error_t *inner_error = NULL;

  while (pdf_stm_read_char (stm, &c, &inner_error))
    @{
      printf ("Read char: '%c'\n", c);
    @}

  if (inner_error)
    @{
      printf ("Got error while reading: %s\n",
              pdf_error_get_message (inner_error));
      pdf_propagate_error (error, inner_error);
      return PDF_FALSE;
    @}

  return PDF_TRUE;
@}

@end example
@end table
@end deftypefun

@deftypefun pdf_bool_t pdf_stm_peek_char (pdf_stm_t *@var{stm}, pdf_char_t *@var{read_char}, pdf_error_t **@var{error})

Peek a character from a given stream. When peeking instead of reading, the offset in the stream is not changed. Two consecutive calls to @code{pdf_stm_peek_char()} will always return the same result.

@table @strong
@item Parameters
@table @var
@item stm
A stream.
@item read_char
The address of where to store the read character.
@item error
A @code{pdf_error_t} to report errors or @code{NULL}.
@table @code
@item PDF_EINVOP
Cannot read from a writing stream.
@item PDF_EINVRANGE
Invalid offset in the backend.
@item PDF_ERROR
Generic error while reading from the backend.
@end table
@end table
@item Returns
@code{PDF_TRUE} if the character was properly read, @code{PDF_FALSE} otherwise.
@item Usage example
@example

pdf_bool_t
foo_read_byte_per_byte (pdf_stm_t    *stm,
                        pdf_error_t **error)
@{
  pdf_error_t *inner_error = NULL;

  while (PDF_TRUE)
    @{
      pdf_uchar_t c;

      if (pdf_stm_peek_char (stm, &c, NULL))
        printf ("Read char: '%c'\n", c);

      /* Need to advance the offset now */
      if (!pdf_stm_read_char (stm, &c, &inner_error))
        break;
    @}

  if (inner_error)
    @{
      printf ("Got error while reading: %s\n",
              pdf_error_get_message (inner_error));
      pdf_propagate_error (error, inner_error);
      return PDF_FALSE;
    @}

  return PDF_TRUE;
@}

@end example
@end table
@end deftypefun

@deftypefun pdf_bool_t pdf_stm_flush (pdf_stm_t *@var{stm}, pdf_bool_t @var{finish}, pdf_size_t *@var{flushed_bytes}, pdf_error_t **@var{error})

Flush any pending writing data in a given stream.

If @var{finish} equals to @code{PDF_TRUE} then the filters in the
stream's filter chain are told to generate any remaining output.

@table @strong
@item Parameters
@table @var
@item stm
A stream.
@item finish
A boolean value indicating whether to finalize the filter chain.
@item flushed_bytes
The number of octets flushed after the operation.
@code{NULL} may also be passed if this number is not needed.
@item error
A @code{pdf_error_t} to report errors or @code{NULL}.
@table @code
@item PDF_EINVOP
Cannot write into a reading stream.
@item PDF_EINVRANGE
Invalid offset in the backend.
@item PDF_ERROR
Generic error while writing into the backend.
@end table
@end table
@item Returns
@code{PDF_TRUE} if all pending octets were flushed. @code{PDF_FALSE} is returned both on EOF and upon detecting an error, but the @var{error} variable will not be set on EOF.
@item Usage example
@example

pdf_bool_t
foo_write_to_buffer_and_flush (const pdf_uchar_t  *input_buffer,
                               pdf_size_t          input_buffer_size,
                               pdf_uchar_t        *output_buffer,
                               pdf_size_t          output_buffer_size,
                               pdf_size_t         *written_bytes,
                               pdf_error_t       **error)
@{
  pdf_error_t *inner_error = NULL;

  /* Create the memory stream */
  stm = pdf_stm_mem_new (output_buffer,
                         output_buffer_size,
                         0, /* Use the default cache size */
                         PDF_STM_WRITE,
                         error);
  if (!stm)
    return PDF_FALSE;

  /* Write up to 100 bytes to the output buffer */
  written_bytes = 0;
  if (!pdf_stm_write (stm,
                      input_buffer,
                      (input_buffer_size > 100 ?
                       100 : input_buffer_size),
                      written_bytes,
                      &inner_error) &&
      inner_error)
    @{
      pdf_propagate_error (error, inner_error);
      pdf_stm_destroy (stm);
      return PDF_FALSE;
    @}

  /* Before returning, ensure everything gets flushed. */
  if (!pdf_buffer_flush (stm, NULL, &inner_error) &&
      inner_error)
    @{
      pdf_propagate_error (error, inner_error);
      pdf_stm_destroy (stm);
      return PDF_FALSE;
    @}

  pdf_stm_destroy (stm);

  return PDF_TRUE;
@}

@end example
@end table
@end deftypefun

@node Stream Positioning
@subsection Stream Positioning

@deftypefun pdf_off_t pdf_stm_bseek (pdf_stm_t *@var{stm}, pdf_off_t @var{pos})

Seek into the backend of a given stream.

@table @strong
@item Parameters
@table @var
@item stm
A stream.
@item pos
The position to seek, measured in octets from the beginning of the
backend media.
@end table
@item Returns
The new position of the stream read/write pointer.
@item Usage example
@example

pdf_bool_t
foo_read_backwards (const pdf_uchar_t  *input_buffer,
                    pdf_size_t          input_buffer_size,
                    pdf_error_t       **error)
@{
  pdf_error_t *inner_error = NULL;
  pdf_stm_t *stm;
  int i;

  /* Create the stream */
  stm = pdf_stm_mem_new (input_buffer,
                         input_buffer_size,
                         0, /* Use the default cache size */
                         PDF_STM_READ,
                         &error);
  if (!stm)
    return PDF_FALSE;

  /* Read all characters from the stream, one by one, in reverse other
   * by seeking in each loop */
  for (i = (input_buffer_size - 1); i >= 0; i--)
    @{
      pdf_uchar_t ret_char;

      /* Bseek into the stream */
      if (pdf_stm_bseek (stm, i) != i)
        @{
          pdf_stm_destroy (stm);
          return PDF_FALSE;
        @}

      /* Peek */
      if (!pdf_stm_peek_char (stm, &ret_char, &error))
        @{
          pdf_stm_destroy (stm);
          return PDF_FALSE;
        @}

      printf ("Char was read: %c\n", (pdf_char_t)ret_char);
    @}

  pdf_stm_destroy (stm);

  return PDF_TRUE;
@}

@end example
@end table
@end deftypefun

@deftypefun pdf_off_t pdf_stm_btell (pdf_stm_t *@var{stm})

Get the current position of the read/write pointer of the backend of a
stream.

@table @strong
@item Parameters
@table @var
@item stm
A stream.
@end table
@item Returns
The current position (measured in octets from the beginning of the
backend media) of the read/write pointer.
@item Usage example
@example

  stm = pdf_stm_mem_new (input_buffer,
                         input_buffer_size,
                         0, /* Use the default cache size */
                         PDF_STM_READ,
                         &error);
  if (stm)
    @{
      printf ("Offset in stream is: %lu\n",
              (unsigned long) pdf_stm_btell (stm));
    @}

@end example
@end table
@end deftypefun

@deftypefun pdf_off_t pdf_stm_tell (pdf_stm_t *@var{stm})

Get the number of octets read/written from/to the stream since either
the last @code{pdf_stm_bseek} operation or the creation of the
stream, if no bseek was made.

@table @strong
@item Parameters
@table @var
@item stm
A stream.
@end table
@item Returns
The current position (measured in octets) of the read/write pointer.
@item Usage example
@example

  stm = pdf_stm_mem_new (input_buffer,
                         input_buffer_size,
                         0, /* Use the default cache size */
                         PDF_STM_READ,
                         &error);
  if (stm)
    @{
      printf ("Offset in stream is: %lu\n",
              (unsigned long) pdf_stm_tell (stm));
    @}

@end example
@end table
@end deftypefun

@node Floating Point Maths
@section Floating Point Maths

@menu
* Floating Point Constants::
* Floating Point Types::
* Rounding Routines::
* Exponential and Logarithmic Routines::
* Number Conversion Routines::
* Trigonometric Routines::
* Geometry Routines::
* Other Maths Routines::
* Creation and Destruction of Functions::
* Evaluation of Functions::
@end menu

@node Floating Point Constants
@subsection Floating Point Constants

@deftp {Constant} PDF_PI
The value of PI.
@end deftp

@deftp {Constant} PDF_REAL_MAX
Maximum value able to be stored in a @code{pdf_real_t} variable.
@end deftp

@deftp {Constant} PDF_REAL_MIN
Minimum value able to be stored in a @code{pdf_real_t} variable.
@end deftp

@node Floating Point Types
@subsection Floating Point Types

@deftp {Data Type} pdf_real_t
An opaque type representing a floating-point number.
@end deftp

The following constants specify the valid ranges for this data type:

@deftp {Data Type} {struct pdf_point_s}

This structure represents a single point. The coordinates of the point
are made using floating point numbers.

@table @code
@item pdf_real_t h
Horizontal coordinate.
@item pdf_real_t v
Vertical coordinate.
@end table
@end deftp

@deftp {Data Type} pdf_point_t

A pointer to a @code{pdf_point_s} structure.

@end deftp

@deftp {Data Type} {struct pdf_matrix_s}

This structure represents a 3x3 matrix representing an affine
transformation.

@table @code
@item pdf_real_t a
@item pdf_real_t b
The first row of the matrix is @code{a b 0}.
@item pdf_real_t c
@item pdf_real_t d
The second row of the matrix is @code{c d 0}.
@item pdf_real_t h
@item pdf_real_t v
The third row of the matrix is @code{h v 1}.
@end table
@end deftp

@deftp {Data Type} pdf_matrix_t

A pointer to a @code{pdf_matrix_s} structure.

@end deftp


@deftp {Data Type} {struct pdf_rect_s}

This structure represents a rectangle. It is composed by the
coordinates for its four sides.

The rectangle sides should be horizontal and vertical and opposite
sides should be parallel.

@table @code
@item pdf_real_t left
@code{x} coordinate for the left points.
@item pdf_real_t top
@code{y} coordinate for the upper points.
@item pdf_real_t right
@code{x} coordinate for the right points.
@item pdf_real_t bottom
@code{y} coordinate for the bottom points.
@end table
@end deftp

@deftp {Data Type} pdf_rect_t

A pointer to a @code{pdf_rect_s} structure.

@end deftp

@deftp {Data Type} {struct pdf_quad_s}
This structure represents a quadrilateral. It is composed by four
corners (floating-point points).
@table @code
@item pdf_point_t tl
Top-left point.
@item pdf_point_t tr
Top-right point.
@item pdf_point_t bl
Bottom-left point.
@item pdf_point_t br
Bottom-right point.
@end table
@end deftp

@deftp {Data Type} pdf_quad_t

A pointer to a @code{pdf_quad_t} structure.

@end deftp

@deftp {Data Type} pdf_fp_func_t

Opaque type representing a Floating Point function.

@end deftp

@node Rounding Routines
@subsection Rounding Routines

@deftypefun pdf_real_t pdf_fp_floor (pdf_real_t @var{op})

Round @var{op} down to the nearest integer.

@table @strong
@item Parameters
@table @var
@item op
A real operand.
@end table
@item Returns
The rounded integer value. If @var{op} is integral or infinite,
@var{op} itself is returned.
@item Usage example
@example
pdf_real_t number;
pdf_u32_t rounded;

number = 1.2;
rounded = pdf_fp_floor (number);
/* rounded equals 1 */

number = 1.6;
rounded = pdf_fp_floor (number);
/* rounded equals 1 */

number = 2;
rounded = pdf_fp_floor (number);
/* rounded equals 2 */
@end example
@end table
@end deftypefun

@deftypefun pdf_real_t pdf_fp_ceil (pdf_real_t @var{op})

Round @var{op} up to the nearest integer.

@table @strong
@item Parameters
@table @var
@item op
A real operand.
@end table
@item Returns
The rounded integer value. If @var{op} is integral or infinite,
@var{op} itself is returned.
@item Usage example
@example
pdf_real_t number;
pdf_u32_t rounded;

number = 1.2;
rounded = pdf_fp_ceil (number);
/* rounded equals 2 */

number = 1.6;
rounded = pdf_fp_ceil (number);
/* rounded equals 2 */

number = 2;
rounded = pdf_fp_ceil (number);
/* rounded equals 2 */
@end example
@end table
@end deftypefun

@node Exponential and Logarithmic Routines
@subsection Exponential and Logarithmic Routines

@deftypefun pdf_real_t pdf_fp_exp (pdf_real_t @var{op})

Return the value of e (the base of natural logarithms) raised to the
power of @var{op}.

@table @strong
@item Parameters
@table @var
@item op
A real operand.
@end table
@item Returns
The value of e raised to the power of @var{op}.
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@deftypefun pdf_real_t pdf_fp_log (pdf_real_t @var{op})

Return the natural logarithm of @var{op}.

@table @strong
@item Parameters
@table @var
@item op
A real operand.
@end table
@item Returns
The natural logarithm of @var{op}.
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@deftypefun pdf_real_t pdf_fp_log10 (pdf_real_t @var{op})

Return the base 10 logarithm of @var{op}.

@table @strong
@item Parameters
@table @var
@item op
A real operand.
@end table
@item Returns
The base 10 logarithm of @var{op}.
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun


@node Number Conversion Routines
@subsection Number Conversion Routines

@deftypefun pdf_status_t pdf_fp_string_to_real (const pdf_char_t *@var{string}, pdf_real_t *@var{result})

Convert a numeric string representation to a @code{pdf_real_t}
value. The string is scanned from left to right, taking into account
the data before the first invalid character.

@table @strong
@item Parameters
@table @var
@item string
A @code{NULL} terminated string.
@item result
The real variable where the result is stored.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The conversion was successful.
@item PDF_ERROR
No recognizable real value was found in the string.
@end table
@item Usage example
@example
pdf_real_t real;
pdf_char_t str[5];

strcpy (str, "1");
str[1] = 0;
pdf_fp_string_to_real (str, &real);
/* real now contains 1.0 */

strcpy (str, "1.0");
str[3] = 0;
pdf_fp_string_to_real (str, &real);
/* real now contains 1.0 */


strcpy (str, "1.0X");
str[4] = 0;
pdf_fp_string_to_real (str, &real);
/* real now contains 1.0 */

strcpy (str, "foo");
str[3] = 0;
if (pdf_fp_string_to_real (str, &real) == PDF_ERROR)
@{
   /* The code reach this point */
@}
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_fp_real_to_string (pdf_real_t @var{real}, pdf_char_t *@var{buffer}, pdf_size_t @var{size}, pdf_u32_t @var{precision})

Get a textual representation of a  @code{pdf_real_t} value.

@table @strong
@item Parameters
@table @var
@item real
The number to convert.
@item buffer
The buffer where to store the textual representation of @var{real}.
Note that this function adds a @code{'\0'} to the end of the textual
representation.
@item size
The maximum number of characteres that may be stored in @var{buffer}.
@item precision
The number of decimal digits to include in the textual representation.
If it is @code{0} then the maximum precision is used.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
A textual representation of @var{real} was successfully written in
@var{s}.
@item PDF_ERROR
An error prevented to perform the conversion.
@end table
@item Usage example
@example
pdf_real_t real;
pdf_char_t s[9];

real = 1.123456;

pdf_fp_real_to_string (real, s, 9, 6);
/* s contains "1.123456" */

pdf_fp_real_to_string (real, s, 9, 3);
/* s contains "1.123" */

if (pdf_fp_real_to_string (real, s, 4, 3) == PDF_ERROR)
@{
    /* The code reach this point: not enough space in the string
       to hold the textual representation of the number with
       the specified precision */
@}
@end example
@end table
@end deftypefun

@node Trigonometric Routines
@subsection Trigonometric Routines

@deftypefun pdf_real_t pdf_fp_sin (pdf_real_t @var{op})

Return the sine of @var{op}, where @var{op} is given in radians.

@table @strong
@item Parameters
@table @var
@item op
A real operand.
@end table
@item Returns
A real value between @code{-1} and @code{1}.
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@deftypefun pdf_real_t pdf_fp_cos (pdf_real_t @var{op})

Return the cosine of @var{op}, where @var{op} is given in radians.

@table @strong
@item Parameters
@table @var
@item op
A real operand.
@end table
@item Returns
A real value between @code{-1} and @code{1}.
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@deftypefun pdf_real_t pdf_fp_atan2 (pdf_real_t @var{op1}, pdf_real_t @var{op2})

Return the arc tangent of the two values @var{op1} and @var{op2}. It
is similar to calculating the arc tangent of @code{op1 / op2} except
that the signs of both arguments are used to determine the quadrant of
the result.

@table @strong
@item Parameters
@table @var
@item op
A real operand.
@end table
@item Returns
The result in radians, wichi is between @code{-PDF_PI} and
@code{PDF_PI} (inclusive).
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@node Geometry Routines
@subsection Geometry Routines

@deftypefun pdf_status_t pdf_fp_matrix_concat (pdf_matrix_t @var{result}, pdf_matrix_t @var{matrix_1}, pdf_matrix_t @var{matrix_2})

Multiplies two matrices.

@table @strong
@item Parameters
@item result
Pointer to the matrix that will be filled with the result. It may be
a copy of @var{matrix_1} or @var{matrix_2}.
@item matrix_1
The first matrix to multiply.
@item matrix_2
The second matrix to multiply.
@item Returns
A PDF status code:
@table @code
@item PDF_OK
The operation succeeded.
@item PDF_ERROR
There was an error performing the execution.
@end table
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_fp_matrix_invert (pdf_matrix_t @var{result}, pdf_matrix_t @var{matrix})

Calculate the inverse of a matrix.

@table @strong
@item Parameters
@table @var
@item result
A pointer to a matrix that will store the inverted matrix. This
parameters can be a copy of @var{matrix}.
@item matrix
A pointer to a matrix used to calculate the inverse.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The operation succeeded.
@item PDF_ERROR
An error prevented the operation to finish.
@end table
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_fp_matrix_transform (pdf_point_t @var{result}, const pdf_matrix_t @var{matrix}, const pdf_point_t @var{point})

Transform a point through a matrix.

@table @strong
@item Parameters
@table @var
@item result
A pointer to a point to hold the result. This can be a copy of
@var{point}.
@item matrix
A pointer to the matrix used to perform the transformation.
@item point
A pointer to the point to transform.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The operation suceeded.
@item PDF_ERROR
An error prevented the operation to finish.
@end table
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_fp_matrix_transform_rect (pdf_rect_t @var{result}, const pdf_matrix_t @var{matrix}, const pdf_rect_t @var{rect})

Transform a rectangle through a matrix.

@table @strong
@item Parameters
@table @var
@item result
A pointer to a rectangle to hold the result. This can be a copy of
@var{rect}.
@item matrix
A pointer to the matrix used to perform the transformation.
@item point
A pointer to the rectangle to transform.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The operation suceeded.
@item PDF_ERROR
An error prevented the operation to finish.
@end table
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@node Other Maths Routines
@subsection Other Maths Routines

@deftypefun pdf_fp_abs (pdf_real_t @var{op})

Return the absolute value of the real number @var{op}.

@table @strong
@item Parameters
@table @var
@item op
A real operand.
@end table
@item Returns
The absolute value of the operand.
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@deftypefun pdf_fp_sqrt (pdf_real_t @var{op})

Return the non-negative square root of @var{op}.

@table @strong
@item Parameters
@table @var
@item op
A real operand.
@end table
@item Returns
The square root of @var{op}.
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun


@node Creation and Destruction of Functions
@subsection Creation and Destruction of Functions

@deftypefun pdf_status_t pdf_fp_func_0_new (pdf_u32_t @var{m}, pdf_u32_t @var{n}, const pdf_real_t @var{domain}[], const pdf_real_t @var{range}[], pdf_u32_t @var{size}[], pdf_u32_t @var{bps}, pdf_u32_t @var{order}, const pdf_real_t @var{encode}[], const pdf_real_t @var{decode}[], pdf_char_t *@var{samples}, pdf_size_t @var{samples_size}, pdf_fp_func_t *@var{function})

Create a new type 0 (sampled) function.

@table @strong
@item Parameters
@table @var
@item m
Number of input values.
@item n
Number of output values.
@item domain
Array of @code{2 * m} numbers. Each pair of consecutive numbers
defines the domain of an input variable.
@item range
Array of @code{2 * n} numbers. Each pair of consecutive numbers
defines the range of an output variable. Output values outside these
ranges will be clipped to the appropriate range.
@item size
Array of @code{m} positive integers containing the number of samples
in each input dimension in the samples table.
@item bps
The number of bits used to represent a sample in the samples
table. Valid values shall be @code{1}, @code{2}, @code{4}, @code{8},
@code{12}, @code{16}, @code{24} and @code{32}.
@item order
Order of interpolation between samples. Valid values shall be @code{1}
and @code{3}.
@item encode
Array of @code{2 * m} numbers specifying the linear mapping of input
values into the domain of the function's sample table.
@item decode
Array of @code{2 * n} numbers specifying the linear mapping of sample
values into the range appropriate for the function's output values.
@item samples
Buffer containing the samples table for the function.
@item samples_size
Size of the samples table.
@item function
A pointer to the variable holding the new function.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The function was successfully created.
@item PDF_ERROR
Error while creating the function.
@end table
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_fp_func_2_new (pdf_u32_t @var{m}, pdf_u32_t @var{n}, const pdf_real_t @var{domain}[], const pdf_real_t @var{range}[], pdf_real_t @var{N}, pdf_real_t @var{c0}[], pdf_real_t @var{c1}[], pdf_fp_func_t *@var{function})

Create a new type 2 (exponential interpolation) function.

@table @strong
@item Parameters
@table @var
@item m
Number of input values.
@item n
Number of output values.
@item domain
Array of @code{2 * m} numbers. Each pair of consecutive numbers
defines the domain of an input variable.
@item range
Array of @code{2 * n} numbers. Each pair of consecutive numbers
defines the range of an output variable. Output values outside these
ranges will be clipped to the appropriate range.
@item N
The interpolation exponent.
@item c0
An array of @code{n} numbers that shall define the function result
when @code{x = 0.0}.
@item c1
An array of n numbers that shall define the function return when
@code{x = 1.0}.
@item function
Pointer to a variable holding the new function.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The function was successfully created.
@item PDF_ERROR
Error while creating the function.
@end table
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_fp_func_3_new (pdf_u32_t @var{m}, pdf_u32_t @var{n}, const pdf_real_t @var{domain}[], const pdf_real_t @var{range}[], pdf_u32_t @var{k}, pdf_fp_func_t *@var{functions}, pdf_real_t @var{bounds}[], const pdf_u32_t @var{encode}[], pdf_fp_func_t *@var{function})

Create a new type 3 (stitching) function.

@table @strong
@item Parameters
@table @var
@item m
Number of input values.
@item n
Number of output values.
@item domain
Array of @code{2 * m} numbers. Each pair of consecutive numbers
defines the domain of an input variable.
@item range
Array of @code{2 * n} numbers. Each pair of consecutive numbers
defines the range of an output variable. Output values outside these
ranges will be clipped to the appropriate range.
@item k
Number of stitching functions.
@item functions
An array of @code{k} 1-input functions that shall make up the
stitching function. The output dimensionality of all functions shall
be the same, and compatible with the value of @var{range}.
@item bounds
An array of @code{k - 1} numbers that, in combination with
@var{domain}, shall define the intervals to which each function from
the @var{functions} parameter shall apply. @var{bounds} elements shall
be in order of increasing value, and each value shall be within the
domain defined by @var{domain}.
@item encode
An array of @code{2 * k} numbers that, taken in pairs, shall map each
subset of the domain defined by @var{domain} and the @var{bounds}
parameter to the domain of the corresponding function.
@item function
A pointer to a variable holding the new function.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The function was successfully created.
@item PDF_ERROR
Error while creating the function.
@end table
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_fp_func_4_new (pdf_u32_t @var{m}, pdf_u32_t @var{n}, pdf_real_t @var{domain}[], pdf_real_t @var{range}[], pdf_char_t *@var{code}, pdf_size_t @var{code_size}, pdf_size_t *@var{error_at}, pdf_fp_func_t *@var{function})

Create a new type 4 (postscript calculator) function.

@table @strong
@item Parameters
@table @var
@item m
Number of input values.
@item n
Number of output values.
@item domain
Array of @code{2 * m} numbers. Each pair of consecutive numbers
defines the domain of an input variable.
@item range
Array of @code{2 * n} numbers. Each pair of consecutive numbers
defines the range of an output variable. Output values outside these
ranges will be clipped to the appropriate range.
@item code
Memory buffer containing the postscript code to execute.
@item code_size
Size of @var{code}.
@item error_at
Pointer to a variable where it will put the current offset on error.
@item function
Pointer to a variable holding the new function.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The function was successfully created.
@item PDF_ERROR
Error while creating the function.
@end table
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_fp_func_destroy (pdf_fp_func_t @var{function})

Destroy a function.

@table @strong
@item Parameters
@table @var
@item function
A pointer to an initialized function.
@end table
@item Returns
A PDF status variable:
@table @code
@item PDF_OK
The function was successfully destroyed.
@end table
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@node Evaluation of Functions
@subsection Evaluation of Functions

@deftypefun pdf_status_t pdf_fp_func_get_bounds (const pdf_fp_func_t @var{function}, pdf_i32_t *@var{in_dimensions}, pdf_i32_t *@var{out_dimensions})

Return the bounds of a given function.

@table @strong
@item Parameters
@table @var
@item function
An initialized function.
@item in_dimensions
Variable to hold the input dimensions of @var{function}.
@item out_dimensions
Variable to hold the output dimensions of @var{function}.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The operation was successfully performed.
@end table
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun


@deftp {Constant} PDF_FP_FUNC_TYPE4_TRUE
Stand for true value in the debugging information structure.
@end deftp

@deftp {Constant} PDF_FP_FUNC_TYPE4_FALSE
Stand for false value in the debugging information structure.
@end deftp


@deftp {Data Type} {pdf_fp_func_debug_t}

This structure contains debugging data associated to the evaluation of a
function.

@table @code
@item type0
No information for type0 functions.
@item type2
No information for type2 functions.
@item type3
No information for type3 functions.
@item type4
@table @code
@item status
A PDF status value:
@table @code
@item PDF_ERROR
An unknown error ocurred.
@item PDF_EINVRANGE
Invalid range operand for the current operator..
@item PDF_EUNDERFLOW
Try to fetch an element from an empty stack.
@item PDF_EOVERFLOW
Overflow of stack.
@item PDF_EBADTYPE
Invalid type data for the current operator.
@item PDF_EMATH
Math error.
@end table
@item op
Offset in the source code in which the error ocurred.
@item stack_size
Size of the stack.
@item stack
Array of elements in the stack when the error ocurred. The first element
is the last pushed one. Each element is a double value or a boolean one.
@end table
@end table
@end deftp


@deftypefun pdf_status_t pdf_fp_func_eval (pdf_fp_func_t @var{function}, const pdf_real_t @var{in}[], pdf_real_t @var{out}[], pdf_fp_func_debug_t *@var{debug})

Evaluate a function.

@table @strong
@item Parameters
@table @var
@item function
The function to evaluate.
@item in
Array containing the input values for the function.
@item out
Array containing the output values from the function evaluation.
@item debug
A pointer to the structure will contain debug information.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The evaluation was successfully performed.
@item PDF_ERROR
Error while evaluating the function.
@item PDF_TYPE0
Error in a type0 function. The debug structure will contain more information.
@item PDF_TYPE2
Error in a type2 function. The debug structure will contain more information.
@item PDF_TYPE3
Error in a type3 function. The debug structure will contain more information.
@item PDF_TYPE4
Error in a type4 function. The debug structure will contain more information.
@end table
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@node Encoded Text
@section Encoded Text

@menu
* Text Data Types::
* Creating and Destroying Text::
* Managing Text Properties::
* Managing Text Contents::
* Comparing Text Variables::
* Managing Host Encodings::
@end menu

@node Text Data Types
@subsection Text Data Types

@deftp {Data Type} {enum pdf_text_unicode_encoding_e}

Enumeration of supported Unicode encodings.

@table @code
@item PDF_TEXT_UTF8
UTF-8 encoding.
@item PDF_TEXT_UTF16_BE
Big Endian UTF-16 encoding.
@item PDF_TEXT_UTF16_LE
Little Endian UTF-16 encoding.
@item PDF_TEXT_UTF16_HE
Host Endian UTF-16 encoding (may be little-endian or big-endian).
@item PDF_TEXT_UTF32_BE
Big Endian UTF-32 encoding.
@item PDF_TEXT_UTF32_LE
Little Endian UTF-32 encoding.
@item PDF_TEXT_UTF32_HE
Host Endian UTF-32 encoding (may be little-endian or big-endian).
@end table
@end deftp


@deftp {Data Type} {pdf_text_unicode_options_e}

Enumeration of extra options to get the contents of a pdf_text_t in a given
UNICODE encoding (see function `pdf_text_get_unicode').

@table @code
@item PDF_TEXT_UNICODE_NO_OPTION (= 0)
No specific option
@item PDF_TEXT_UNICODE_WITH_BOM
Prepend Byte Order Marker to the UNICODE string.
@item PDF_TEXT_UTF16BE_WITH_LANGCODE
Insert language/country code information between the BOM (if required) and the
data. This option is ONLY applicable to UTF16BE. If specified in any other
encoding, the function will fail.
@item PDF_TEXT_UNICODE_WITH_NUL_SUFFIX
Append a NUL suffix to the Unicode string (1-byte NUL for UTF-8, 2-byte NUL for
UTF-16 and 4-byte NUL for UTF-32).
@end table
@end deftp



@deftp {Data Type} {enum pdf_text_filter_type_e}

Enumeration of supported filters in encoded text objects
(see function `pdf_text_filter').

@table @code
@item PDF_TEXT_FILTER_IDENTITY
Do not perform any transformation in the encoded text. It is a no-op.
@item PDF_TEXT_FILTER_LINE_ENDINGS
Normalize line endings.
@item PDF_TEXT_FILTER_UPPER_CASE
Makes all text upper case.
@item PDF_TEXT_FILTER_LOWER_CASE
Makes all text lower case.
@item PDF_TEXT_FILTER_TITLE_CASE
Makes all text title case.
@item PDF_TEXT_FILTER_REMOVE_AMP
Remove all single ampersands. This filter transform @code{&&} into
@code{&}.
@item PDF_TEXT_FILTER_NORM_WITH_FULL_WIDTH
Normalize with full width ASCII variants filter.
@item PDF_TEXT_FILTER_REMOVE_LINE_ENDINGS
Replace line endings with space characters.
@end table
@end deftp


@deftp {Data Type} pdf_text_t

A Unicode string, which must be considered as an opaque type. It contains the data
in UTF-32BE encoding, as well as any `ISO-639-1' country code and/or `ISO-3166-1 alpha-2'
language code applied. It also contains an internal list of word boundaries.

This data type must be initialized before being used, and destroyed afterwards.

@end deftp

@node Creating and Destroying Text
@subsection Creating and Destroying Text

@deftypefun pdf_text_t *pdf_text_new (pdf_error_t **@var{error})

Create a new empty text object.

@table @strong
@item Parameters
@table @var
@item error
A @code{pdf_error_t} to report errors or @code{NULL}.
@table @code
@item PDF_ENOMEM
Not enough memory to create the text object.
@item PDF_EBADCONTEXT
The global context of the text module was not initialized.
@end table
@end table
@item Returns
A newly created @code{pdf_text_t}, or @code{NULL} if any error happened.
@item Usage Example
@example
pdf_error_t *error = NULL;
pdf_text_t *text;

text = pdf_text_new (&error);
if (!text)
   @{
      /* Error! */
   @}
@end example
@end table
@end deftypefun


@deftypefun void pdf_text_destroy (pdf_text_t *@var{text})

Destroy a text object and its contents.

@table @strong
@item Parameters
@table @var
@item text
A properly created text object.
@end table
@item Usage Example
@example
pdf_text_t *text;

text = pdf_text_new (NULL);
if (text)
  @{
    pdf_text_destroy (text);
  @}
@end example
@end table
@end deftypefun

@deftypefun pdf_text_t *pdf_text_dup (const pdf_text_t *@var{text}, pdf_error_t **@var{error})

Duplicates a text object.

@table @strong
@item Parameters
@table @var
@item text
A properly created text object.
@item error
A @code{pdf_error_t} to report errors or @code{NULL}.
@table @code
@item PDF_ENOMEM
Not enough memory to create the text object.
@item PDF_EBADCONTEXT
The global context of the text module was not initialized.
@end table
@end table
@item Returns
A newly created @code{pdf_text_t}, or @code{NULL} if any error happened.
@item Usage Example
@example
pdf_text_t *text1;
pdf_text_t *text2;

text1 = pdf_text_new (NULL);
if (text1)
  @{
    text2 = pdf_text_dup (text1, NULL);
  @}
@end example
@end table
@end deftypefun

@deftypefun pdf_text_t *pdf_text_new_from_host (const pdf_char_t *@var{str}, const pdf_size_t @var{size}, const pdf_char_t *@var{enc}, pdf_error_t **@var{error})

Create a new text object and initialize it with a given host encoded string.

@table @strong
@item Parameters
@table @var
@item str
A string in some host encoding.
@item size
The length of @var{str}, in octets.
@item enc
The host encoding with which @var{str} is encoded.
@item error
A @code{pdf_error_t} to report errors or @code{NULL}.
@table @code
@item PDF_ENOMEM
Not enough memory to create the text object.
@item PDF_EBADCONTEXT
The global context of the text module was not initialized.
@item PDF_ETEXTENC
Invalid data in the input string (encoding error).
@end table
@end table
@item Returns
A newly created @code{pdf_text_t}, or @code{NULL} if any error happened.
@item Usage Example
@example
pdf_error_t *error = NULL;
pdf_text_t *text;
const pdf_char_t *he_string = "hello";
pdf_size_t  he_string_size;

/* Obtain host encoding and text... */

/* And create text object with those contents */
text = pdf_text_new_from_host (he_string,
                               strlen (he_string),
                               "usascii",
                               &error);
if (!text)
  @{
    /* Something bad happened */
  @}
@end example
@end table
@end deftypefun

@deftypefun pdf_text_t *pdf_text_new_from_pdf_string (const pdf_char_t *@var{str}, const pdf_size_t @var{size}, pdf_char_t **@var{remaining_str}, pdf_size_t *@var{remaining_length}, pdf_error_t **@var{error})

Create a new text object and initialize it with a given `PDF string'
text representation. This `PDF string' can be either encoded in UTF-16BE, with
BOM and optional Country/Language code information, or in PDF Doc Encoding.

The Country/Language code marker is treated as end-of-text marker, so that a text object
handles only a given pair of country and language codes. This function should be used
inside a loop, so that the input string of data is splitted in chunks if more than
one language/code is available in the text (only if PDF string is encoded in
UTF-16BE).

@table @strong
@item Parameters
@table @var
@item str
A valid `PDF string'
@item size
The length of @var{str} in octets
@item remaining_str
Returned pointer to the next chunk of data to process, if any.
@item remaining_length
Length of @var{remaining_str} in octets
@item error
A @code{pdf_error_t} to report errors or @code{NULL}.
@table @code
@item PDF_ENOMEM
Not enough memory to create the text object.
@item PDF_EBADCONTEXT
The global context of the text module was not initialized.
@item PDF_ETEXTENC
Invalid data in the input string (encoding error).
@end table
@end table
@item Returns
A newly created @code{pdf_text_t}, or @code{NULL} if any error happened.
@item Usage Example
@example
pdf_error_t *error = NULL;
pdf_text_t *text;
pdf_char_t *pdf_string;
pdf_size_t  pdf_string_size;
pdf_char_t *remaining_str;
pdf_size_t  remaining_size;

/* Obtain PDF string... */

/* And create text object with those contents */
remaining_str = pdf_string;
remaining_length = pdf_string_size;
do
  @{
    text = pdf_text_new_from_pdf_string (remaining_str,
                                         remaining_length,
                                         &remaining_str,
                                         &remaining_length,
                                         &error);
    if (text)
      @{
        /* Do something with the newly created text object */
      @}
  @}
while (!error && remaining_length > 0);
@end example
@end table
@end deftypefun

@deftypefun pdf_text_t *pdf_text_new_from_unicode (const pdf_char_t *@var{str}, pdf_size_t @var{size}, enum pdf_text_unicode_encoding_e @var{enc}, pdf_text_t **@var{error})

Create a new text object from a string of Unicode characters in a
given unicode encoding. The Unicode string can be given with or without BOM,
and there must not be any language/code information embedded in the string.

Note that for UTF-16BE strings two options are possible to create the
pdf_text_t object: treating it as a PDF string (so BOM is mandatory and
Language/Country code are optional) or treating it as a general Unicode
string (so BOM is optional and Language/Country code is not allowed).

@table @strong
@item Parameters
@table @var
@item str
A Unicode string.
@item size
The length of @var{str} in octets.
@item enc
The Unicode encoding used in @var{str}.
@item error
A @code{pdf_error_t} to report errors or @code{NULL}.
@table @code
@item PDF_ENOMEM
Not enough memory to create the text object.
@item PDF_EBADCONTEXT
The global context of the text module was not initialized.
@item PDF_ETEXTENC
Invalid data in the input string (encoding error).
@end table
@end table
@item Returns
A newly created @code{pdf_text_t}, or @code{NULL} if any error happened.
@item Usage Example
@example
pdf_error_t *error = NULL;
pdf_text_t *text;
pdf_char_t *unicode_string = "hello this is utf-8";

/* And create text object with those contents */
text = pdf_text_new_from_unicode (unicode_string,
                                  strlen (unicode_string),
                                  PDF_TEXT_UTF8,
                                  &error);
if (!error)
  @{
    /* Something bad happened */
  @}
@end example
@end table
@end deftypefun

@deftypefun pdf_text_t *pdf_text_new_from_u32 (const pdf_u32_t @var{number}, pdf_error_t **@var{error})

Create a new text variable containing the textual representation of a
given integer.

@table @strong
@item Parameters
@table @var
@item number
An unsigned 32 bit number.
@item error
A @code{pdf_error_t} to report errors or @code{NULL}.
@table @code
@item PDF_ENOMEM
Not enough memory to create the text object.
@item PDF_EBADCONTEXT
The global context of the text module was not initialized.
@end table
@end table
@item Returns
A newly created @code{pdf_text_t}, or @code{NULL} if any error happened.
@item Usage Example
@example
pdf_error_t *error = NULL;
pdf_text_t *text;

text = pdf_text_new_from_u32 (12345, &error);
if (!text)
  @{
    /* Something bad happened */
  @}
@end example
@end table
@end deftypefun

@node Managing Text Properties
@subsection Managing Text Properties

@deftypefun {const pdf_char_t *} pdf_text_get_country (const pdf_text_t *@var{text})

Return the `ISO-3166-1 alpha-2' country code associated with a text variable, as a
@code{NUL}-terminated string. The returned string should not be modified, as it is
managed by the `pdf_text_t' data type.

@table @strong
@item Parameters
@table @var
@item text
A text variable.
@end table
@item Returns
The code of the country associated with @var{text}.
@item Usage Example
@example
pdf_text_t *text;
pdf_char_t *code;

/* ...create and manipulate `text' */

code = pdf_text_get_country (text);
@end example
@end table
@end deftypefun

@deftypefun {const pdf_char_t *} pdf_text_get_language (const pdf_text_t *@var{text})

Return the `ISO-639-1' language code associated with a text variable, as a
@code{NUL}-terminated string. The returned string should not be modified, as it is
managed by the `pdf_text_t' data type.

@table @strong
@item Parameters
@table @var
@item text
A text variable.
@end table
@item Returns
The code of the language associated with @var{text}.
@item Usage Example
@example
pdf_text_t *text;
pdf_char_t *code;

/* ...create and manipulate `text' */

code = pdf_text_get_language (text);
@end example
@end table
@end deftypefun

@deftypefun void pdf_text_set_country (pdf_text_t *@var{text}, const pdf_char_t *@var{code})

Associate a text variable with a 2-digit `ISO-3166-1 alpha-2' country code.

@table @strong
@item Parameters
@table @var
@item text
A text variable.
@item code
A 2-digit country code.
@end table
@item Usage Example
@example
pdf_text_t *text;

/* ...create and manipulate `text' */

pdf_text_set_country (text, "GB");
@end example
@end table
@end deftypefun

@deftypefun void pdf_text_set_language (pdf_text_t *@var{text}, const pdf_char_t *@var{code})

Associate a text variable with a 2-digit `ISO-639-1' language code.

@table @strong
@item Parameters
@table @var
@item text
A text variable.
@item code
A 2-digit language code.
@end table
@item Usage Example
@example
pdf_text_t *text;

/* ...create and manipulate `text' */

pdf_text_set_language (text, "en");
@end example
@end table
@end deftypefun

@deftypefun pdf_bool_t pdf_text_empty_p (const pdf_text_t *@var{text})

Determine if a given text variable is empty (contains no text).

@table @strong
@item Parameters
@table @var
@item text
A text variable.
@end table
@item Returns
@code{PDF_TRUE} if @var{text} is empty, @code{PDF_FALSE} otherwise.
@item Usage Example
@example
pdf_text_t *text;

/* ...initialize and manipulate `text'... */

if (pdf_text_empty_p (text))
  @{
    /* `text' contains no text */
  @}
@end example
@end table
@end deftypefun


@node Managing Text Contents
@subsection Managing Text Contents

@deftypefun pdf_char_t *pdf_text_get_host (const pdf_text_t *@var{text}, const pdf_char_t *@var{enc}, pdf_size_t *@var{length}, pdf_error_t **@var{error})

Get the contents of a text variable encoded in a given host encoding.

Note that the host encoding may be multibyte and thus the output string may
contain NUL octets.

@table @strong
@item Parameters
@table @var
@item text
A text variable.
@item enc
A host encoding supported by the host.
@item length
Output length, in octets, of the returned string.
@item error
A @code{pdf_error_t} to report errors or @code{NULL}.
@table @code
@item PDF_ENOMEM
Not enough memory to create the output string.
@item PDF_ETEXTENC
Error when trying to encode the text contents in the requested encoding.
@end table
@end table
@item Returns
A newly allocated string encoded in the given @var{enc} host encoding.
@item Usage Example
@example
pdf_error_t *error = NULL;
pdf_char_t *str;
pdf_size_t str_size;
pdf_text_t *text;

/* ...initialize and manipulate `text'... */

str = pdf_text_get_host (text,
                         "us-ascii",
                         &str_size,
                         &error);
if (str)
  @{
    /* Do something with the string */
    pdf_dealloc (str);
  @}
@end example
@end table
@end deftypefun

@deftypefun pdf_char_t *pdf_text_get_pdfdocenc (const pdf_text_t *@var{text}, pdf_error_t **@var{error})

Get the contents of a text variable encoded in PDF Doc Encoding,
and @code{NUL}-terminated.

@table @strong
@item Parameters
@table @var
@item text
A text variable.
@item error
A @code{pdf_error_t} to report errors or @code{NULL}.
@table @code
@item PDF_ENOMEM
Not enough memory to create the output string.
@item PDF_ETEXTENC
Error when trying to encode the text contents in PDF Doc Encoding.
@end table
@end table
@item Returns
A newly allocated @code{NUL}-terminated string encoded in PDF Doc Encoding.
The string must be deallocated by the caller.
@item Usage Example
@example
pdf_error_t *error = NULL;
pdf_text_t *text;
pdf_char_t *str;

/* ...initialize and manipulate `text'... */

str = pdf_text_get_pdfdocenc (text, &error);
if (str)
  @{
    /* Do something with the string */
    pdf_dealloc (str);
  @}
@end example
@end table
@end deftypefun


@deftypefun pdf_char_t *pdf_text_get_unicode (const pdf_text_t *@var{text}, enum pdf_text_unicode_encoding_e @var{enc}, pdf_u32_t @var{options}, pdf_size_t *@var{length}, pdf_error_t **@var{error})

Get the contents of a text variable encoded in the specified
Unicode encoding. Additional options can be set in the request.

Note that the output string may contain NUL octets if the requested encoding is
not UTF-8.

@table @strong
@item Parameters
@table @var
@item text
A text variable.
@item enc
A given Unicode encoding, specifying requested endianness if applicable.
@item options
Mask of additional option flags, set as: OPTION_1 | OPTION_2 | OPTION_3.
(see @code{pdf_text_unicode_options_e} data type)
@item length
Output length, in octets, of the returned string.
@item error
A @code{pdf_error_t} to report errors or @code{NULL}.
@table @code
@item PDF_ENOMEM
Not enough memory to create the output string.
@item PDF_ETEXTENC
Error when trying to encode the text contents in the requested encoding.
@end table
@end table
@item Returns
A newly allocated string encoded in the given @var{enc} Unicode encoding.
The string must be deallocated by the caller.
@item Usage Example
@example
pdf_error_t *error = NULL;
pdf_text_t *text;
pdf_char_t *str;
pdf_size_t str_length;

/* ...initialize and manipulate `text'... */

str = pdf_text_get_unicode (text,
                            PDF_TEXT_UTF16_BE,
                            (PDF_TEXT_UNICODE_WITH_BOM | PDF_TEXT_UTF16BE_WITH_LANGCODE),
                            &str_length,
                            &error);
if (str)
  @{
    /* Do something with the string */
    pdf_dealloc (str);
  @}
@end example
@end table
@end deftypefun


@deftypefun {pdf_char_t *} pdf_text_get_hex (const pdf_text_t *@var{text}, pdf_char_t @var{delimiter}, pdf_error_t **@var{error})

Get the contents of a text variable as a string which includes the hexadecimal representation of each byte stored in the internal string of the text variable, separated by the character given in @var{delimiter} (usually ':').

For debugging purposes only.

@table @strong
@item Parameters
@table @var
@item text
A text variable
@item delimiter
A single ASCII char used as delimiter
@item error
A @code{pdf_error_t} to report errors or @code{NULL}.
@table @code
@item PDF_ENOMEM
Not enough memory to create the output string.
@end table
@end table
@item Returns
A newly allocated @code{NUL}-terminated string with the contents of the text object in hexadecimal representation. The string must be deallocated by the caller.
@item Usage Example
@example
pdf_text_t *text;
pdf_char_t *str;

/* ...initialize and manipulate `text'... */

str = pdf_text_get_hex (text, ':', NULL);
if (str)
  @{
    PDF_DEBUG_BASE("Internal representation of the string is: '%s'", str);
    pdf_dealloc (str);
  @}
@end example
@end table
@end deftypefun

@deftypefun pdf_bool_t pdf_text_set_host (pdf_text_t *@var{text}, const pdf_char_t *@var{str}, pdf_size_t @var{size}, const pdf_char_t *@var{enc}, pdf_error_t **@var{error})

Set a string encoded with some host encoding as the value of a text variable.

@table @strong
@item Parameters
@table @var
@item text
A text variable.
@item str
A string encoded with some host encoding.
@item enc
The length of @var{str}, in octets.
@item enc
The host encoding used to encode @var{str}.
@item error
A @code{pdf_error_t} to report errors or @code{NULL}.
@table @code
@item PDF_ENOMEM
Not enough memory to create the output string.
@item PDF_ETEXTENC
Invalid data in the input string (encoding error).
@end table
@end table
@item Returns
@code{PDF_TRUE} if the operation succeeded, @code{PDF_FALSE} otherwise.
@item Usage Example
@example
pdf_error_t *error = NULL;
pdf_char_t *str = "string in ascii-7, a.k.a. us-ascii";
pdf_text_t *text;

/* ...initialize and manipulate `text' */

if (!pdf_text_set_host (text,
                        str,
                        strlen (str),
                        "us-ascii",
                        &error))
  @{
    /* An error happened */
  @}
@end example
@end table
@end deftypefun

@deftypefun pdf_bool_t pdf_text_set_pdfdocenc (pdf_text_t *@var{text}, const pdf_char_t *@var{str}, pdf_error_t **@var{error})

Set a PDF Doc Encoding encoded string as the value of a text variable.

@table @strong
@item Parameters
@table @var
@item text
A text variable.
@item str
A string encoded with PDF Doc Encoding, @code{NUL} terminated.
@item error
A @code{pdf_error_t} to report errors or @code{NULL}.
@table @code
@item PDF_ENOMEM
Not enough memory to create the output string.
@item PDF_ETEXTENC
Invalid data in the input string (encoding error).
@end table
@end table
@item Returns
@code{PDF_TRUE} if the operation succeeded, @code{PDF_FALSE} otherwise.
@item Usage Example
@example
pdf_error_t *error = NULL;
pdf_char_t *str = "PDF doc encoded string!";
pdf_text_t *text;

/* ...initialize and manipulate `text' and `str'... */
if (!pdf_text_set_pdfdocenc (text, str, &error))
  @{
    /* An error happened */
  @}
@end example
@end table
@end deftypefun

@deftypefun pdf_bool_t pdf_text_set_unicode (pdf_text_t *@var{text}, const pdf_char_t *@var{str}, pdf_size_t @var{size}, enum pdf_text_unicode_encoding_e @var{enc}, pdf_error_t **@var{error})

Set a Unicode encoded string as the value of a text variable.

@table @strong
@item Parameters
@table @var
@item text
A text variable.
@item str
A Unicode string without country/language data embedded.
@item size
The length of @var{str}, in octets.
@item enc
The Unicode encoding used in @var{str}.
@item error
A @code{pdf_error_t} to report errors or @code{NULL}.
@table @code
@item PDF_ENOMEM
Not enough memory to create the output string.
@item PDF_ETEXTENC
Invalid data in the input string (encoding error).
@end table
@end table
@item Returns
@code{PDF_TRUE} if the operation succeeded, @code{PDF_FALSE} otherwise.
@item Usage Example
@example
pdf_error_t *error = NULL;
pdf_text_t *text;

/* ...initialize  `text'... */

if (!pdf_text_set_unicode (text,
                           "\x00\x00\x00\x20\x00\x00\x00\x69",
                           8,
                           PDF_TEXT_UTF32_BE,
                           &error))
  @{
    /* An error happened */
  @}
@end example
@end table
@end deftypefun

@deftypefun pdf_bool_t pdf_text_concat (pdf_text_t *@var{text1}, const pdf_text_t *@var{text2}, const pdf_bool_t @var{override_langinfo}, pdf_error_t *@var{error})

Concatenate the contents of two text variables (@var{text1} first,
then @var{text2}) and store the result in @var{text1}.

Warning! If @var{override_langinfo} is not set and different country/language
codes are found within the text variables an error will be returned
(concatenation not possible). If @var{override_langinfo} is set, the country
and language information is not checked, and the one in @var{text1} is left
untouched.

@table @strong
@item Parameters
@table @var
@item text1
The first text variable to concatenate. The contents of this variable
are modified with the output of the concatenation.
@item text2
The second text variable to concatenate. The contents of this variable
are left unchanged.
@item override_langinfo
Flag to indicate if the language and country information must be checked
before performing the concatenation.
@item error
A @code{pdf_error_t} to report errors or @code{NULL}.
@table @code
@item PDF_ENOMEM
Not enough memory to create the output string.
@item PDF_ETEXTENC
Failed language/country information check.
@end table
@end table
@item Returns
@code{PDF_TRUE} if the operation succeeded, @code{PDF_FALSE} otherwise.
@item Usage Example
@example
pdf_error_t *error = NULL;
pdf_text_t *text1;
pdf_text_t *text2;

/* ...initialize `text1' and `text2'... */

if (!pdf_text_concat (text1,
                      text2,
                      PDF_FALSE,
                      &error))
  @{
    /* Manage the error */
  @}
@end example
@end table
@end deftypefun


@deftypefun pdf_bool_t pdf_text_concat_ascii (pdf_text_t *@var{text1}, const pdf_char_t * @var{ascii_str}, pdf_error_t **@var{error})

Concatenate the contents of text variable @var{text1} with ASCII string @var{ascii_str},
and store the result in @var{text1}.

@table @strong
@item Parameters
@table @var
@item text1
The first text variable to concatenate. The contents of this variable
are modified with the output of the concatenation.
@item ascii_str
The ascii string to concatenate. The contents of this variable
are left unchanged.
@item error
A @code{pdf_error_t} to report errors or @code{NULL}.
@table @code
@item PDF_ENOMEM
Not enough memory to create the output string.
@item PDF_ETEXTENC
Input string @var{ascii_str} is not ASCII-7.
@end table
@end table
@item Returns
@code{PDF_TRUE} if the operation succeeded, @code{PDF_FALSE} otherwise.
@item Usage Example
@example
pdf_error_t *error = NULL;
pdf_text_t *text1;

/* ...initialize `text1'... */

if (!pdf_text_concat_ascii (text1, "some ascii to append", &error))
  @{
    /* Manage the error */
  @}
@end example
@end table
@end deftypefun


@deftypefun pdf_bool_t pdf_text_replace (pdf_text_t *@var{text}, const pdf_text_t *@var{new_pattern}, const pdf_text_t *@var{old_pattern}, pdf_error_t **@var{error})

Replace a fixed pattern in the content of a given text variable.

@table @strong
@item Parameters
@table @var
@item text
A text variable.
@item new_pattern
The replacement text.
@item old_pattern
The text to be replaced. Any occurrence of this text is replaced with @var{new_pattern}.
@item error
A @code{pdf_error_t} to report errors or @code{NULL}.
@table @code
@item PDF_ENOMEM
Not enough memory to handle the replace.
@item PDF_ETEXTENC
Invalid input pattern.
@end table
@end table
@item Returns
@code{PDF_TRUE} if the operation succeeded, @code{PDF_FALSE} otherwise.
@item Usage Example
@example
pdf_error_t *error = NULL;
pdf_text_t *text;
pdf_text_t *new_pattern;
pdf_text_t *old_pattern;

/* ...initialize `text', `new_pattern' and `old_pattern'... */

if (!pdf_text_replace (text,
                       new_pattern,
                       old_pattern,
                       &error))
  @{
    /* Manage the error */
  @}
@end example
@end table
@end deftypefun

@deftypefun pdf_bool_t pdf_text_replace_ascii (pdf_text_t *@var{text}, const pdf_char_t *@var{new_pattern}, const pdf_char_t *@var{old_pattern}, pdf_error_t **@var{error})

Replace a fixed ASCII pattern in the content of a given text variable.

@table @strong
@item Parameters
@table @var
@item text
A text variable.
@item new_pattern
The replacement ASCII string.
@item old_pattern
The text to be replaced. Any occurrence of this text is replaced with @var{new_pattern}.
@item error
A @code{pdf_error_t} to report errors or @code{NULL}.
@table @code
@item PDF_ENOMEM
Not enough memory to handle the replace.
@item PDF_ETEXTENC
Invalid input pattern.
@end table
@end table
@item Returns
@code{PDF_TRUE} if the operation succeeded, @code{PDF_FALSE} otherwise.
@item Usage Example
@example
pdf_text_t *text;
const pdf_char_t *new_pattern = "GNU/Linux";
const pdf_char_t *old_pattern = "Linux";

/* ...initialize `text'... */

if (!pdf_text_replace_ascii (text,
                             new_pattern,
                             old_pattern,
                             &error))
  @{
    /* Manage the error */
  @}
@end example
@end table
@end deftypefun

@deftypefun pdf_bool_t pdf_text_filter (pdf_text_t *@var{text}, const pdf_u32_t @var{filter}, pdf_error_t **@var{error})

Filter the contents of a text variable.

@table @strong
@item Parameters
@table @var
@item text
A text variable.
@item filter
Mask of flags specifying what filters to be run, as: FILTER_1 | FILTER_2 | FILTER_3.
(see @code{pdf_text_filter_type_e} data type).
Warning!! At most one case-related filter can be applied at a time.
@item error
A @code{pdf_error_t} to report errors or @code{NULL}.
@table @code
@item PDF_ENOMEM
Not enough memory to handle the filter operation.
@item PDF_ETEXTENC
Invalid input filter setup.
@end table
@end table
@item Returns
@code{PDF_TRUE} if the operation succeeded, @code{PDF_FALSE} otherwise.
@item Usage Example
@example
pdf_error_t *error = NULL;
pdf_text_t *text;

/* ...initialize `text'... */

if (!pdf_text_filter (text,
                      (PDF_TEXT_FILTER_LOWER_CASE | PDF_TEXT_FILTER_REMOVE_AMP)),
                      &error)
  @{
    /* Manage error */
  @}
@end example
@end table
@end deftypefun


@node Comparing Text Variables
@subsection Comparing Text Variables

@deftypefun pdf_i32_t pdf_text_cmp (const pdf_text_t *@var{text1}, const pdf_text_t *@var{text2}, const pdf_bool_t @var{case_sensitive}, pdf_error_t **@var{error})

Compare the contents of two text variables.

@table @strong
@item Parameters
@table @var
@item text1
A text variable.
@item text2
A text variable.
@item case_sensitive
A boolean value indicating if the comparison is case-sensitive.
@item error
A @code{pdf_error_t} to report errors or @code{NULL}.
@table @code
@item PDF_ENOMEM
Not enough memory to handle the filter operation.
@item PDF_ETEXTENC
Internal error when doing case-insensitive comparison.
@end table
@end table
@item Returns
An integer:
@table @code
@item -1
If text1 < text2
@item 0
If text1 = text2
@item +1
If text1 > text2
@end table
@item Usage Example
@example
pdf_error_t *error = NULL;
pdf_text_t *text1;
pdf_text_t *text2;
pdf_i32_t cmp;

/* ...initialize `text1' and `text2'... */

cmp = pdf_text_cmp (text1, text2, PDF_FALSE, &error);
if (!error)
  @{
    switch (cmp)
    @{
    case -1:
      @{
        /* XXX */
        break;
      @}
    case 0:
      @{
         /* XXX */
         break;
      @}
    case +1:
      @{
         /* XXX */
         break;
      @}
    @}
  @}
@end example
@end table
@end deftypefun

@node Managing Host Encodings
@subsection Managing Host Encodings

@deftypefun const pdf_char_t *pdf_text_get_host_encoding (void)

Return the host encoding configured by the user in the locale.

@table @strong
@item Parameters
None
@item Returns
A string with the host encoding configured in the user's locale.
The returned string shouldn't be modified by the caller.
@item Usage Example
@example

print ("Current host encoding is: '%s'\n",
       pdf_text_get_host_encoding ());

@end example
@end table
@end deftypefun

@deftypefun pdf_bool_t pdf_text_check_host_encoding (const pdf_char_t *@var{encoding_name}, pdf_error_t **@var{error})

Check if a given encoding is available in the system.

@table @strong
@item Parameters
@table @var
@item encoding_name
Name of the encoding to check for.
@item error
A @code{pdf_error_t} to report errors or @code{NULL}.
@table @code
@item PDF_ENOMEM
Not enough memory to check if encoding is available.
@end table
@end table
@item Returns
@code{PDF_TRUE} if @var{encoding_name} is available in the system, @code{PDF_FALSE} otherwise.
@item Usage Example
@example
pdf_error_t *error = NULL;

if (!pdf_text_check_host_encoding ("ascii-us", &error))
  @{
    if (!error)
    @{
      /* Host encoding not available */
    @}
    else
    @{
      /* An error happened when trying to check
       * if host encoding available */
    @}
  @}
else
  @{
    /* Host encoding is available */
  @}
@end example
@end table
@end deftypefun


@deftypefun const pdf_char_t *pdf_text_get_best_encoding (const pdf_text_t *@var{text}, const pdf_char_t *@var{preferred_encoding})

Return the best available host encoding to encode the contents of a
given text variable. A specified preferred encoding is selected if
there is no clear best encoding.

The ``best'' encoding is an encoding able to encode the bigger number
of characters of the unicode content of the given text variable, so the
function will check for Unicode encodings supported in the system.
@table @strong
@item Parameters
@table @var
@item text
A text variable.
@item preferred_encoding
A text encoding supported by the host.
@end table
@item Returns
The best host encoding available to encode the contents of @var{text}.
@item Usage Example
@example
pdf_text_t *text;
const pdf_char_t *best;

/* ...create and manipulate `text'... */

best = pdf_text_get_best_encoding (text, "UTF-8");

@end example
@end table
@end deftypefun


@node Time Management
@section Time Management

@menu
* Time Related Data Types::
* Time Creation and Destruction::
* Managing Time Values::
* Getting Time Intervals::
* Time Comparison::
* Time Printing and Parsing::
* Getting the Current Time::
* Calendar Spans Management::
* Platform-specific functions::
@end menu

@node Time Related Data Types
@subsection Time Related Data Types

@deftp {Data Type} pdf_time_t
A variable of type @code{pdf_time_t} contains information about a
particular date and time, including GMT offset information.

The size of the @code{pdf_time_t} variable is known, and therefore these variables
can be created and initialized in stack.
@end deftp

@deftp {Data Type} {struct pdf_time_cal_s}
This structure holds information about a specific time represented in
calendar items: years, months, days, day of week, hours, minutes,
seconds and the relative offset with GMT.

The calendar can be represented in both UTC and local time. If the given GMT
offset is zero, the calendar fields come in UTC; if not zero, the calendar
fields come in a given local time.

@table @code
@item pdf_u16_t year
A year number.
@item pdf_u8_t month
A month number. The valid range is @code{1..12}.
@item pdf_u8_t day
A day number. The valid range is @code{1..31}.
@item pdf_u8_t dow
Day of the week. The valid range is @code{1..7} (Monday to Sunday).
@item pdf_u8_t hour
An hour. The valid range is @code{0..23}.
@item pdf_u8_t minute
A minute. The valid range is @code{0..59}.
@item pdf_u8_t sec
A second. The valid range is @code{0..59}.
@item pdf_i32_t gmt_offset
A GMT offset, in seconds west of GMT.
@end table
@end deftp

@deftp {Data Type} {struct pdf_time_cal_span_s}
This structure holds information about a time span represented in
calendar items: years, months, days, hours, minutes and seconds.

@table @code
@item pdf_bool_t sign
@item pdf_u16_t years
@item pdf_u16_t months
@item pdf_u32_t days
@item pdf_u32_t hours
@item pdf_u32_t minutes
@item pdf_u32_t seconds
@end table
@end deftp

@deftp {Data Type} {enum pdf_time_string_format_e}
Enumeration containing the several supported formats used to
convert a time to a string representation or to parse a time from a
string representation.

@table @code
@item PDF_TIME_STRING_FORMAT_PDF
PDF date strings.
@item PDF_TIME_STRING_FORMAT_ISO_8601
ISO 8601 date and time strings.
@item PDF_TIME_STRING_FORMAT_UTC_ASN1
UTC ASN1 date.
@item PDF_TIME_STRING_FORMAT_GENERALIZED_ASN1
Generalized ASN1 date.
@end table
@end deftp

@deftp {Data Type} {enum pdf_time_string_options_e}
Enumeration containing the options available when converting times to
strings or strings to times.

@table @code
@item PDF_TIME_STRING_NO_OPTION
No option.
@item PDF_TIME_STRING_TRAILING_APOSTROPHE
PDF-formatted time strings may (PDF reference 1.7) or may not (ISO 32000) include a trailing apostrophe.
@end table
@end deftp

@node Time Creation and Destruction
@subsection Time Creation and Destruction

@deftypefun pdf_time_t *pdf_time_new (pdf_error_t *@var{error})
Creates a heap-allocated time object and sets it to the Epoch: Jan 1 1970-01-01 00:00:00 UTC

@table @strong
@item Parameters
@table @var
@item error
A @code{pdf_error_t} to report errors or @code{NULL}.
@table @code
@item PDF_ENOMEM
Not enough memory to create the time object.
@item PDF_EBADCONTEXT
The global context of the time module was not initialized.
@end table
@end table
@item Returns
A newly created @code{pdf_time_t}, or @code{NULL} if any error happened.
@item Usage Example
@example
pdf_error_t *error = NULL;
pdf_time_t *mytime;

mytime = pdf_time_new (&error);
if (!mytime)
   @{
      /* Error! */
   @}
@end example
@end table
@end deftypefun


@deftypefun pdf_time_t *pdf_time_dup (const pdf_time_t *@var{time_var}, pdf_error_t **@var{error})
Duplicates in heap a time variable.

@table @strong
@item Parameters

@table @var
@item time_var
A time variable.
@item error
A @code{pdf_error_t} to report errors or @code{NULL}.
@table @code
@item PDF_ENOMEM
Not enough memory to create the text object.
@item PDF_EBADCONTEXT
The global context of the text module was not initialized.
@end table
@end table
@item Returns
A newly heap-allocated @code{pdf_time_t}, or @code{NULL} if any error happened.
@item Usage example
@example
pdf_time_t *orig;
pdf_time_t *new_time;

orig = pdf_time_new (NULL);
if (orig)
  @{
      new_time = pdf_time_dup (orig, NULL);
      if (!new_time)
         @{
           /* Error */
         @}
   @}
@end example
@end table
@end deftypefun


@deftypefun void pdf_time_destroy (pdf_time_t *@var{time_var})
Destroy the heap-allocated @var{time_var} and free all used memory. @var{time_var} should have been previously allocated with @code{pdf_time_new()} or @code{pdf_time_dup()}.

@table @strong
@item Parameters
@table @var
@item time_var
The heap-allocated time variable to be destroyed.
@end table
@item Usage example
@example
pdf_time_t *mytime;

mytime = pdf_time_new (NULL);
if (mytime)
   pdf_time_destroy (mytime);
@end example
@end table
@end deftypefun


@deftypefun void pdf_time_init (pdf_time_t *@var{time_var})
Initializes a preallocated time object and sets it to the Epoch: Jan 1 1970-01-01 00:00:00 UTC

Use this method to initialize time objects in the stack.
@table @strong
@item Parameters
@table @var
@item time_var
The time object to be initialized.
@end table
@item Usage Example
@example
pdf_time_t mytime;

pdf_time_init (&mytime);
@end example
@end table
@end deftypefun


@deftypefun void pdf_time_init_dup (pdf_time_t *@var{time_var}, const pdf_time_t *@var{time_var_orig}, pdf_error_t **@var{error})
Initializes the preallocated @var{time_var} object and sets it to the same time as @var{time_var_orig}.

Use this method to initialize time objects in the stack.
@table @strong
@item Parameters

@table @var
@item time_var
A time variable to initialize.
@item time_var_orig
A time variable.
@end table
@item Usage example
@example
pdf_time_t orig;
pdf_time_t new_time;

pdf_time_init (&orig);
pdf_time_init_dup (&new_time, &orig);
@end example
@end table
@end deftypefun


@deftypefun void pdf_time_deinit (pdf_time_t *@var{time_var})
Deinitializes @var{time_var}, which should have been previously initialized with @code{pdf_time_init()} or @code{pdf_time_init_dup()}.

@table @strong
@item Parameters
@table @var
@item time_var
The time variable to be deinitialized.
@end table
@item Usage example
@example
pdf_time_t mytime;

pdf_time_init (&mytime);
pdf_time_deinit (&mytime);
@end example
@end table
@end deftypefun


@node Managing Time Values
@subsection Managing Time Values

@deftypefun void pdf_time_copy (const pdf_time_t *@var{copy}, pdf_time_t *@var{orig})
Copies @var{orig} into @var{copy}.

@table @strong
@item Parameters
@table @var
@item copy
The time to receive the data from @var{orig}. Should be a properly
created time variable.

Note that any previous data in @var{copy} is destroyed.
@item orig
The time whose data is to be copied. Should be a properly created time variable.
@end table
@item Usage example
@example
pdf_time_t orig;
pdf_time_t copy;

pdf_time_init (&orig);
pdf_time_init (&copy);

pdf_time_copy (&copy, &orig);
@end example
@end table
@end deftypefun

@deftypefun void pdf_time_clear (pdf_time_t *@var{time_var})
Reset @var{time_var} to the initialized state. After this call
@var{time_var} will contain the same date as if returned by
@code{pdf_time_new()} or @code{pdf_time_init()}.

@table @strong
@item Parameters
@table @var
@item time_var
The time variable to clear. Should be a properly create time variable.
@end table
@item Usage example
@example
pdf_time_t mytime;

pdf_time_init (&mytime);

/* ...manipulate `mytime'... */

pdf_time_clear (&mytime);
@end example
@end table
@end deftypefun


@deftypefun void pdf_time_set_utc (pdf_time_t *@var{time_var}, pdf_i64_t @var{utc_seconds})
This function will initialize @var{time_var} to the given Unix time (seconds since January 1st 1970) in UTC timescale.

@table @strong
@item Parameters
@table @var
@item time_var
The time variable to set. Should be a properly create time variable.
@item utc_seconds
Seconds since January 1st 1970.
@end table
@item Usage example
@example
pdf_time_t mytime;

pdf_time_init (&mytime);
pdf_time_set_utc (&mytime, 1234567890);
pdf_time_deinit (&mytime);
@end example
@end table
@end deftypefun

@deftypefun void pdf_time_set_local (pdf_time_t *@var{time_var}, pdf_i64_t @var{local_seconds}, pdf_i32_t @var{local_gmt_offset})
This function will initialize @var{time_var} to the given Unix time (seconds since January 1st 1970) in a local timescale represented by the GMT offset given in @var{local_gmt_offset}.

@table @strong
@item Parameters
@table @var
@item time_var
The time variable to set. Should be a properly create time variable.
@item local_seconds
Seconds since January 1st 1970.
@item local_gmt_offset
Seconds west of GMT.
@end table
@item Usage example
@example
pdf_time_t mytime;

pdf_time_init (&mytime);
pdf_time_set_local (&mytime, 1234567890, -3600);
pdf_time_deinit (&mytime);
@end example
@end table
@end deftypefun


@deftypefun void pdf_time_add_cal_span (pdf_time_t *@var{time_var}, const struct pdf_time_cal_span_s *@var{p_cal_span})
Add the time span represented by the calendar span under the address in @var{p_cal_span} to @var{time_var}.

@table @strong
@item Parameters

@table @var
@item time_var
A properly created time variable.
@item p_cal_span
A pointer to a calendar span with valid values.
@end table
@item Usage example
@example
pdf_time_t mytime;
struct pdf_time_cal_span_s cal_span = @{ 0 @};

/* Initialized to Jan 1 1970-01-01 00:00:00 */
pdf_time_init (&mytime);

cal_span.year = 30;
cal_span.month = 7;
cal_span.day = 20;
cal_span.hour = 21;

pdf_time_add_cal_span (&mytime, &cal_span);

/* `time' now contains Aug 21 2000-08-21 21:00:00 */

pdf_time_deinit (&time);
@end example
@end table
@end deftypefun

@deftypefun void pdf_time_sub_cal_span (pdf_time_t *@var{time_var}, const struct pdf_time_cal_span_s *@var{p_cal_span})
Subtract the time span represented by the calendar span under the address in @var{p_cal_span} to @var{time_var}.

@table @strong
@item Parameters

@table @var
@item time_var
A properly created time variable.
@item p_cal_span
A pointer to a calendar span with valid values.
@end table
@item Usage example
@example
pdf_time_t mytime;
struct pdf_time_cal_span_s cal_span = @{ 0 @};

/* Initialized to Jan 1 1970-01-01 00:00:00 */
pdf_time_init (&mytime);

cal_span.year = 30;
cal_span.month = 7;
cal_span.day = 20;
cal_span.hour = 21;

pdf_time_add_cal_span (&mytime, &cal_span);

/* `time' now contains Aug 21 2000-08-21 21:00:00 */

pdf_time_sub_cal_span (&mytime, &cal_span);

/* `time' now contains Jan 1 1970-01-01 00:00:00 */

pdf_time_deinit (&mytime);
@end example
@end table
@end deftypefun


@deftypefun void pdf_time_add_span (pdf_time_t *@var{time_var}, pdf_i32_t @var{time_span})
Add @var{time_span} seconds to @var{time_var}.

@table @strong
@item Parameters

@table @var
@item time_var
A properly created time variable.
@item time_span
Number of seconds to add to the time variable.
@end table
@item Usage example
@example
pdf_time_t *mytime;

mytime = pdf_time_new (NULL);

pdf_time_add_span (mytime, 86400);

pdf_time_destroy (mytime);
@end example
@end table
@end deftypefun

@deftypefun void pdf_time_sub_span (pdf_time_t *@var{time_var}, pdf_i32_t @var{time_span})
Subtract @var{time_span} seconds from @var{time_var}.

@table @strong
@item Parameters

@table @var
@item time_var
A properly created time variable.
@item time_span
Number of seconds to substract from the time variable.
@end table
@item Usage example
@example
pdf_time_t mytime;
pdf_time_span_t myspan;

mytime = pdf_time_new (NULL);

pdf_time_add_span (mytime, 86400);
pdf_time_sub_span (mytime, 86400);

pdf_time_destroy (mytime);
@end example
@end table
@end deftypefun

@deftypefun void pdf_time_get_local_cal (const pdf_time_t *@var{time_var}, struct pdf_time_cal_s *@var{local_cal})
Fill @var{local_cal} with the local calendar time of @var{time_var}.

@table @strong
@item Parameters

@table @var
@item time_var
A properly created time variable.
@item local_cal
A pointer to the time calendar structure that will hold the local time
of @var{time_var}.
@end table

@item Usage example
@example
pdf_time_t mytime;
struct pdf_time_cal_s cal;

pdf_time_init (&mytime);
pdf_time_get_local_cal (&mytime, &cal);
pdf_time_deinit (&mytime);
@end example
@end table
@end deftypefun

@deftypefun void pdf_time_get_utc_cal (const pdf_time_t *@var{time_var}, struct pdf_time_cal_s *@var{utc_cal})
Get the UTC calendar time of a given time variable.

@table @strong
@item Parameters

@table @var
@item time_var
A properly created time variable.
@item p_cal_time
A pointer to the calendar time structure that will hold the UTC time of @var{time_var}.
@end table
@item Usage example
@example
pdf_time_t mytime;
sruct pdf_time_cal_s cal_time;

pdf_time_init (&mytime);

pdf_time_get_utc_cal (&mytime, &cal_time);

pdf_time_deinit (&mytime);
@end example
@end table
@end deftypefun

@deftypefun void pdf_time_set_from_cal (pdf_time_t *@var{time_var}, const struct pdf_time_cal_s *@var{cal})
Set the value of a time variable from a given calendar time.

@table @strong
@item Parameters

@table @var
@item time_var
A properly created time variable.
@item cal
A pointer to a calendar time structure.
@end table
@item Usage example
@example
pdf_time_t *mytime;
struct pdf_time_cal_s mycaltime;

mytime = pdf_time_new (NULL);

mycaltime.year = 2000;
mycaltime.month = 8;
mycaltime.day = 10;
mycaltime.hour = 0;
mycaltime.minute = 0;
mycaltime.sec = 0;
mycaltime.gmt_offset = 1;

/* This field is ignored by `pdf_time_from_cal' */
mycaltime.dow = 0;

pdf_time_set_from_cal (&mytime, &mycaltime);

pdf_time_destroy (mytime);
@end example
@end table
@end deftypefun

@deftypefun void pdf_time_set_local_offset (pdf_time_t *@var{time_var})
Set the local time offset of @var{time_var} to the one used by the
operating system.

@table @strong
@item Parameters
@table @var
@item time
A properly created time variable.
@end table
@item Usage example
@example
pdf_time_t mytime;

pdf_time_init (&mytime);

pdf_time_set_utc (&mytime, 1234567890);
pdf_time_set_local_offset (&mytime);

pdf_time_deinit (&mytime);
@end example
@end table
@end deftypefun

@node Getting Time Intervals
@subsection Getting Time Intervals

@deftypefun void pdf_time_diff_cal (const pdf_time_t *@var{time1}, const pdf_time_t *@var{time2}, struct pdf_time_cal_span_s *@var{p_cal_span})
Calculate the time span that goes from @var{time1} to @var{time2} and
store it in @var{p_cal_span}.

Note that the highest possible distribution inside @var{p_cal_span} is used.
@table @strong
@item Parameters

@table @var
@item time1
The beginning of the time interval (inclusive).
@item time2
The end of the time interval (exclusive).
@item p_cal_span
Pointer to the calendar time span structure that will hold the time span that
goes between @var{time1} and @var{time2}.
@end table
@item Usage example
@example
pdf_time_t time1;
pdf_time_t time2;
struct pdf_time_cal_span_s diff;

pdf_time_init (&time1);
pdf_time_init (&time2);

pdf_time_set_utc (&time1, 1234567890);
pdf_time_set_utc (&time2, 1300000000);

pdf_time_diff (&time1, &time2, &diff);
printf ("Time between times is: %d-%d-%d %d:%d:%d\n",
        diff.years,
        diff.months,
        diff.days,
        diff.hours,
        diff.minutes,
        diff.seconds);

pdf_time_deinit (&time1);
pdf_time_deinit (&time2);
@end example
@end table
@end deftypefun

@deftypefun pdf_i64_t pdf_time_diff (const pdf_time_t *@var{time1}, const pdf_time_t *@var{time2})
Calculate the time span between two dates.

@table @strong
@item Parameters

@table @var
@item time1
The beginning time. Should be a properly created time.
@item time2
The ending time. Should be a properly created time.
@end table

@item Returns
The number of seconds betweeen @var{time1} and @var{time2}.
@item Usage example
@example
pdf_time_t time1;
pdf_time_t time2;
pdf_i64_t diff;

pdf_time_init (&time1);
pdf_time_init (&time2);

pdf_time_set_utc (&time1, 1234567890);
pdf_time_set_utc (&time2, 1300000000);

diff = pdf_time_diff (&time1, &time2);
printf ("Time between times is: %lld\n",
        (long long) diff);

pdf_time_deinit (&time1);
pdf_time_deinit (&time2);
@end example
@end table
@end deftypefun

@node Time Comparison
@subsection Time Comparison

@deftypefun pdf_i8_t pdf_time_cmp (const pdf_time_t *@var{time1}, const pdf_time_t *@var{time2})
Compares two times.

@table @strong
@item Parameters

@table @var
@item time1
The first time to compare.
Should be a properly created time variable.
@item time2
The second time to compare.
Should be a properly created time variable.
@end table

@item Returns
A status value:
@table @code
@item -1
If @var{time1} precedes @var{time2}.
@item 0
If @var{time1} and @var{time2} contain the same time.
@item 1
If @var{time2} precedes @var{time1}.
@end table

@item Usage example
@example
pdf_time_t *time1;
pdf_time_t *time2;

time1 = pdf_time_new ();
time2 = pdf_time_new ();

pdf_time_set_utc (time1, 1234567890);
pdf_time_set_utc (time1, 1300000000);

/* As `time1' is before `time2', it will return -1 */
switch (pdf_time_cmp (time1, time2))
   @{
   case -1:
     @{
        /* `time1' precedes `time2' */
        break;
     @}
   case 0:
      @{
         /* `time1' contain the same time as `time2' */
         break;
      @}
   case 1:
      @{
         /* `time2' precedes `time1' */
         break;
      @}
   @}
@end example
@end table
@end deftypefun

@node Time Printing and Parsing
@subsection Time Printing and Parsing

@deftypefun pdf_char_t* pdf_time_to_string (const pdf_time_t *@var{time_var}, const enum pdf_time_string_format_e @var{time_format}, pdf_u32_t @var{options}, pdf_error_t **@var{error})
Create a string representation of a given time.

@table @strong
@item Parameters

@table @var
@item time_var
A properly created time variable.
@item time_format
The format to use when creating the string representation of
@var{time}.
@item options
Options to use when creating the string representation of the time.
@item error
A @code{pdf_error_t} to report errors or @code{NULL}.
@table @code
@item PDF_ENOMEM
Not enough memory to perform the operation.
@end table
@end table
@item Returns
The string representation of @var{time} which must be deallocated by the caller of the function explicitly with pdf_dealloc(), or @code{NULL} if there is an error.

@item Usage example
@example
pdf_error_t *error = NULL;
pdf_time_t mytime;
pdf_char_t *mytime_str;

pdf_time_init (&mytime);
pdf_time_set_utc (&mytime, 1234567890);

mytime_str = pdf_time_to_string (&mytime,
                                 PDF_TIME_STRING_FORMAT_PDF,
                                 PDF_TIME_STRING_NO_OPTION,
                                 &error);
if (!mytime_str)
   @{
      /* Error! */
      pdf_error_destroy (error);
   @}

pdf_dealloc (mytime_str);
pdf_time_deinit (&mytime);
@end example
@end table
@end deftypefun

@deftypefun pdf_bool_t pdf_time_set_from_string (pdf_time_t *@var{time_var}, const pdf_char_t *@var{time_str}, const enum pdf_time_string_format_e @var{time_format}, pdf_u32_t @var{options}, pdf_error_t **@var{error})
Set the contents of a time variable from a string in specific time format.

@table @strong
@item Parameters

@table @var
@item time_var
A properly created time variable.

@item time_str
A null-terminated string representation of a time.
@item time_format
The format indicating how to parse @var{time_str}.
@item options
Options to use when parsing the string representation of the time.
@item error
A @code{pdf_error_t} to report errors or @code{NULL}.
@table @code
@item PDF_EBADDATA
@var{time_str} in not properly formatted according to @var{time_format}
@end table
@end table
@item Returns
@code{PDF_TRUE} if the time was properly set, @code{PDF_FALSE} otherwise.

@item Usage example
@example
pdf_time_t *mytime;
pdf_error_t *error = NULL;
const pdf_char_t *time_str = "D:20090813210000+00'00";

mytime = pdf_time_new (NULL);
if (!pdf_time_from_string (mytime,
                           time_str,
                           PDF_TIME_STRING_FORMAT_PDF,
                           PDF_TIME_STRING_NO_OPTION,
                           &error))
   @{
      /* Error while parsing `time_str' according to
       * `PDF_TIME_STRING_FORMAT_PDF' */
      pdf_error_destroy (error);
   @}

pdf_time_destroy (mytime);
@end example
@end table
@end deftypefun

@node Getting the Current Time
@subsection Getting the Current Time

@deftypefun void pdf_time_set_to_current_local_time (pdf_time_t *@var{time_var})
Set the value of @var{time_var} to the current local time used by the operating system.

@table @strong
@item Parameters
@table @var
@item time_var
A properly created time variable.
@end table
@item Usage example
@example
pdf_time_t *mytime;

mytime = pdf_time_new (NULL);

pdf_time_set_to_current_local_time (mytime);

pdf_time_destroy (mytime);
@end example
@end table
@end deftypefun

@deftypefun void pdf_time_set_to_current_utc_time (pdf_time_t *@var{time_var})
Set the value of @var{time_var} to the current UTC time used by the operating system.

@table @strong
@item Parameters
@table @var
@item time_var
A properly created time variable.
@end table
@item Usage example
@example
pdf_time_t *mytime;

mytime = pdf_time_new (NULL);

pdf_time_set_to_current_utc_time (mytime);

pdf_time_destroy (mytime);
@end example
@end table
@end deftypefun

@node Calendar Spans Management
@subsection  Calendar Spans Management

@deftypefun void pdf_time_add_cal_span_with_base (const struct pdf_time_cal_span_s *@var{span1}, const struct pdf_time_cal_span_s *@var{span2}, const pdf_time_t *@var{base_time}, struct pdf_time_cal_span_s *@var{result})

Add two calendar spans. Since the calendar spans are relative (some
years has more days than another) the calendar spans are first
resolved from a base time.

@table @strong
@item Parameters
@table @var
@item span1
The pointer to the first calendar span to add.
@item span2
The pointer to the second calendar span to add.
@item base_time
The base time to use.
@item result
Pointer to the calendar span to store the result of the add operation.
@end table
@item Usage example
@example
pdf_time_t base;
struct pdf_time_cal_span_s span1 = @{ 0 @};
struct pdf_time_cal_span_s span2 = @{ 0 @};
struct pdf_time_cal_span_s result = @{ 0 @};

/* Base time the Unix epoch */
pdf_time_init (&base);

span1.years = 12;
span1.months = 1;
span1.days = 23;

span2.hours = 12;
span2.minutes = 30;
span2.seconds = 15;

pdf_time_add_cal_span_with_base (&span1,
                                 &span2,
                                 &base,
                                 &result);
printf ("(result) %d-%d-%d %d:%d:%d\n",
        result.years,
        result.months,
        result.days,
        result.hours,
        result.minutes,
        result.seconds);

pdf_time_deinit (&base);
@end example
@end table
@end deftypefun


@deftypefun pdf_i8_t pdf_time_cal_span_cmp (const struct pdf_time_cal_span_s *@var{span1}, const struct pdf_time_cal_span_s *@var{span2}, const pdf_time_t *@var{base_time})

Compare two calendar spans previously resolved with a given base time.

@table @strong
@item Parameters

@table @var
@item span1
The pointer to the first calendar span to be compared.
@item span2
The pointer to the second calendar span to be compared.
@item base_time
The used base time. Should be a correctly created time variable.
@end table
@item Returns
@table @code
@item -1
Given the base time, the time interval defined by @var{span2} is
greater in length than the time interval defined by @var{span1}.
@item 0
Given the base time, the time inveral defined by @var{span1} is equal
in length than the time interval defined by @var{span2}.
@item +1
Given the base time, the time interval defined by @var{span1} is
greater in length than the time interval defined by @var{span2}.
@end table
@item Usage example
@example
pdf_time_t base;
struct pdf_time_cal_span_s span1 = @{ 0 @};
struct pdf_time_cal_span_s span2 = @{ 0 @};
struct pdf_time_cal_span_s result = @{ 0 @};

/* Base time the Unix epoch */
pdf_time_init (&base);

span1.years = 12;
span1.months = 1;
span1.days = 23;

span2.years = 12;
span2.months = 1;
span2.days = 23;
span2.hours = 12;
span2.minutes = 30;
span2.seconds = 15;

/* `span2' is longer than `span1', so it should
 * return -1 */
switch (pdf_time_cal_span_cmp (&span1, &span2, &base))
   @{
   case -1:
      @{
         /* The length of `span1' is shorter than the
          * length of `span2' */
         break;
      @}
   case 0:
      @{
         /* The length of `span1' is equal than the
          * length of `span2' */
         break;
      @}
   case 1:
      @{
         /* The length of `span1' is greater than the
          * length of `span2' */
         break;
      @}
   @}

pdf_time_deinit (&base);
@end example
@end table
@end deftypefun

@deftypefun void pdf_time_cal_span_diff (const struct pdf_time_cal_span_s *@var{span1}, const struct pdf_time_cal_span_s *@var{span2}, const pdf_time_t *@var{base_time}, struct pdf_time_cal_span_s *@var{result})

Compute the difference between two calendar spans relative to a given
base time and store it in a given calendar span.

@table @strong
@item Parameters

@table @var
@item span1
The pointer to the first calendar span to diff.
@item span2
The pointer to the second calendar span to diff.
@item base_time
The base time. Should be a correctly created time variable.
@item result
Pointer to the calendar structure holding the result of the difference.
@end table
@item Usage example
@example
pdf_time_t base;
struct pdf_time_cal_span_s span1 = @{ 0 @};
struct pdf_time_cal_span_s span2 = @{ 0 @};
struct pdf_time_cal_span_s result = @{ 0 @};

/* Base time the Unix epoch */
pdf_time_init (&base);

span1.years = 12;
span1.months = 1;
span1.days = 23;

span2.years = 12;
span2.months = 1;
span2.days = 23;
span2.hours = 12;
span2.minutes = 30;
span2.seconds = 15;

pdf_time_cal_span_diff (&span1,
                        &span2,
                        &base,
                        &result);
printf ("(result) %d-%d-%d %d:%d:%d\n",
        result.years,
        result.months,
        result.days,
        result.hours,
        result.minutes,
        result.seconds);

pdf_time_deinit (&base);
@end example
@end table
@end deftypefun

@node Platform-specific functions
@subsection Platform-specific functions

@deftypefun pdf_bool_t pdf_time_w32_set_from_filetime (pdf_time_t *@var{time_var}, const FILETIME *@var{p_filetime}, pdf_error_t **@var{error})
This function will initialize @var{time_var} to the given Filetime epoch in UTC timescale.

This function is only available in Windows OS.
@table @strong
@item Parameters
@table @var
@item time_var
The time variable to set. Should be a properly create time variable.
@item p_filetime
Pointer to a valid FILETIME structure, containing 100-nanosecond intervals since 1 January 1601.
@item error
A @code{pdf_error_t} to report errors or @code{NULL}.
@table @code
@item PDF_ERROR
Generic error reported by the Windows-specific underlying method.
@end table
@end table
@item Returns
A status value:
@table @code
@item PDF_OK
The operation succeeded.
@end table
@item Usage example
@example
pdf_time_t mytime;
FILETIME filetime;

pdf_time_init (&mytime);

/* do stuff to get the FILETIME */

pdf_time_w32_set_from_filetime (&mytime, &filetime);

pdf_time_deinit (&mytime);
@end example
@end table
@end deftypefun


@node The Filesystem Module
@section The Filesystem Module

@menu
* Filesystem Concepts::
* The Filesystem Interface::
* The File Interface::
* The Filesystem Implementation Interface::
* The Filesystem Definition Interface::
@end menu

@node Filesystem Concepts
@subsection Filesystem Concepts

@strong{Filesystems}

Filesystem objects provide access to file system services in an
abstract way, letting the library client to define filesystems for
other classes of devices.

In the GNU PDF Library a filesystem object (of type @code{pdf_fsys_t}) is
an implementation of the file system services for a specific class of
devices. The filesystem object provides the functionality to open
files, read and write data from/to open files, create and delete
folders, rename files, manage file and folder permissions, etc.

By implementing the functions defined in the Filesystem Implementation
Interface the client can define and use its own filesystems. In this
way a high level of abstraction is achieved in the library code that
uses the filesystem services: the library could be able to read the contents
of a PDF file from a file stored in the local filesystem, from a
network webdav based filesystem, an http server or a compressed image.

The GNU PDF Library provides the default @emph{disk} filesystem
implementation for each supported plattform, as well as a simple @emph{http}
filesystem implementation for remote access of files in HTTP servers
which provide byte serving capabilities.

Conceptually speaking a filesystem contains a tree (or several
trees in some filesystem implementations supporting several
volumes) of @emph{filesystem items}.

Each item has a type and several properties. The client can ask the
filesystem for the properties of a given item identified by a path
name.

@strong{Open files}

Open files are readable or writeable items in a filesystem.

An open file object (of type @code{pdf_fsys_file_t}) represents a readable
and/or writable file in a filesystem. Open files are associated with a
given filesystem and any filesystem can maintain an arbitrary number
of open files (this may depend on the specific filesystem
implementation).

The client can read and write data from/to an open file using the
@code{pdf_fsys_file_*} functions. The implementation of the open files
then calls to the appropriate functionality of the filesystem managing
the file.

There is not an explicit data type for an @emph{open folder} in the GNU
PDF Library. Instead, folders are referred using @emph{paths}.

The Filesystem Interface provides functions to create, delete and
rename folders.

@strong{Paths}

Both files and folders in a filesystem can be referred using a string
locator: a @emph{path}. Paths are implemented using PDF text objects, and
several paths can refer to the same file or folder.

Both the encoding and the format of the contents of a path
depends on the specific filesystem implementation.

@strong{URLs}

@emph{URLs} are strings referring to files and folders in a filesystem, encoded
and built as per RFC 1738. Each filesystem is able to handle one or more URL
schemes, and implements conversion routines from paths to URLs and vice-versa.

@node The Filesystem Interface
@subsection The Filesystem Interface

The Filesystem Interface is implemented by the Filesystem module and
provides access to some filesystem functionalities in a filesystem
implementation independent way.

The functionality covered by the Filesystem Interface includes:

@itemize @bullet
@item
Folder management.
@item
Folder contents management.
@item
Volume-level flush operations.
@item
Read In Advance (RIA) capabilities.
@item
Storage properties management (free space, etc).
@item
Management of filesystem items (rename, remove, flags, etc).
@end itemize

Note that not all the filesystem implementations support these
operations. Read In Advance capabilities, for example, are usually
implemented in slow file system devices such as network
filesystems. When a specific filesystem implementation does not support
a functionality in the Filesystem Interface then the specific call
becomes a no-op.

@menu
* Filesystem Data Types::
* Retrieving File System implementations::
* Getting File System Properties::
* Managing paths and URLs::
* Folder Management::
* Getting File System Item Properties::
@end menu

@node Filesystem Data Types
@subsubsection Filesystem Data Types

The following data types are defined and provided to the client by the
Filesystem Module.

@deftp {Data Type} pdf_fsys_t
An opaque type representing a filesystem.
@end deftp

@deftp {Constant} PDF_FSYS_DISK_ID
Unique ID string of the Disk Filesystem implementation.
@end deftp

@deftp {Constant} PDF_FSYS_HTTP_ID
Unique ID string of the HTTP Filesystem implementation.
@end deftp

@deftp {Data Type} {struct pdf_fsys_item_props_s}
This structure holds information about a filesystem item (a file or a
directory).

@table @code
@item pdf_bool_t is_hidden
Whether the item is, or should be considered, hidden.
@item pdf_bool_t is_readable
Whether the item is readable.
@item pdf_bool_t is_writable
Whether the item is writable.
@item pdf_time_t creation_date
Creation date/time of the item.
@item pdf_time_t modification_date
Modification date/time of the item.
@item pdf_off_t file_size
File size, in octets.
@end table
@end deftp


@node Retrieving File System implementations
@subsubsection Retrieving File System implementations

@deftypefun {const pdf_fsys_t *}pdf_fsys_get (const pdf_char_t *@var{id})

Get the filesystem implementation registered with the given @var{id}.

@table @strong
@item Parameters
@table @var
@item id
A unique string ID, which should be the one used when registering the filesystem
implementation.
@end table
@item Returns
The registered filesystem implementation.
@item Usage example
@example

const pdf_fsys_t *disk;

disk = pdf_fsys_get (PDF_FSYS_DISK_ID);
if (!disk)
  @{
    printf ("No Disk filesystem implementation was registered\n");
  @}

@end example
@end table
@end deftypefun

@defun PDF_FSYS_DISK

Macro that retrieves the filesystem implementation with ID PDF_FSYS_DISK_ID.

@table @strong
@item Returns
The macro expands to a @code{pdf_fsys_t *}.
@item Usage example
@example

if (!PDF_FSYS_DISK)
  @{
    printf ("No Disk filesystem implementation was registered\n");
  @}

@end example
@end table
@end defun

@defun PDF_FSYS_HTTP

Macro that retrieves the filesystem implementation with ID PDF_FSYS_HTTP_ID.

@table @strong
@item Returns
The macro expands to a @code{pdf_fsys_t *}.
@item Usage example
@example

if (!PDF_FSYS_HTTP)
  @{
    printf ("No HTTP filesystem implementation was registered\n");
  @}

@end example
@end table
@end defun

@node Managing paths and URLs
@subsubsection Managing paths and URLs


@deftypefun {pdf_text_t *}pdf_fsys_get_parent (const pdf_fsys_t *@var{fsys}, const pdf_text_t *@var{path}, pdf_error_t **@var{error})

Get the path of the direct parent of a given item in the filesystem.

@table @strong
@item Parameters
@table @var
@item fsys
A valid filesystem.
@item path
The path of an item in the filesystem.
@item error
A @code{pdf_error_t} to report errors or @code{NULL}.
@table @code
@item PDF_EBADNAME
@var{path} does not name a valid item in the filesystem.
@item PDF_EBADPERMS
The client does not have permissions to get the parent of the specified
item.
@end table
@end table
@item Returns
A newly created @code{pdf_text_t}, or @code{NULL} if there is no parent.
On error, @code{NULL} is also returned, and @var{error} is set accordingly.
@item Usage example
@example

static void
print_parent_directories (const pdf_char_t *utf8_path)
@{
  pdf_error_t *error = NULL;
  pdf_text_t *path;
  pdf_text_t *parent;

  path = pdf_text_new_from_unicode (utf8_path,
                                    strlen (utf8_path),
                                    PDF_TEXT_UTF8,
                                    &error);
  if (!path)
    @{
      printf ("couldn't get path: %s\n",
              error ? pdf_error_get_message (error) : "unknown error");
      pdf_error_destroy (error);
      return;
    @}

  while ((parent = pdf_fsys_get_parent (PDF_FSYS_DISK,
                                        path,
                                        &error)) != NULL)
    @{
      pdf_char_t *parent_utf8;

      parent_utf8 = pdf_text_get_unicode ((const pdf_text_t *)elem,
                                          PDF_TEXT_UTF8,
                                          PDF_TEXT_UNICODE_WITH_NUL_SUFFIX,
                                          NULL,
                                          &error);
      if (!parent_utf8)
        @{
          printf ("couldn't get UTF-8 parent path: %s\n",
                  error ? pdf_error_get_message (error) : "unknown error");
          pdf_clear_error (&error);
          break;
        @}

      printf ("Parent path found: '%s'\n",
              parent_utf8);

      pdf_dealloc (parent_utf8);
      pdf_text_destroy (path);
      path = parent;
    @}

  if (error)
    @{
      printf ("couldn't list parents: %s\n",
              error ? pdf_error_get_message (error) : "unknown error");
      pdf_error_destroy (error);
    @}

  if (path)
    pdf_text_destroy (path);
  if (parent)
    pdf_text_destroy (parent);
@}

@end example
@end table
@end deftypefun

@deftypefun {pdf_text_t *}pdf_fsys_get_basename (const pdf_fsys_t *@var{fsys}, const pdf_text_t *@var{path}, pdf_error_t **@var{error})

Get the filename from a given path in the filesystem.

@table @strong
@item Parameters
@table @var
@item fsys
A valid filesystem.
@item path
The path of an item in the filesystem.
@item error
A @code{pdf_error_t} to report errors or @code{NULL}.
@table @code
@item PDF_EBADNAME
@var{path} does not name a valid item in the filesystem.
@item PDF_EBADPERMS
The client does not have permissions to get the parent of the specified
item.
@end table
@end table
@item Returns
A newly created @code{pdf_text_t}.
On error, @code{NULL} is returned, and @var{error} is set accordingly.
@item Usage example
@example

pdf_bool_t
file_is_hidden (pdf_text_t *path)
@{
  pdf_error_t *error = NULL;
  pdf_text_t *basename;
  pdf_char_t *basename_utf8;
  pdf_bool_t hidden;

  basename = pdf_fsys_get_basename (PDF_FSYS_DISK,
                                    path,
                                    &error);
  if (!basename)
    @{
      printf ("couldn't get basename: %s\n",
              error ? pdf_error_get_message (error) : "unknown error");
      pdf_clear_error (&error);
      return PDF_FALSE;
    @}

  basename_utf8 = pdf_text_get_unicode (basename,
                                        PDF_TEXT_UTF8,
                                        PDF_TEXT_UNICODE_WITH_NUL_SUFFIX,
                                        NULL,
                                        &error);
  if (!basename_utf8)
    @{
      printf ("couldn't get UTF-8 filename: %s\n",
              error ? pdf_error_get_message (error) : "unknown error");
      pdf_clear_error (&error);
      pdf_text_destroy (basename);
      return PDF_FALSE;
    @}

  hidden = (basename_utf8[0] == '.' ? PDF_TRUE : PDF_FALSE);

  pdf_dealloc (basename_utf8);
  pdf_text_destroy (basename);

  return hidden;
@}

@end example
@end table
@end deftypefun

@deftypefun {pdf_text_t *}pdf_fsys_build_path (const pdf_fsys_t *@var{fsys}, pdf_error_t **@var{error}, const pdf_text_t *@var{first_element}, ...)

Build a path by concatenating the given @code{pdf_text_t} path elements.

@table @strong
@item Parameters
@table @var
@item fsys
A valid filesystem.
@item error
A @code{pdf_error_t} to report errors or @code{NULL}.
@table @code
@item PDF_ENOMEM
Not enough memory to perform the operation.
@item PDF_ERROR
Generic error building the path.
@end table
@item first_element
First text path element.
@item ...
Variable-length list of @code{pdf_text_t} objects, last element must be @code{NULL}.
@end table
@item Returns
A newly allocated @code{pdf_text_t} containing the built path, or @code{NULL} on error.
@item Usage example
@example

pdf_text_t *
get_full_path (const pdf_text_t *directory,
               const pdf_text_t *filename)
@{
  pdf_text_t *full_path;
  pdf_error_t *error = NULL;

  full_path = pdf_fsys_build_path (PDF_FSYS_DISK,
                                   &error,
                                   directory,
                                   filename,
                                   NULL);
  if (!full_path)
    @{
      printf ("couldn't build path: %s",
              error ? pdf_error_get_message (error) : "unknown error");
      pdf_clear_error (&error);
      return NULL;
    @}

  return full_path;
@}

@end example
@end table
@end deftypefun

@deftypefun {pdf_char_t *}pdf_fsys_get_url_from_path (const pdf_fsys_t *@var{fsys}, const pdf_text_t *@var{path}, pdf_error_t **@var{error})

Get a URL corresponding to the given path.

@table @strong
@item Parameters
@table @var
@item fsys
A valid filesystem.
@item path
The path of an item in the filesystem.
@item error
A @code{pdf_error_t} to report errors or @code{NULL}.
@table @code
@item PDF_ENOMEM
Not enough memory to perform the operation.
@item PDF_ERROR
Generic error building the URL.
@end table
@end table
@item Returns
A newly allocated string with the URL.
@item Usage example
@example

void
print_file_url (const pdf_text_t *path)
@{
  pdf_char_t *url;
  pdf_error_t *error = NULL;

  url = pdf_fsys_get_url_from_path (PDF_FSYS_DISK,
                                    path,
                                    &error);
  if (!url)
    @{
      printf ("couldn't get URL from path: %s",
              error ? pdf_error_get_message (error) : "unknown error");
      pdf_clear_error (&error);
      return;
    @}

  printf ("URL: '%s'\n", url);
  pdf_dealloc (url);
@}

@end example
@end table
@end deftypefun

@deftypefun {pdf_text_t *}pdf_fsys_get_path_from_url (const pdf_fsys_t *@var{fsys}, const pdf_char_t *@var{url}, pdf_error_t **@var{error})

Get the path corresponding to the given URL.

@table @strong
@item Parameters
@table @var
@item fsys
A valid filesystem.
@item url
A valid URL for an item in the filesystem.
@item error
A @code{pdf_error_t} to report errors or @code{NULL}.
@table @code
@item PDF_ENOMEM
Not enough memory to perform the operation.
@item PDF_ERROR
Generic error building the path.
@end table
@end table
@item Returns
A newly allocated @code{pdf_text_t} containing the path.
@item Usage example
@example

void
print_file_path (const pdf_char_t *url)
@{
  pdf_text_t *path;
  pdf_char_t *path_utf8;
  pdf_error_t *error = NULL;

  path = pdf_fsys_get_path_from_url (PDF_FSYS_DISK,
                                     url,
                                     &error);
  if (!path)
    @{
      printf ("couldn't get path from URL: %s",
              error ? pdf_error_get_message (error) : "unknown error");
      pdf_clear_error (&error);
      return;
    @}

  path_utf8 = pdf_text_get_unicode (path,
                                    PDF_TEXT_UTF8,
                                    PDF_TEXT_UNICODE_WITH_NUL_SUFFIX,
                                    NULL,
                                    &error);
  if (!path_utf8)
    @{
      printf ("couldn't get UTF-8 from path: %s\n",
              error ? pdf_error_get_message (error) : "unknown error");
      pdf_clear_error (&error);
      pdf_text_destroy (path);
      break;
    @}

  printf ("Path: '%s'\n", path_utf8);

  pdf_dealloc (path_utf8);
  pdf_text_destroy (path);
@}

@end example
@end table
@end deftypefun

@node Getting File System Properties
@subsubsection Getting File System Properties

@deftypefun pdf_i64_t pdf_fsys_get_free_space (const pdf_fsys_t *@var{fsys}, pdf_text_t *@var{path}, pdf_error_t **@var{error})

Get the free storage space in the volume containing @var{path}.

@table @strong
@item Parameters
@table @var
@item fsys
A valid filesystem.
@item path
A path.
@item error
A @code{pdf_error_t} to report errors or @code{NULL}.
@table @code
@item PDF_ERROR
Any other error.
@end table
@end table
@item Returns
A 64-bit value containing the remaining free space in the volume
containing @var{path}, or -1 if error.
@item Usage example
@example

static void
print_root_free_space (void)
@{
  pdf_i64_t free_space;
  pdf_text_t *path;

  path = pdf_text_new_from_unicode ("/", 1, PDF_TEXT_UTF8, NULL);
  if (!path)
    return;

  free_space = pdf_fsys_get_free_space (PDF_FSYS_DISK, path, NULL);
  if (free_space < 0)
    return;

  printf ("Empty space in root: %ld\n", free_space);

  pdf_text_destroy (path);
@}

@end example
@end table
@end deftypefun

@node Folder Management
@subsubsection Folder Management

@deftypefun pdf_bool_t pdf_fsys_create_folder (const pdf_fsys_t *@var{fsys}, const pdf_text_t *@var{path}, pdf_error_t **@var{error})

Create a folder named @var{path}.

@table @strong
@item Parameters
@table @var
@item fsys
A valid filesystem.
@item path
The path of the folder to be created.
@item error
A @code{pdf_error_t} to report errors or @code{NULL}.
@table @code
@item PDF_EBADNAME
The specified @var{path} is incorrect.
@item PDF_EBADPERMS
The client does not have permissions to create the folder.
@item PDF_ERROR
Any other error condition.
@end table
@end table
@item Returns
@code{PDF_TRUE} if successful, @code{PDF_FALSE} otherwise.
@item Usage example
@example

pdf_error_t *error = NULL;
const pdf_char_t *utf8_path = "/tmp/something";
pdf_text_t *path;

path = pdf_text_new_from_unicode (utf8_path,
                                  strlen (utf8_path),
                                  PDF_TEXT_UTF8,
                                  &error);
if (!path ||
    !pdf_fsys_create_folder (PDF_FSYS_DISK,
                             path,
                             error))
  @{
    printf ("Couldn't create folder '%s': '%s'\n",
            utf8_path,
            (error ?
             pdf_error_get_message (error) :
             "unknown error"));
    pdf_clear_error (&error);
  @}

if (path)
  pdf_text_destroy (path);

@end example
@end table
@end deftypefun

@deftypefun pdf_bool_t pdf_fsys_remove_folder (const pdf_fsys_t *@var{fsys}, const pdf_text_t *@var{path}, pdf_error_t **@var{error})

Remove an empty folder from the filesystem.

@table @strong
@item Parameters
@table @var
@item fsys
A valid filesystem.
@item path
A path of an empty folder in the filesystem.
@item error
A @code{pdf_error_t} to report errors or @code{NULL}.
@table @code
@item PDF_EBADNAME
@var{path} does not name a folder in the filesystem.
@item PDF_EBADPERMS
The client does not have permissions to remove the folder.
@item PDF_ERROR
Any other error.
@end table
@end table
@item Returns
@code{PDF_TRUE} if successful, @code{PDF_FALSE} otherwise.
@item Usage example
@example

pdf_error_t *error = NULL;
const pdf_char_t *utf8_path = "/tmp/something";
pdf_text_t *path;

path = pdf_text_new_from_unicode (utf8_path,
                                  strlen (utf8_path),
                                  PDF_TEXT_UTF8,
                                  &error);
if (!path ||
    !pdf_fsys_remove_folder (PDF_FSYS_DISK,
                             path,
                             error))
  @{
    printf ("Couldn't remove folder '%s': '%s'\n",
            utf8_path,
            (error ?
             pdf_error_get_message (error) :
             "unknown error"));
    pdf_clear_error (&error);
  @}

if (path)
  pdf_text_destroy (path);

@end example
@end table
@end deftypefun

@deftypefun {pdf_list_t *}pdf_fsys_get_folder_contents (const pdf_fsys_t *@var{fsys}, const pdf_text_t *@var{path}, pdf_error_t **@var{error})

Get a list with the paths of the items contained in a given folder.

@table @strong
@item Parameters
@table @var
@item fsys
A valid filesystem.
@item path
The path of a folder.
@item error
A @code{pdf_error_t} to report errors or @code{NULL}.
@table @code
@item PDF_EBADNAME
@var{path} does not name a folder in the filesystem.
@item PDF_EBADPERMS
The client does not have permissions to read the contents of the folder.
@item PDF_ERROR
Any other error condition.
@end table
@end table
@item Returns
A newly allocated list of @code{pdf_text_t} items with the names of the files in
the given folder.
@item Usage example
@example

static void
print_filenames_in_directory (const pdf_char_t *utf8_path)
@{
  pdf_text_t *path;
  pdf_list_iterator_t iter;
  pdf_error_t *error = NULL;
  pdf_list_t *files;
  void *elem;

  path = pdf_text_new_from_unicode (utf8_path,
                                    strlen (utf8_path),
                                    PDF_TEXT_UTF8,
                                    &error);
  if (!path)
    @{
      printf ("couldn't create path object: %s\n",
              error ? pdf_error_get_message (error) : "unknown error");
      pdf_error_destroy (error);
      return;
    @}

  files = pdf_fsys_get_folder_contents (PDF_FSYS_DISK,
                                        path,
                                        &error);
  if (!files)
    @{
      printf ("couldn't list files in folder: %s\n",
              error ? pdf_error_get_message (error) : "unknown error");
      pdf_error_destroy (error);
      return;
    @}

  pdf_list_iterator_init (&iter, files);
  while (pdf_list_iterator_next (&iter, &elem, NULL))
    @{
      pdf_char_t *filename_utf8;

      filename_utf8 = pdf_text_get_unicode ((const pdf_text_t *)elem,
                                            PDF_TEXT_UTF8,
                                            PDF_TEXT_UNICODE_WITH_NUL_SUFFIX,
                                            NULL,
                                            &error);
      if (!filename_utf8)
        @{
          printf ("couldn't get UTF-8 filename: %s\n",
                  error ? pdf_error_get_message (error) : "unknown error");
          pdf_clear_error (&error);
          pdf_list_iterator_deinit (&iter);
          break;
        @}

      printf ("File '%s' found in directory\n",
              filename_utf8);

      pdf_dealloc (filename_utf8);
    @}

  pdf_list_iterator_deinit (&iter);
  pdf_list_destroy (files);
@}

@end example
@end table
@end deftypefun

@node Getting File System Item Properties
@subsubsection Getting File System Item Properties

The following functions provides access to generic properties of
filesystem items (both files and directories).

@deftypefun pdf_bool_t pdf_fsys_get_item_props (pdf_fsys_t *@var{fsys}, pdf_text_t *@var{path}, struct pdf_fsys_item_props_s *@var{props}, pdf_error_t **@var{error})

Get the properties of a filesystem item identified by a path.

@table @strong
@item Parameters
@table @var
@item fsys
A valid filesystem.
@item path
The path of an item in the filesystem.
@item props
The address of a structure to hold the properties of the filesystem
item.
@item error
A @code{pdf_error_t} to report errors or @code{NULL}.
@table @code
@item PDF_EBADDATA
Invalid path.
@item PDF_EBADPERMS
The client does not have enough permissions to read the requested item.
@end table
@end table
@item Returns
@code{PDF_TRUE} if successful, @code{PDF_FALSE} otherwise.
@item Usage example
@example

void
print_file_properties (pdf_text_t *path)
@{
  pdf_error_t *error = NULL;
  struct pdf_fsys_item_props_s item_props = @{ 0 @};
  pdf_char_t *utf8;
  pdf_char_t *mtime_str;
  pdf_char_t *ctime_str;

  utf8 = pdf_text_get_unicode (path,
                               PDF_TEXT_UTF8,
                               PDF_TEXT_UNICODE_WITH_NUL_SUFFIX,
                               NULL,
                               &error);
  if (!utf8)
    @{
      printf ("couldn't get UTF-8 path\n");
      return;
    @}

  /* Get the properties for the item */
  if (!pdf_fsys_get_item_props (PDF_FSYS_DISK,
                                path,
                                &item_props,
                                &error))
    @{
      printf ("couldn't get item '%s' properties: %s\n",
              utf8,
              error ? pdf_error_get_message (error) : "unknown error");
      pdf_clear_error (&error);
      pdf_dealloc (utf8);
      return;
    @}

  ctime_str = pdf_time_to_string (&item_props.creation_date,
                                  PDF_TIME_STRING_FORMAT_ISO_8601,
                                  PDF_TIME_STRING_NO_OPTION,
                                  NULL);
  mtime_str = pdf_time_to_string (&item_props.modification_date,
                                  PDF_TIME_STRING_FORMAT_ISO_8601,
                                  PDF_TIME_STRING_NO_OPTION,
                                  NULL);

  printf ("item '%s' properties:\n"
          "  hidden:   %s\n"
          "  readable: %s\n"
          "  writable: %s\n"
          "  ctime:    %s\n"
          "  mtime:    %s\n"
          "  size:     %lu bytes\n",
          utf8,
          item_props.is_hidden ? "yes" : "no",
          item_props.is_readable ? "yes" : "no",
          item_props.is_writable ? "yes" : "no",
          ctime_str ? ctime_str : "unknown",
          mtime_str ? mtime_str : "unknown",
          (unsigned long)item_props.file_size);

  pdf_dealloc (ctime_str);
  pdf_dealloc (mtime_str);
  pdf_dealloc (utf8);
@}

@end example
@end table
@end deftypefun

@deftypefun {pdf_hash_t *}pdf_fsys_item_props_to_hash (const struct pdf_fsys_item_props_s *@var{item_props}, pdf_error_t **@var{error})

Get a hash containing the properties of a filesystem item.

The values returned in the hash variable are represented by the following keys:

@table @code
@item PDF_FSYS_ITEM_IS_HIDDEN
Boolean value, with the value of the 'is_hidden' variable in @var{item_props}.
@item PDF_FSYS_ITEM_IS_READABLE
Boolean value, with the value of the 'is_readable' variable in @var{item_props}.
@item PDF_FSYS_ITEM_IS_WRITABLE
Boolean value, with the value of the 'is_writable variable in @var{item_props}.
@item PDF_FSYS_ITEM_CREATION_DATE
A PDF style date string representing the 'creation_date' variable in @var{item_props}.
@item PDF_FSYS_ITEM_MODIFICATION_DATE
A PDF style date string representing the 'modification_date' variable in @var{item_props}.
@item PDF_FSYS_ITEM_FILE_SIZE
A @code{pdf_size_t} value, with the value of the 'file_size' variable in @var{item_props}.
@end table

@table @strong
@item Parameters
@table @var
@item item_props
A filesystem item properties structure.
@item error
A @code{pdf_error_t} to report errors or @code{NULL}.
@table @code
@item PDF_ENOMEM
Not enough memory to perform the operation.
@end table
@end table
@item Returns
A newly allocated @code{pdf_hash_t} containing the properties of the filesystem item.
@item Usage example
@example

void
print_file_properties (pdf_text_t *path)
@{
  pdf_error_t *error = NULL;
  struct pdf_fsys_item_props_s item_props = @{ 0 @};
  pdf_char_t *utf8;
  const pdf_char_t *mtime_str;
  const pdf_char_t *ctime_str;
  pdf_hash_t *item_props_hash;

  utf8 = pdf_text_get_unicode (path,
                               PDF_TEXT_UTF8,
                               PDF_TEXT_UNICODE_WITH_NUL_SUFFIX,
                               NULL,
                               &error);
  if (!utf8)
    @{
      printf ("couldn't get UTF-8 path\n");
      return;
    @}

  /* Get the properties for the item */
  if (!pdf_fsys_get_item_props (PDF_FSYS_DISK,
                                path,
                                &item_props,
                                &error))
    @{
      printf ("couldn't get item '%s' properties: %s\n",
              utf8,
              error ? pdf_error_get_message (error) : "unknown error");
      pdf_clear_error (&error);
      pdf_dealloc (utf8);
      return;
    @}

  /* Get hash with the properties */
  item_props_hash = pdf_fsys_item_props_to_hash (&item_props,
                                                 &error);
  if (!item_props_hash)
    @{
      printf ("couldn't get props hash: %s\n",
              error ? pdf_error_get_message (error) : "unknown error");
      pdf_clear_error (&error);
      pdf_dealloc (utf8);
      return;
    @}

  ctime_str = pdf_hash_get_string (item_props_hash,
                                   PDF_FSYS_ITEM_CREATION_DATE);
  mtime_str = pdf_hash_get_string (item_props_hash,
                                   PDF_FSYS_ITEM_MODIFICATION_DATE);

  printf ("item '%s' properties:\n"
          "  hidden:   %s\n"
          "  readable: %s\n"
          "  writable: %s\n"
          "  ctime:    %s\n"
          "  mtime:    %s\n"
          "  size:     %lu bytes\n",
          utf8,
          pdf_hash_get_bool (item_props_hash,
                             PDF_FSYS_ITEM_IS_HIDDEN) ? "yes" : "no",
          pdf_hash_get_bool (item_props_hash,
                             PDF_FSYS_ITEM_IS_READABLE) ? "yes" : "no",
          pdf_hash_get_bool (item_props_hash,
                             PDF_FSYS_ITEM_IS_WRITABLE) ? "yes" : "no",
          ctime_str ? ctime_str : "unknown",
          mtime_str ? mtime_str : "unknown",
          (unsigned long)pdf_hash_get_size (item_props_hash,
                                            PDF_FSYS_ITEM_FILE_SIZE));

  pdf_hash_destroy (item_props_hash);
  pdf_dealloc (utf8);
@}

@end example
@end table
@end deftypefun

@deftypefun pdf_bool_t pdf_fsys_item_p (pdf_fsys_t *@var{fsys}, pdf_text_t *@var{path})

Determine if a given item, identified by a path, exists in a given
filesystem.

@table @strong
@item Parameters
@item fsys
A valid filesystem.
@item path
The path of an item in the filesystem.
@item Returns
@code{PDF_TRUE} if the specified item exists in the filesystem.
If th item doesn't exist, or if the program doesn't have enough permissions to check it, @code{PDF_FALSE} is returned.
@item Usage example
@example

void
print_file_exists (const pdf_char_t *path_utf8)
@{
  pdf_text_t *path;

  path = pdf_text_new_from_unicode (path_utf8,
                                    strlen (path_utf8),
                                    PDF_TEXT_UTF8,
                                    NULL);

  /* Test whether the path exists */
  printf ("File '%s' %s\n",
          path_utf8,
          (pdf_fsys_item_p (PDF_FSYS_DISK, path) ?
           "exists" : "doesn't exist"));

  pdf_text_destroy (path);
@}

@end example
@end table
@end deftypefun

@deftypefun pdf_bool_t pdf_fsys_item_readable_p (const pdf_fsys_t *@var{fsys}, pdf_text_t *@var{path})

Determine if a given filesystem item, identified by a path, is
readable.

@table @strong
@item Parameters
@table @var
@item fsys
A valid filesystem.
@item path
The path of an item in the filesystem.
@end table
@item Returns
@code{PDF_TRUE} if the specified item is readable.
If th item doesn't exist, or if the program doesn't have enough permissions to check if the item is readable, @code{PDF_FALSE} is returned.
@item Usage example
@example

void
print_file_readable (const pdf_char_t *path_utf8)
@{
  pdf_text_t *path;

  path = pdf_text_new_from_unicode (path_utf8,
                                    strlen (path_utf8),
                                    PDF_TEXT_UTF8,
                                    NULL);

  /* Test whether the path exists */
  printf ("File '%s' is %s\n",
          path_utf8,
          (pdf_fsys_item_readable_p (PDF_FSYS_DISK, path) ?
           "readable" : "not readable"));

  pdf_text_destroy (path);
@}

@end example
@end table
@end deftypefun

@deftypefun pdf_bool_t pdf_fsys_item_writable_p (const pdf_fsys_t *@var{fsys}, pdf_text_t *@var{path})

Determine if a given filesystem item, identified by a path, is
writable.

@table @strong
@item Parameters
@table @var
@item fsys
A valid filesystem.
@item path
The path of an item in the filesystem.
@end table
@item Returns
@code{PDF_TRUE} if the specified item is writable.
If th item doesn't exist, or if the program doesn't have enough permissions to check if the item is writable, @code{PDF_FALSE} is returned.
@item Usage example
@example

void
print_file_writable (const pdf_char_t *path_utf8)
@{
  pdf_text_t *path;

  path = pdf_text_new_from_unicode (path_utf8,
                                    strlen (path_utf8),
                                    PDF_TEXT_UTF8,
                                    NULL);

  /* Test whether the path exists */
  printf ("File '%s' is %s\n",
          path_utf8,
          (pdf_fsys_item_writable_p (PDF_FSYS_DISK, path) ?
           "writable" : "not writable"));

  pdf_text_destroy (path);
@}

@end example
@end table
@end deftypefun


@node The File Interface
@subsection The File Interface

The File Interface is implemented by the filesystem module and
provides access to filesystem functionality related with open files,
such as writing and reading data to/from a specific file.

The functionality covered by the File Interface includes:

@itemize @bullet
@item
Synchronous Input/Output.
@item
Asynchronous Input/Output (not to be confused with RIA. See above).
@item
File-level flush operations.
@item
File positioning management.
@item
File size management.
@item
File flags (status) management.
@end itemize

Note that open file variables (@code{pdf_fsys_file_t}) contain a
reference to its underlying filesystem implementation, so the client
should only provide a correctly initialized (opened) file variable to
the @code{pdf_fsys_file_*} functions.

@menu
* File Data Types::
* Opening and closing Files::
* File Properties Management::
* Comparing Files::
* Managing File Positions::
* Changing the Size of a File::
* Synchronous Input/Output::
* Read in Advance::
@end menu

@node File Data Types
@subsubsection File Data Types

The following file-related data types are defined and provided to the
client by the Filesystem Module.

@deftp {Data Type} pdf_fsys_file_t
An opaque type representing an open file. The client can perform
several operations in the file using the @code{pdf_fsys_file_t} as a
reference.
@end deftp

@deftp {Data Type} {enum pdf_fsys_file_mode_e}

The mode used when opening a file in a filesystem. The available modes
are described in the following list.

@table @code
@item PDF_FSYS_OPEN_MODE_INVALID
Invalid open mode.
@item PDF_FSYS_OPEN_MODE_READ
The file is opened in read-only mode. The file should exist in the
filesystem.
@item PDF_FSYS_OPEN_MODE_WRITE
The file is opened in write-only mode. The file is truncated to 0
size (any previous contents are lost) if the file exists and it is
created if it does not exist.
@item PDF_FSYS_OPEN_MODE_RW
The file is opened in read/write mode. The file should exist in the
filesystem.
@end table
@end deftp


@node Opening and closing Files
@subsubsection Opening and closing Files

@deftypefun {pdf_fsys_file_t *}pdf_fsys_file_open (const pdf_fsys_t *@var{fsys}, const pdf_text_t *@var{path}, enum pdf_fsys_file_mode_e @var{mode}, pdf_error_t **@var{error})

Open a file in @var{fsys} identified by @var{path} using
the specified @var{mode} and return a new open file object.

@table @strong
@item Parameters
@table @var
@item fsys
A valid filesystem.
@item path
A path that identifies the file to be opened. The format and
encoding of this text variable depends on the underlying filesystem
implementation.
@item mode
The open mode to use to open the file.
@item file
The output file variable.
@item error
A @code{pdf_error_t} to report errors or @code{NULL}.
@table @code
@item PDF_EBADNAME
The path specified in @var{path} does not identify an existing
file in the filesystem.
@item PDF_EBADPERMS
The client does not have permission to open the specified file using the
specified mode.
@item PDF_ENOMEM
Not enough memory.
@end table
@end table
@item Returns
A newly created @code{pdf_fsys_file_t} or @code{NULL} on error.
@item Usage example
@example

pdf_fsys_file_t *
file_open_read (pdf_text_t *path)
@{
  pdf_error_t *error = NULL;
  pdf_fsys_file_t *f;

  f = pdf_fsys_file_open (PDF_FSYS_DISK,
                          path,
                          PDF_FSYS_OPEN_MODE_READ,
                          &error);
  if (!f)
    @{
      printf ("couldn't open the file for reading: '%s'\n",
              error ? pdf_error_get_message (error) : "unknown error");
      return NULL;
    @}

  printf ("correctly opened the file for reading\n");
  return f;
@}

@end example
@end table
@end deftypefun

@deftypefun {pdf_fsys_file_t *}pdf_fsys_file_open_tmp (const pdf_fsys_t *@var{fsys}, pdf_error_t **@var{error})

Create a temporary file in @var{fsys} and open it.

The temporary file is opened with mode @code{PDF_FSYS_OPEN_MODE_RW}
and stored in @var{file}. The file will be automatically deleted
after it gets closed.

Note that while the filesystem implementation may also delete the file
when the client application exits, it is not guaranteed.

@table @strong
@item Parameters
@table @var
@item fsys
A valid filesystem.
@item error
A @code{pdf_error_t} to report errors or @code{NULL}.
@table @code
@item PDF_EBADNAME
The path specified in @var{path} does not identify an existing
file in the filesystem.
@item PDF_EBADPERMS
The client does not have permission to open the specified file using the
specified mode.
@item PDF_ENOMEM
Not enough memory.
@end table
@end table
@item Returns
A newly created @code{pdf_fsys_file_t} or @code{NULL} on error.
@item Usage example
@example

pdf_error_t *error = NULL;
pdf_fsys_file_t *tmpfile;
pdf_size_t written;

/* Open a temporary file and write some contents to it.  */
tmpfile = pdf_fsys_file_open_tmp (PDF_FSYS_DISK,
                                  &error);
if (!tmpfile)
  @{
    printf ("couldn't open temporary file: '%s'",
            error ? pdf_error_get_message (error) : "unknown error");
  @}
else
  @{
    const pdf_char_t *data = "Temporary data";

    pdf_fsys_file_write (tmpfile,
                         data,
                         strlen (data),
                         &written,
                         NULL);

    /* Close the file. Also deletes it from the filesystem. */
    pdf_fsys_file_close (tmpfile);
  @}

@end example
@end table
@end deftypefun

@deftypefun pdf_bool_t pdf_fsys_file_close (pdf_fsys_file_t *@var{file}, pdf_error_t **@var{error})

Close a given open file. Any pending output data is flushed before closing.

@table @strong
@item Parameters
@table @var
@item file
An open file.
@item error
A @code{pdf_error_t} to report errors or @code{NULL}.
@table @code
@item PDF_ERROR
There was an error closing the file.
@end table
@end table
@item Returns
@code{PDF_TRUE} if file was successfully closed, @code{PDF_FALSE} otherwise. In both cases, @var{file} can no longer be used.
@item Usage example
@example

void
print_can_file_open_read (pdf_text_t *path)
@{
  pdf_error_t *error = NULL;
  pdf_fsys_file_t *f;

  f = pdf_fsys_file_open (PDF_FSYS_DISK,
                          path,
                          PDF_FSYS_OPEN_MODE_READ,
                          &error);
  if (!f)
    @{
      printf ("couldn't open the file for reading: '%s'\n",
              error ? pdf_error_get_message (error) : "unknown error");
      pdf_clear_error (&error);
      return;
    @}

  printf ("correctly opened the file for reading\n");

  if (!pdf_fsys_file_close (f, &error))
    @{
      printf ("error closing the file: '%s'\n",
              error ? pdf_error_get_message (error) : "unknown error");
      pdf_clear_error (&error);
    @}
@}

@end example
@end table
@end deftypefun

@deftypefun pdf_bool_t pdf_fsys_file_reopen (pdf_fsys_file_t *@var{file}, enum pdf_fsys_file_mode_e @var{mode}, pdf_error_t **@var{error})

Reopen a given open file with a given mode.

@table @strong
@item Parameters
@table @var
@item file
An open file.
@item mode
The new file mode to use.
@item error
A @code{pdf_error_t} to report errors or @code{NULL}.
@table @code
@item PDF_EBADPERMS
The client does not have enough permissions to open the file using the
specified mode. The open file is now closed.
@end table
@end table
@item Returns
@code{PDF_TRUE} if successfully reopened, @code{PDF_FALSE} otherwise.
@item Usage example
@example

void
print_file_open_modes (pdf_text_t *path)
@{
  pdf_error_t *error = NULL;
  pdf_fsys_file_t *f;

  f = pdf_fsys_file_open (PDF_FSYS_DISK,
                          path,
                          PDF_FSYS_OPEN_MODE_READ,
                          &error);
  if (!f)
    @{
      printf ("couldn't open the file for reading: '%s'\n",
              error ? pdf_error_get_message (error) : "unknown error");
      pdf_clear_error (&error);
      return;
    @}
  printf ("correctly opened the file for reading\n");

  if (!pdf_fsys_file_reopen (f,
                             PDF_FSYS_OPEN_MODE_WRITE,
                             &error))
    @{
      printf ("couldn't open the file for writing: '%s'\n",
              error ? pdf_error_get_message (error) : "unknown error");
      pdf_clear_error (&error);
      return;
    @}
  printf ("correctly opened the file for writing\n");

  if (!pdf_fsys_file_reopen (f,
                             PDF_FSYS_OPEN_MODE_RW,
                             &error))
    @{
      printf ("couldn't open the file for reading and writing: '%s'\n",
              error ? pdf_error_get_message (error) : "unknown error");
      pdf_clear_error (&error);
      return;
    @}
  printf ("correctly opened the file for reading and writing\n");

  if (!pdf_fsys_file_close (f, &error))
    @{
      printf ("error closing the file: '%s'\n",
              error ? pdf_error_get_message (error) : "unknown error");
      pdf_clear_error (&error);
    @}
@}

@end example
@end table
@end deftypefun


@node File Properties Management
@subsubsection File Properties Management

The following functions provides access to several properties of open
files.

@deftypefun pdf_off_t pdf_fsys_file_get_size (const pdf_fsys_file_t *@var{file}, pdf_error_t **@var{error})

Get the size (in octets) of a given open file.

@table @strong
@item Parameters
@table @var
@item file
An open file.
@item error
A @code{pdf_error_t} to report errors or @code{NULL}.
@table @code
@item PDF_ERROR
Generic error getting file size.
@end table
@end table
@item Returns
A @code{pdf_off_t} with The size of the file in octets, or @code{(pdf_off_t)-1)} on error.
@item Usage example
@example

pdf_off_t
get_file_size (pdf_text_t *path)
@{
  pdf_error_t *error = NULL;
  pdf_fsys_file_t *f;
  pdf_off_t size;

  f = pdf_fsys_file_open (PDF_FSYS_DISK,
                          path,
                          PDF_FSYS_OPEN_MODE_READ,
                          &error);
  if (!f)
    @{
      printf ("couldn't open the file for reading: '%s'\n",
              error ? pdf_error_get_message (error) : "unknown error");
      pdf_clear_error (&error);
      return (pdf_off_t)-1;
    @}

  size = pdf_fsys_file_get_size (f, &error);
  if (size == (pdf_off_t)-1)
    @{
      printf ("couldn't get file size: '%s'\n",
              error ? pdf_error_get_message (error) : "unknown error");
      pdf_clear_error (&error);
    @}

  pdf_fsys_file_close (path, NULL);

  return size;
@}

@end example
@end table
@end deftypefun

@deftypefun {const pdf_fsys_t *}pdf_fsys_file_get_filesystem (const pdf_fsys_file_t *@var{file})

Get the filesystem associated with a given open file.

@table @strong
@item Parameters
@table @var
@item file
An open file.
@end table
@item Returns
The filesystem associated with @var{file}.
@item Usage example
@example

pdf_fsys_file_t *f;

f = pdf_fsys_file_open (PDF_FSYS_DISK,
                        path,
                        PDF_FSYS_OPEN_MODE_READ,
                        NULL);

if (f &&
    pdf_fsys_file_get_filesystem (f) != PDF_FSYS_DISK)
  @{
    printf ("this should never happen...\n");
  @}

@end example
@end table
@end deftypefun

@deftypefun {enum pdf_fsys_file_mode_e} pdf_fsys_file_get_mode (const pdf_fsys_file_t *@var{file})

Return the access mode used to open a given file.

@table @strong
@item Parameters
@table @var
@item file
An open file.
@end table
@item Returns
A @code{enum pdf_fsys_file_mode_e} mode value.
@item Usage example
@example

void
print_used_mode (const pdf_fsys_file_t *file)
@{
  switch (pdf_fsys_file_get_mode (file))
    @{
    case PDF_FSYS_OPEN_MODE_READ:
      printf ("file was opened for reading\n");
      break;
    case PDF_FSYS_OPEN_MODE_WRITE:
      printf ("file was opened for writing\n");
      break;
    case PDF_FSYS_OPEN_MODE_RW:
      printf ("file was opened for reading and writing\n");
      break;
    default:
      printf ("unknown file open mode\n");
      break;
    @}
@}

@end example
@end table
@end deftypefun

@deftypefun pdf_bool_t pdf_fsys_file_set_mode (pdf_fsys_file_t *@var{file}, enum pdf_fsys_file_mode_e @var{new_mode}, pdf_error_t **@var{error})

Update the mode of a given open file, reopening it if needed.

@table @strong
@item Parameters
@table @var
@item file
An open file.
@item new_mode
The new mode to set for the file.
@item error
A @code{pdf_error_t} to report errors or @code{NULL}.
@table @code
@item PDF_EBADDATA
The mode provided was invalid.
@item PDF_ERROR
General failure, most applicable to Win32.
@end table
@end table
@item Returns
@code{PDF_TRUE} if successful, @code{PDF_FALSE} otherwise.
@item Usage example
@example

void
print_file_set_modes (pdf_text_t *path)
@{
  pdf_error_t *error = NULL;
  pdf_fsys_file_t *f;

  f = pdf_fsys_file_open (PDF_FSYS_DISK,
                          path,
                          PDF_FSYS_OPEN_MODE_READ,
                          &error);
  if (!f)
    @{
      printf ("couldn't open the file for reading: '%s'\n",
              error ? pdf_error_get_message (error) : "unknown error");
      pdf_clear_error (&error);
      return;
    @}
  printf ("correctly opened the file for reading\n");

  if (!pdf_fsys_file_set_mode (f,
                               PDF_FSYS_OPEN_MODE_WRITE,
                               &error))
    @{
      printf ("couldn't set mode to writing: '%s'\n",
              error ? pdf_error_get_message (error) : "unknown error");
      pdf_clear_error (&error);
      return;
    @}
  printf ("correctly set the mode to writing\n");

  if (!pdf_fsys_file_set_mode (f,
                               PDF_FSYS_OPEN_MODE_RW,
                               &error))
    @{
      printf ("couldn't set the mode for reading and writing: '%s'\n",
              error ? pdf_error_get_message (error) : "unknown error");
      pdf_clear_error (&error);
      return;
    @}
  printf ("correctly set the mode for reading and writing\n");

  if (!pdf_fsys_file_close (f, &error))
    @{
      printf ("error closing the file: '%s'\n",
              error ? pdf_error_get_message (error) : "unknown error");
      pdf_clear_error (&error);
    @}
@}

@end example
@end table
@end deftypefun

@node Comparing Files
@subsubsection Comparing Files

The following functions allow to compare files.

@deftypefun pdf_bool_t pdf_fsys_file_same_p (const pdf_fsys_file_t *@var{file}, pdf_text_t *@var{path}, pdf_error_t **@var{error})

Determine whether a given open file is the same file as a given file
identified by a file path.

@table @strong
@item Parameters
@table @var
@item file
An open file.
@item path
A file path.
@item error
A @code{pdf_error_t} to report errors or @code{NULL}.
@table @code
@item PDF_EBADDATA
Invalid input path given.
@item PDF_ERROR
Generic error when comparing file paths.
@end table
@end table
@item Returns
@code{PDF_TRUE} if both @var{file} and @var{path} refer to the same file, @code{PDF_FALSE} otherwise. On error, @code{PDF_FALSE} is also returned and @var{error} is set accordingly.
@item Usage example
@example

pdf_bool_t
is_our_predefined_file (const pdf_fsys_file_t *file)
@{
  static const pdf_char_t *predefined_file_path_utf8 = "path/to/baz";
  static pdf_text_t *predefined_file_path = NULL;

  if (!predefined_file_path)
    @{
      pdf_error_t *error = NULL;

      predefined_file_path =  pdf_text_new_from_unicode (predefined_file_path_utf8,
                                                         strlen (predefined_file_path_utf8),
                                                         PDF_TEXT_UTF8,
                                                         &error);
     if (!predefined_file_path)
       @{
         printf ("couldn't build predefined file path: '%s'\n",
                 error ? pdf_error_get_message (error) : "unknown error");
         pdf_clear_error (&error);
         return PDF_FALSE;
       @}
    @}

  return pdf_fsys_file_same_p (file, predefined_file_path, NULL);
@}
@end example
@end table
@end deftypefun

@node Managing File Positions
@subsubsection Managing File Positions

The following functions allow to move the input/output pointer of a
buffer file (its ``current position'').

@deftypefun pdf_off_t pdf_fsys_file_get_pos (const pdf_fsys_file_t *@var{file}, pdf_error_t **@var{error})

Get the current position (in octets) in a given open file.
Position is given always with respect to the beginning of the file.

@table @strong
@item Parameters
@table @var
@item file
An open file.
@item error
A @code{pdf_error_t} to report errors or @code{NULL}.
@table @code
@item PDF_ERROR
Generic error.
@end table
@end table
@item Returns
The current position, or @code{(pdf_off_t)-1)} on error.
@item Usage example
@example

void
print_current_file_position (const pdf_fsys_file_t *file)
@{
  pdf_error_t *error = NULL;
  pdf_off_t pos;

  pos = pdf_fsys_file_get_pos (file, &error);
  if (pos == (pdf_off_t)-1)
    @{
      printf ("couldn't get file position: '%s'\n",
              error ? pdf_error_get_message (error) : "unknown error");
      pdf_clear_error (&error);
    @}
  else
    @{
      printf ("current file position: '%lu'\n",
              (unsigned long)pos);
    @}
@}

@end example
@end table
@end deftypefun

@deftypefun pdf_bool_t pdf_fsys_file_set_pos (pdf_fsys_file_t *@var{file}, pdf_off_t @var{new_pos}, pdf_error_t **@var{error})

Set the current position in a given open file.
Position is given always with respect to the beginning of the file.

@table @strong
@item Parameters
@table @var
@item file
An open file.
@item new_pos
The new position of the file.
@item error
A @code{pdf_error_t} to report errors or @code{NULL}.
@table @code
@item PDF_EBADDATA
Invalid new position.
@item PDF_EBADPERMS
The client does not have enough permissions to change the current file position.
@item PDF_ERROR
Generic error.
@end table
@end table
@item Returns
@code{PDF_TRUE} if successful, @code{PDF_FALSE} otherwise.
@item Usage example
@example

pdf_bool_t
file_rewind (pdf_fsys_file_t *file)
@{
  pdf_error_t *error = NULL;

  if (!pdf_fsys_file_set_pos (pos, 0, &error))
    @{
      printf ("couldn't rewind the file: '%s'\n",
              error ? pdf_error_get_message (error) : "unknown error");
      pdf_clear_error (&error);
      return PDF_FALSE;
    @}

  return PDF_TRUE;
@}

@end example
@end table
@end deftypefun

@node Changing the Size of a File
@subsubsection Changing the Size of a File

@deftypefun pdf_bool_t pdf_fsys_file_can_set_size_p (const pdf_fsys_file_t *@var{file}, pdf_off_t @var{size})

Determine if a given open file is resizeable to a given size.

@table @strong
@item Parameters
@table @var
@item file
An open file.
@item size
The new size for the file in octets.
@end table
@item Returns
@code{PDF_TRUE} if the file can be resized to the given size, @code{PDF_FALSE} otherwise.
@item Usage example
@example

pdf_bool_t
file_can_truncate (const pdf_fsys_file_t *file)
@{
  if (!pdf_fsys_file_can_set_size (pos, 0))
    @{
      printf ("cannot truncate file\n");
      return PDF_FALSE;
    @}

  return PDF_TRUE;
@}

@end example
@end table
@end deftypefun

@deftypefun pdf_bool_t pdf_fsys_file_set_size (pdf_fsys_file_t *@var{file}, pdf_off_t @var{size}, pdf_error_t **@var{error})

Resize a file to a given new size measured in octets.

@table @strong
@item Parameters
@table @var
@item file
An open file.
@item new_size
The new size for the file. If it is bigger than the previous size then
the file is extended to that size. If it is shorter than the previous
size then the file gets truncated.
@item error
A @code{pdf_error_t} to report errors or @code{NULL}.
@table @code
@item PDF_EBADPERMS
The client does not have enough permissions to change the current file size.
@item PDF_ERROR
Generic error.
@end table
@end table
@item Returns
@code{PDF_TRUE} if successful, @code{PDF_FALSE} otherwise.
@item Usage example
@example

pdf_bool_t
file_truncate (pdf_fsys_file_t *file)
@{
  pdf_error_t *error = NULL;

  if (!pdf_fsys_file_set_size (pos, 0, &error))
    @{
      printf ("couldn't truncate the file: '%s'\n",
              error ? pdf_error_get_message (error) : "unknown error");
      pdf_clear_error (&error);
      return PDF_FALSE;
    @}

  return PDF_TRUE;
@}

@end example
@end table
@end deftypefun


@node Synchronous Input/Output
@subsubsection Synchronous Input/Output

The following functions provides synchronous input/output for open
files.


@deftypefun pdf_bool_t pdf_fsys_file_read (pdf_fsys_file_t *@var{file}, pdf_char_t *@var{buf}, pdf_size_t @var{bytes}, pdf_size_t *@var{read_bytes}, pdf_error_t **@var{error})

Synchronously read data from an open file item.

@table @strong
@item Parameters
@table @var
@item file
An open file.
@item buf
The buffer to hold the read data.
@item bytes
The number of octets to read.
@item read_bytes
The number of octets actually read in the operation.
This may be less than @var{bytes} on EOF or error.
@item error
A @code{pdf_error_t} to report errors or @code{NULL}.
@table @code
@item PDF_EBADDATA
The file element or a given pointer is invalid.
@item PDF_ERROR
An error prevented to read the requested octets.
@end table
@end table
@item Returns
@code{PDF_TRUE} if all @var{bytes} were successfully read.
If end of file is reached, @code{PDF_FALSE} is returned.
On error, @code{PDF_FALSE} is returned and @code{error} is set accordingly.
@item Usage example
@example

void
print_text_file_contents (pdf_fsys_file_t *file)
@{
  pdf_error_t *error = NULL;
  pdf_char_t buffer[1025];
  pdf_bool_t eof = PDF_FALSE;

  while (!eof)
    @{
      pdf_size_t read_bytes = 0;

      if (!pdf_fsys_file_read (file,
                               buffer,
                               1024,
                               &read_bytes,
                               &error))
        @{
          if (!error)
            eof = PDF_TRUE;
          else
            @{
              printf ("error reading from file: %s",
                      pdf_error_get_message (error));
              pdf_error_destroy (error);
              return;
            @}
        @}

      if (read_bytes > 0)
        @{
          buffer[read_bytes] = '\0';
          printf ("content: '%s'\n", buffer);
        @}
    @}

  printf ("done.\n");
@}

@end example
@end table
@end deftypefun


@deftypefun pdf_bool_t pdf_fsys_file_write (pdf_fsys_file_t *@var{file}, const pdf_char_t *@var{buf}, pdf_size_t @var{bytes}, pdf_size_t *@var{written_bytes}, pdf_error_t **@var{error})

Synchronously write data to an open file item.

@table @strong
@item Parameters
@table @var
@item file
An open file.
@item buf
A pointer to memory containing the data to write into the file.
@item bytes
The number of octets to write.
@item written_bytes
The number of octets actually written.
This may be less than @var{bytes} on EOF or error.
@item error
A @code{pdf_error_t} to report errors or @code{NULL}.
@table @code
@item PDF_EBADDATA
The file element or a given pointer is invalid.
@item PDF_ENOMEM
A disk full condition ocurred.
@item PDF_ERROR
An error prevented to write the octets.
@end table
@end table
@item Returns
@code{PDF_TRUE} if all @var{bytes} were successfully written.
On error, @code{PDF_FALSE} is returned and @code{error} is set accordingly.
@item Usage example
@example

pdf_bool_t
copy_file (const pdf_text_t *ifile_path, const pdf_text_t *ofile_path)
@{
  pdf_error_t *error = NULL;
  pdf_fsys_file_t *ifile;
  pdf_fsys_file_t *ofile;
  pdf_bool_t eof = PDF_FALSE;
#define BUFFER_SIZE 1024
  pdf_char_t buffer [BUFFER_SIZE];

  /* Open the input file for reading */
  ifile = pdf_fsys_file_open (PDF_FSYS_DISK,
                              ifile_path,
                              PDF_FSYS_OPEN_MODE_READ,
                              &error);
  if (!ifile)
    @{
      printf ("couldn't open file for reading: %s",
              error ? pdf_error_get_message (error) : "unknown error");
      pdf_clear_error (&error);
      return PDF_FALSE;
    @}

  /* Open the output file for writing */
  ofile = pdf_fsys_file_open (PDF_FSYS_DISK,
                              ofile_path
                              PDF_FSYS_OPEN_MODE_WRITE,
                              &error);
  if (!ofile)
    @{
      printf ("couldn't open file for writing: %s",
              error ? pdf_error_get_message (error) : "unknown error");
      pdf_clear_error (&error);
      return PDF_FALSE;
    @}

  while (!eof)
    @{
      pdf_size_t read_bytes = 0;

      if (!pdf_fsys_file_read (ifile,
                               buffer,
                               BUFFER_SIZE,
                               &read_bytes,
                               &error))
        @{
          if (!error)
            eof = PDF_TRUE;
          else
            @{
              printf ("error reading from file: %s",
                      pdf_error_get_message (error));
              pdf_error_destroy (error);
              return PDF_FALSE;
            @}
        @}

      if (read_bytes > 0)
        @{
          pdf_size_t written_bytes = 0;

          if (!pdf_fsys_file_write (ofile,
                                    buffer,
                                    read_bytes,
                                    &written_bytes,
                                    &error) &&
              error)
            @{
              printf ("error writing to file: %s",
                      pdf_error_get_message (error));
              pdf_error_destroy (error);
              return;
            @}
        @}
    @}

  pdf_fsys_file_close (ifile, NULL);
  pdf_fsys_file_close (ofile, NULL);
@}

@end example
@end table
@end deftypefun


@deftypefun pdf_bool_t pdf_fsys_file_flush (pdf_fsys_file_t *@var{file}, pdf_error_t **@var{error})

Flush all the written data for the specified file.

@table @strong
@item Parameters
@table @var
@item file
An open file variable.
@item error
A @code{pdf_error_t} to report errors or @code{NULL}.
@table @code
@item PDF_EBADDATA
Bad function parameters to underlying @code{write()}.
@item PDF_EAGAIN
Try again.
@item PDF_ERROR
There was an error flushing the open file.
@end table
@end table
@item Returns
@code{PDF_TRUE} if successful, @code{PDF_FALSE} otherwise.
@item Usage example
@example

pdf_bool_t
write_timestamp_file (const pdf_text_t *path)
@{
  pdf_error_t *error = NULL;
  pdf_fsys_file_t *file;
  pdf_size_t written_bytes = 0;
  pdf_char_t *timestamp;
  pdf_time_t now;

  /* Get timestamp string */
  pdf_time_set_to_current_utc_time (&now);
  timestamp = pdf_time_to_string (&now,
                                  PDF_TIME_STRING_FORMAT_ISO_8601,
                                  PDF_TIME_STRING_NO_OPTION,
                                  &error);
  if (!timestamp)
    @{
      printf ("couldn't get timestamp: '%s'\n",
              error ? pdf_error_get_message (error) : "unknown error");
      pdf_clear_error (&error);
      return PDF_FALSE;
    @}

  /* Open the output file for writing */
  file = pdf_fsys_file_open (PDF_FSYS_DISK,
                             path
                             PDF_FSYS_OPEN_MODE_WRITE,
                             &error);
  if (!file)
    @{
      printf ("couldn't open file for writing: %s",
              error ? pdf_error_get_message (error) : "unknown error");
      pdf_clear_error (&error);
      pdf_dealloc (timestamp);
      return PDF_FALSE;
    @}

  if (!pdf_fsys_file_write (file,
                            timestamp,
                            strlen (timestamp),
                            &written_bytes,
                            &error) &&
      error)
    @{
      printf ("error writing to file: %s",
              pdf_error_get_message (error));
      pdf_error_destroy (error);
      pdf_dealloc (timestamp);
      pdf_fsys_file_close (file, NULL);
      return PDF_FALSE;
    @}

  /* Flush the bytes. This action just here is completely
   * useless, as the flushing will anyway be done once the
   * file gets closed. Useful only when we want to detect
   * errors happening exactly on the flushing operation.
   */
  if (!pdf_fsys_file_flush (file, &error))
    @{
      printf ("couldn't flush the data: %s",
              error ? pdf_error_get_message (error) : "unknown error");
      pdf_clear_error (&error);
      pdf_dealloc (timestamp);
      pdf_fsys_file_close (file, NULL);
      return PDF_FALSE;
    @}

  pdf_dealloc (timestamp);
  pdf_fsys_file_close (file, NULL);
  return PDF_TRUE;
@}

@end example
@end table
@end deftypefun

@node Read in Advance
@subsubsection Read in Advance

When working with slow filesystems (such as network filesystems) it is
useful to be able to request parts of the file in advance.

@deftypefun pdf_status_t pdf_fsys_file_request_ria (pdf_fsys_file_t @var{file}, pdf_off_t @var{offset}, pdf_size_t @var{count})

Request a Read-In-Advance operation in a given open file.

Note that it is up to the underlying filesystem to honour the
operation. If the filesystem does not implement RIA capabilities then
this function is a no-op.

@table @strong
@item Parameters
@table @var
@item file
An open file.
@item offset
The beginning of the requested block.
@item count
The size (in octets) of the requested block.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The operation succeeded.
@item PDF_ERROR
An error occurred.
@end table
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@deftypefun pdf_bool_t pdf_fsys_file_has_ria (pdf_fsys_file_t @var{file})

Determine whether the filesystem is performing some RIA operation for
the given open file.

Note that it is up to the underlying filesystem to honour the
operation. If the filesystem does not implement RIA capabilities then
this function always return @code{PDF_FALSE}.

@table @strong
@item Parameters
@table @var
@item file
An open file.
@end table
@item Returns
A PDF boolean value:
@table @code
@item PDF_TRUE
The filesystem is performing some RIA operation in the given file.
@item PDF_FALSE
There is not an outstanding RIA operation in the given file.
@end table
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_fsys_file_cancel_ria (pdf_fsys_file_t @var{file})

Cancel any pending RIA operation in a given open file.

Note that it is up to the underlying filesystem to honour the
operation. If the filesystem does not implement RIA capabilities then
this function is a no-op.

@table @strong
@item Parameters
@table @var
@item file
An open file.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
Any pending RIA operation was cancelled.
@end table
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun


@node The Filesystem Implementation Interface
@subsection The Filesystem Implementation Interface

The filesystem implementation interface is a set of functions that are
installed in a @code{pdf_fsys_t} variable in order to provide its
functionality. By implementing those functions the client can provide
a filesystem for some (physical or logical) storage device: a webdav
directory, a read-only http filesystem, etc.

Note that the functions conforming the Implementation Interface are
not intended to be directly invoked by clients. Clients can access to
the functionality of the filesystem using indirect ways:

@itemize @bullet
@item
Making calls to the Filesystem Interface.
@item
Making calls to the File Interface.
@end itemize

The implementation of both interfaces then makes use of the Filesystem
Implementation Interface in order to honour the petition.

@menu
* File System Interface Implementation::
* File Interface Implementation::
@end menu

@node File System Interface Implementation
@subsubsection File System Interface Implementation

@deftp {Data Type} {pdf_status_t (*pdf_fsys_init_fn_t) (void **@var{data})}

Filesystem callback called to initialize the filesystem internal
state, if any.

This callback is called by the @code{pdf_fsys_create} function.
@end deftp

@deftp {Data Type} {pdf_status_t (*pdf_fsys_cleanup_fn_t) (void *@var{data})}

Filesystem callback called to cleanup the filesystem internal state,
if any.

This callback is called by the @code{pdf_fsys_destroy} function.
@end deftp

@deftp {Data Type} {pdf_status_t (*pdf_fsys_file_open_fn_t) (pdf_text_t @var{path}, enum pdf_fsys_file_mode_e @var{mode}, pdf_fsys_file_t *@var{file})}

Filesystem callback called to open a file identified by the path
@var{path} in the mode specified by @var{mode}. A new
@code{pdf_fsys_file_t} is created and stored in @var{file}.

This callback is called by the @code{pdf_file_fsys_open} filesystem
interface function.
@end deftp

@deftp {Data Type} {pdf_status_t (*pdf_fsys_file_open_tmp_fn_t) (pdf_fsys_file_t *@var{file})}

Filesystem callback called to create a temporary file, to open it in
read/write mode and to store it in @var{file}.

This callback is called by the @code{pdf_fsys_file_open_tmp} filesystem
interface function.
@end deftp

@deftp {Data Type} {pdf_status_t (*pdf_fsys_close_fn_t) (pdf_fsys_file_t @var{file})}

Filesystem callback used to close a given file identified by the
open file variable @var{file}. The output buffers of the file are
flushed before to close it.

This callback is called by the @code{pdf_fsys_close} filesystem
interface function.
@end deftp

The following callbacks are defined to provide folder management:
creation, deletion and modification of folders in the filesystem and
retrieval of folder contents.

@deftp {Data Type} {pdf_status_t (*pdf_fsys_create_folder_fn_t) (pdf_text_t @var{path})}

Filesystem callback used to create a folder identified by the
@var{path} path.

This callback is called by the @code{pdf_fsys_create_folder}
filesystem interface function.
@end deftp

@deftp {Data Type} {pdf_status_t (*pdf_fsys_get_folder_contents_fn_t) (pdf_text_t @var{path}, pdf_list_t @var{item_list})}

Filesystem callback used to get the contents of a specified folder as
a list of paths.

This callback is called by the @code{pdf_fsys_get_folder_contents}
filesystem interface function.
@end deftp

@deftp {Data Type} {pdf_status_t (*pdf_fsys_get_parent_fn_t) (pdf_text_t @var{path}, pdf_text_t @var{parent_path})}

Filesystem callback used to get the path of the father of a given
item in a filesystem. If @var{path} is the root directory then
NULL is returned in @var{parent_path}.

This callback is called by the @code{pdf_fsys_get_parent} filesystem
interface function.
@end deftp

@deftp {Data Type} {pdf_status_t (*pdf_fsys_remove_folder_fn_t) (pdf_text_t @var{path})}

Filesystem callback used to remove an empty folder identified by
@var{path}.

This callback is called by the @code{pdf_fsys_remove_folder}
filesystem interface function.
@end deftp

The following callbacks are defined to provide synchronous
input/output in open files.


@deftp {Data Type} {pdf_status_t (*pdf_fsys_file_read_fn_t) (pdf_fsys_file_t @var{file}, pdf_char_t*@var{buf}, pdf_size_t @var{bytes}, pdf_size_t*@var{read_bytes})}

Filesystem callback used to synchronously read data from an open file
item.

This callback is called by the @code{pdf_fsys_file_read} file
interface function.
@end deftp

@deftp {Data Type} {pdf_status_t (*pdf_fsys_file_write_fn_t) (pdf_fsys_file_t @var{file}, pdf_char_t*@var{buf}, pdf_size_t @var{bytes}, pdf_size_t*@var{written_bytes})}
Filesystem callback used to synchronously write data to an open file
item.

This callback is called by the @code{pdf_fsys_file_write} file
interface function.
@end deftp

@deftp {Data Type} {pdf_status_t (*pdf_fsys_file_flush_fn_t) (pdf_fsys_file_t @var{file})}

Filesystem callback used to flush all the written data for the
specified file.

This callback is called by the @code{pdf_fsys_file_flush} file
interface function.
@end deftp

The following callbacks are defined to provide access to several
filesystem item properties. The file system items are addressed using
paths.

@deftp {Data Type} {pdf_status_t (*pdf_fsys_get_item_props_fn_t) (pdf_text_t @var{path}, struct pdf_fsys_item_props_s *@var{props})}

Filesystem callback used to get the properties of a named filesystem
item.

This callback is called by the @code{pdf_fsys_get_item_props}
filesystem interface function.
@end deftp

@deftp {Data Type} {pdf_i64_t (*pdf_fsys_get_free_space_fn_t) (pdf_text_t @var{path})}

Filesystem callback used to get the free storage space in the volume
containing @var{path}.

This callback is called by the @code{pdf_fsys_get_free_space} file
system interface function.
@end deftp

@deftp {Data Type} {pdf_bool_t (*pdf_fsys_item_p_fn_t) (pdf_text_t @var{path})}

Filesystem callback used to determine whether a given item,
identified by a path, exists in a given filesystem.

This callback is called by the @code{pdf_fsys_item_p} file system
interface function.
@end deftp

@deftp {Data Type} {pdf_bool_t (*pdf_fsys_item_readable_p_fn_t) (pdf_text_t @var{path})}

Filesystem callback used to determine whether a given filesystem
item, identified by a path, is readable.

This callback is called by the @code{pdf_fsys_item_readable_p}
file system interface function.
@end deftp

@deftp {Data Type} {pdf_bool_t (*pdf_fsys_item_writable_p_fn_t) (pdf_fsys_t @var{filename}, pdf_text_t @var{path})}

Filesystem callback used to determine whether a given filesystem
item, identified by a path, is writeable.

This callback is called by the @code{pdf_fsys_item_writeable_p} file
system interface function.
@end deftp

typedef pdf_status_t (*pdf_fsys_build_path_fn_t) (void * data,
                                                  pdf_text_t * output,
                                                  pdf_text_t first_element,
                                                  pdf_list_t rest);


@deftp {Data Type} {pdf_status_t (*pdf_fsys_build_path_fn_t) (void * @var{data}, pdf_text_t *@var{output}, pdf_text_t @var{first_name}, pdf_list_t @var{rest})}

Filesystem callback used to concatenate and build a file path. Where @var{rest} is a list of pdf_text_t objects.

This callback is called by the @code{pdf_fsys_build_path} file
system interface function.
@end deftp


@node File Interface Implementation
@subsubsection File Interface Implementation

The following callbacks are defined to provide access to several file
properties.

@deftp {Data Type} {pdf_bool_t (*pdf_fsys_file_can_set_size_fn_t) (pdf_fsys_file_t @var{file}, pdf_off_t @var{pos})}

Filesystem callback used to determine if it is possible to set the
size of a given file to an especified value.

The callback should return a PDF bool value specifying if it is
possible to perform the operation.
@end deftp

@deftp {Data Type} {pdf_status_t (*pdf_fsys_file_get_size_fn_t) (pdf_fsys_file_t @var{file}, pdf_off_t *@var{pos})}

Filesystem callback used to get the logical size of a file (in
octets).

The callback should return a PDF status value:
@table @code
@item PDF_OK
The operation was successfully performed and the logical size of the
file was stored in @var{pos}.
@item PDF_BADPERMS
The client does not have enough permissions to get the logical size of
@var{file}.
@end table
@end deftp

@deftp {Data Type} {pdf_status_t (*pdf_fsys_file_set_size_fn_t) (pdf_fsys_file_t @var{file}, pdf_off_t @var{pos})}

Filesystem callback used to set the logical size of a file (in
octets).

The callback should return a PDF status value:
@table @code
@item PDF_OK
The operation was successfully performed and the logical size of the
file was changed.
@item PDF_BADPERMS
The client does not have enough permissions to set the logical size of
@var{file}.
@end table
@end deftp

@deftp {Data Type} {pdf_status_t (*pdf_fsys_file_get_pos_fn_t) (pdf_fsys_file_t @var{file}, pdf_off_t *@var{pos})}

Filesystem callback used to get the current position in a given file.

The callback should return a PDF status variable:
@table @code
@item PDF_OK
The operation was successfully performed and the current position in
@var{file} was stored in @var{pos}.
@end table

This callback is called by the @code{pdf_fsys_file_get_pos} file
interface function.
@end deftp

@deftp {Data Type} {pdf_status_t (*pdf_fsys_file_set_pos_fn_t) (pdf_fsys_file_t @var{file}, pdf_off_t @var{pos})}

Filesystem callback used to set the current position in a given file.

The callback should return a PDF status variable:
@table @code
@item PDF_OK
The operation was successfully performed and the current position in
n@var{file} was set to @var{pos}.
@end table

This callback is called by the @code{pdf_fsys_file_set_pos} file
interface function.
@end deftp

@deftp {Data Type} {enum pdf_fsys_file_mode_e (*pdf_fsys_file_get_mode_fn_t) (pdf_fsys_file_t @var{file})}

Filesystem callback used to get the open mode of a given open file.

This callback is called by the @code{pdf_fsys_file_get_mode} file
interface function.
@end deftp

@deftp {Data Type} {pdf_status_t (*pdf_fsys_file_set_mode_fn_t) (pdf_fsys_file_t @var{file}, enum pdf_fsys_file_mode_e @var{new_mode})}

Filesystem callback used to update the mode of a given open file with
a given set of file modes.

This callback is called by the @code{pdf_fsys_file_set_mode} file
interface function.
@end deftp

@deftp {Data Type} {pdf_text_t (*pdf_fsys_file_get_url_fn_t) (pdf_fsys_file_t @var{file})}

Filesystem callback used to get a URL pointing to a given open file.

This callback is called by the @code{pdf_fsys_file_get_url} file
interface function.
@end deftp

@deftp {Data Type} {pdf_bool_t (*pdf_fsys_file_same_p_fn_t) (pdf_fsys_file_t @var{file}, pdf_text_t @var{path})}

Filesystem callback used to determine whether a given open file is the
same file as a given file identified by a file path.

This callback is called by the @code{pdf_fsys_file_same_p} file
interface function.
@end deftp

@deftp {Data Type} {pdf_status_t (*pdf_fsys_file_request_ria_fn_t) (pdf_fsys_file_t @var{file}, pdf_off_t @var{offset}, pdf_size_t @var{count})}

Filesystem callback used to request a Read-In-Advance operation in a
given open file.

This callback is called by the @code{pdf_fsys_file_request_ria} file
interface function.
@end deftp

@deftp {Data Type} {pdf_bool_t (*pdf_fsys_file_has_ria_fn_t) (pdf_fsys_file_t @var{file})}

Filesystem callback used to determine whether the filesystem is
performing some RIA operation for the given open file.

This callback is called by the @code{pdf_fsys_file_has_ria} file
interface function.
@end deftp

@deftp {Data Type} {pdf_status_t (*pdf_fsys_file_cancel_ria_fn_t) (pdf_fsys_file_t @var{file})}

Filesystem callback used to cancel any pending RIA operation in a
given open file.

This callback is called by the @code{pdf_fsys_file_cancel_ria} file
interface function.
@end deftp

@deftp {Data Type} {pdf_status_t (*pdf_fsys_file_close_fn_t) (pdf_fsys_file_t @var{file})}

Filesystem callback used to close a given open file.

This callback is called by the @code{pdf_fsys_file_close} file
interface function.
@end deftp

@deftp {Data Type} {pdf_status_t (*pdf_fsys_file_reopen_fn_t) (pdf_fsys_file_t @var{file}, enum pdf_fsys_file_mode_e @var{mode})}

Filesystem callback used to reopen a given open file with a
given mode.

This callback is called by the @code{pdf_fsys_file_reopen} file
interface function.
@end deftp

@node The Filesystem Definition Interface
@subsection The Filesystem Definition Interface

The Filesystem Definition Interface is implemented by the Filesystem
module and provides functionality to provide an implementation of a
filesystem. A @code{pdf_fsys_t} should be properly defined before to
use it.

The Filesystem Definition Interface defines the following elements:

@itemize @bullet
@item
The function types conforming the Filesystem Implementation Interface.
@item
Installation functions to register implementation functions into a
filesystem variable.
@end itemize

@menu
* File System Definition Data Types::
* File System Definition Functions::
@end menu

@node File System Definition Data Types
@subsubsection File System Definition Data Types

@deftp {Data Type} struct pdf_fsys_impl_s

Structure containing the callbacks to a concrete file system
implementation.

The members of the structure are the following:

@table @code
@item pdf_fsys_init_fn init_fn
@item pdf_fsys_cleanup_fn cleanup_fn
@item pdf_fsys_open_fn_t open_fn
@item pdf_fsys_close_fn_t c close_fn
@item pdf_fsys_create_folder_fn_t create_folder_fn
@item pdf_fsys_get_folder_contents_fn_t get_folder_contents_fn
@item pdf_fsys_get_parent_fn_t get_parent_fn
@item pdf_fsys_remove_folder_fn_t remove_folder_fn
@item pdf_fsys_file_read_fn_t file_read_fn
@item pdf_fsys_file_write_fn_t file_write_fn
@item pdf_fsys_file_flush_fn_t fiile_flush_fn
@item pdf_fsys_get_item_props_fn_t get_item_props_fn
@item pdf_fsys_get_free_space_fn_t get_free_space_fn
@item pdf_fsys_item_p_fn_t item_p_fn
@item pdf_fsys_item_readable_p_fn_t item_readable_p_fn
@item pdf_fsys_item_writable_p_fn_t item_writable_p_fn
@item pdf_fsys_get_temp_path_fn_t get_temp_path_fn
@item pdf_fsys_file_can_set_size_fn_t file_can_set_size_fn
@item pdf_fsys_file_get_size_fn_t file_get_size_fn
@item pdf_fsys_file_set_size_fn_t file_set_size_fn
@item pdf_fsys_file_get_pos_fn_t file_get_pos_fn
@item pdf_fsys_file_set_pos_fn_t file_set_pos_fn
@item pdf_fsys_file_get_mode_fn_t file_get_mode_fn
@item pdf_fsys_file_set_mode_fn_t file_set_mode_fn
@item pdf_fsys_file_get_url_fn_t file_get_url_fn
@item pdf_fsys_file_same_p_fn_t file_same_p_fn
@item pdf_fsys_file_request_ria_fn_t file_request_ria_fn
@item pdf_fsys_file_has_ria_fn_t file_has_ria_fn
@item pdf_fsys_file_cancel_ria_fn_t file_cancel_ria_fn
@item pdf_fsys_file_close_fn_t file_close_fn
@item pdf_fsys_file_reopen_fn_t file_reopen_fn
@end table
@end deftp

@node File System Definition Functions
@subsubsection File System Definition Functions

@deftypefun pdf_fsys_t pdf_fsys_create (struct pdf_fsys_impl_s @var{implementation})

Create and return a new filesystem variable that will use a given
implementation.

@table @strong
@item Parameters
@table @var
@item implementation
A filesystem implementation.
@end table
@item Returns
A fileystem variable.
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_fsys_destroy (pdf_fsys_t @var{filesystem})

Destroy a filesystem freein all used resources.

@table @strong
@item Parameters
@table @var
@item filesystem
A filesystem variable.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The filesystem was successfully destroyed.
@end table
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@node The Tokeniser
@section The Tokeniser

The tokeniser module provides functions to:

@itemize @minus
@item Read PDF lexical tokens from a base layer stream
@item Write PDF lexical tokens into a base layer stream
@end itemize

@menu
* Tokeniser data types::
* Creation and destruction of tokenisers::
* Reading tokens::
* Writing tokens::
* Creating and destroying tokens::
* Accessing token attributes::
@end menu

@node Tokeniser data types
@subsection Tokeniser data types

@deftp {Data Type} pdf_token_t
A PDF token.
@end deftp

@deftp {Data Type} {enum pdf_token_type_e}
The type of a PDF token.

Valid values are:

@table @code
@item PDF_TOKEN_INTEGER
A PDF integer value.
@item PDF_TOKEN_REAL
A PDF real value (a floating-point number).
@item PDF_TOKEN_STRING
A PDF string.
@item PDF_TOKEN_NAME
A PDF name.
@item PDF_TOKEN_COMMENT
A PDF comment.
@item PDF_TOKEN_KEYWORD
A keyword, i.e., any string of regular characters such as ``null''
or ``R'' that is not matched as another type.
@item PDF_TOKEN_DICT_START
The ``<<'' operator, which marks the beginning of a dictionary.
@item PDF_TOKEN_DICT_END
The ``>>'' operator, which marks the end of a dictionary.
@item PDF_TOKEN_ARRAY_START
The ``['' operator, which marks the beginning of an array.
@item PDF_TOKEN_ARRAY_END
The ``]'' operator, which marks the end of an array.
@item PDF_TOKEN_PROC_START
The ``@{'' operator, which marks the beginning of a procedure.
@item PDF_TOKEN_PROC_END
The ``@}'' operator, which marks the end of a procedure.
@end table
@end deftp

@deftp {Data Type} pdf_token_reader_t
A token reader that operates on a reading base layer stream and provides
a stream of PDF tokens.
@end deftp

@deftp {Data Type} pdf_token_writer_t
A token writer that operates on a writing base layer stream,
generating the textual representation of a PDF token.
@end deftp

@node Creation and destruction of tokenisers
@subsection Creation and destruction of tokenisers

@deftypefun pdf_status_t pdf_token_reader_new (pdf_stm_t @var{stm}, pdf_token_reader_t *@var{reader})

Create a new token reader operating a given reading stream.

@table @strong
@item Parameters
@table @var
@item stm
A reading stream.
@item reader
A pointer to a token reader.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The reader was successfully created.
@item PDF_EBADDATA
@var{stm} is not a reading stream.
@item PDF_ENOMEM
Not enough memory to create the reader.
@item PDF_ERROR
An error prevented to perform the operation.
@end table
@item Usage example
@example
pdf_stm_t stream;
pdf_token_reader_t reader;

/* Open a file stream */
XXX

/* Create the token reader */
switch (pdf_token_reader_new (stream, &reader))
@{
   case PDF_BADDATA:
   @{
      /* STREAM is not a valid reading stream */
      break;
   @}
   case PDF_ENOMEM:
   @{
      /* Not enough memory to create the reader */
      break;
   @}
   case PDF_ERROR:
   @{
      /* Some other error prevented the creation of
         the reader */
      break;
   @}
   default:
   @{
      /* Success */
      break;
   @}
@}
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_token_writer_new (pdf_stm_t @var{stm}, pdf_token_writer_t *@var{writer})

Create a new token writer operating a given reading stream.

@table @strong
@item Parameters
@table @var
@item stm
A writing stream.
@item writer
A pointer to a token writer.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The writer was successfully created.
@item PDF_EBADDATA
@var{stm} is not a writing stream.
@item PDF_ENOMEM
Not enough memory to create the writer.
@item PDF_ERROR
An error prevented to perform the operation.
@end table
@item Usage example
@example
pdf_stm_t stream;
pdf_token_writer_t writer;

/* Open a file stream */
XXX

/* Create the token writer */
switch (pdf_token_writer_new (stream, &writer))
@{
   case PDF_BADDATA:
   @{
      /* STREAM is not a valid writing stream */
      break;
   @}
   case PDF_ENOMEM:
   @{
      /* Not enough memory to create the writer */
      break;
   @}
   case PDF_ERROR:
   @{
      /* Any other error prevented the creation of
         the writer */
      break;
   @}
   default:
   @{
      /* Success */
      break;
   @}
@}
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_token_reader_destroy (pdf_token_reader_t @var{reader})

Destroy a token reader freeing any used resources.

@table @strong
@item Parameters
@table @var
@item reader
The reader to destroy.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The token reader was destroyed.
@item PDF_EBADDATA
@var{reader} was NULL.
@end table
@item Usage example
@example
pdf_token_reader_t reader;

/* Create a reader */
XXX
/* Destroy the reader */
pdf_token_reader_destroy (reader);
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_token_writer_destroy (pdf_token_writer_t @var{writer})

Destroy a token writer, freeing any used resources.

@table @strong
@item Parameters
@table @var
@item writer
The writer to destroy.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The token writer was destroyed.
@item PDF_EBADDATA
@var{writer} was NULL.
@end table
@item Usage example
@example
pdf_token_writer_t writer;

/* Create a writer */
XXX
/* Destroy the writer */
pdf_token_writer_destroy (writer);
@end example
@end table
@end deftypefun

@node Reading tokens
@subsection Reading tokens

@deftypefun pdf_status_t pdf_token_read (pdf_token_reader_t @var{reader}, pdf_u32_t @var{flags}, pdf_token_t *@var{token})

Read a token from a token reader.

@table @strong
@item Parameters
@table @var
@item reader
A token reader.
@item flags
A bitmask specifying a combination of these flags:
@table @code
@item PDF_TOKEN_NO_NAME_ESCAPES
Don't treat ``#'' as a special character when reading name tokens
(this flag should be used when reading PDF 1.1 files).
@item PDF_TOKEN_RET_COMMENTS
Return comments as tokens (rather than ignoring them).
@item PDF_TOKEN_END_AT_STREAM
Assume that a ``stream'' keyword token was just read, find the beginning
of the corresponding stream, and return PDF_EEOF when successful
(i.e., when the input stream is positioned after the first line feed).
@end table
@item token
A pointer to a pdf_token_t that will hold the read token.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The operation succeeded.
@item PDF_EAGAIN
It's not possible to read a full token now.
Since one may have been partially read, the operation should be repeated
with the same flags when data becomes available.
@item PDF_EEOF
Reached the end of the input stream (at a valid position).
@item PDF_EBADFILE
The stream violates the PDF specifications.
@item PDF_EIMPLLIMIT
It's not possible to read the next token without exceeding an
implementation limit (e.g., the token is too long).
@item PDF_ERROR
An unspecified error occurred.
@end table
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_token_reader_reset (pdf_token_reader_t @var{reader})

Reset the state of the token reader.

@table @strong
@item Parameters
@table @var
@item reader
A token reader.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The operation succeeded.
@end table
@end table
@end deftypefun

@node Writing tokens
@subsection Writing tokens

@deftypefun pdf_status_t pdf_token_write (pdf_token_writer_t @var{writer}, pdf_u32_t @var{flags}, pdf_token_t @var{token})

Write a given token using a given token writer.

@table @strong
@item Parameters
@table @var
@item writer
A token writer.
@item flags
A bitmask specifying a combination of these flags:
@table @code
@item PDF_TOKEN_NO_NAME_ESCAPES
Don't escape special characters using ``#'' when writing name tokens
(this flag should be used when writing PDF 1.1 files).
@item PDF_TOKEN_HEX_STRINGS
Write strings in hexadecimal encoding.
@item PDF_TOKEN_READABLE_STRINGS
Encode strings in a human-readable way
(i.e., in hexadecimal or with special characters escaped).
@end table
@item token
A PDF token.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The operation succeeded.
@item PDF_EAGAIN
It's not possible to write a full token now.
Since it may have been partially written, the operation must be repeated
with the same arguments when the stream becomes writable.
@item PDF_EBADDATA
One of the arguments is invalid. This may be caused by an invalid token
(e.g., one that contains unrepresentable characters).
@item PDF_ERROR
An unspecified error occurred.
@end table
@item Usage example
@example
XXX
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_token_writer_reset (pdf_token_writer_t @var{writer})

Reset the state of the token writer.

@table @strong
@item Parameters
@table @var
@item reader
A token writer.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The operation succeeded.
@end table
@end table
@end deftypefun

@node Creating and destroying tokens
@subsection Creating and destroying tokens

@deftypefun pdf_status_t pdf_token_integer_new (pdf_i32_t @var{value}, pdf_token_t *@var{token})

Create an integer token.

@table @strong
@item Parameters
@table @var
@item value
The numeric value for the token.
@item token
A pointer to the newly created token.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The operation succeeded.
@item PDF_ENOMEM
Not enough memory.
@end table
@end table

@end deftypefun

@deftypefun pdf_status_t pdf_token_real_new (pdf_real_t @var{value}, pdf_token_t *@var{token})

Create a real (floating-point number) token.

@table @strong
@item Parameters
@table @var
@item value
The numeric value for the token.
@item token
A pointer to the newly created token.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The operation succeeded.
@item PDF_EBADDATA
The given value is invalid.
@item PDF_ENOMEM
Not enough memory.
@end table
@end table

@end deftypefun

@deftypefun pdf_status_t pdf_token_string_new (const pdf_char_t *@var{value}, pdf_size_t @var{size}, pdf_token_t *@var{token})

Create a string token containing a copy of the given data.

@table @strong
@item Parameters
@table @var
@item value
A pointer to the binary data that will make up the string.
@item size
The amount of data to copy, in octets.
@item token
A pointer to the newly created token.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The operation succeeded.
@item PDF_ENOMEM
Not enough memory.
@end table
@end table

@end deftypefun

@deftypefun pdf_status_t pdf_token_name_new (const pdf_char_t *@var{value}, pdf_size_t @var{size}, pdf_token_t *@var{token})

Create a name token containing a copy of the given data.

@table @strong
@item Parameters
@table @var
@item value
A pointer to the binary data that will make up the name.
@item size
The amount of data to copy, in octets.
@item token
A pointer to the newly created token.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The operation succeeded.
@item PDF_EBADDATA
The given value is invalid.
@item PDF_ENOMEM
Not enough memory.
@end table
@end table

@end deftypefun

@deftypefun pdf_status_t pdf_token_keyword_new (const pdf_char_t *@var{value}, pdf_size_t @var{size}, pdf_token_t *@var{token})

Create a keyword token containing a copy of the given data.

@table @strong
@item Parameters
@table @var
@item value
A pointer to the binary data that will make up the keyword.
@item size
The amount of data to copy, in octets.
@item token
A pointer to the newly created token.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The operation succeeded.
@item PDF_EBADDATA
The given value is invalid.
@item PDF_ENOMEM
Not enough memory.
@end table
@end table

@end deftypefun

@deftypefun pdf_status_t pdf_token_comment_new (const pdf_char_t *@var{value}, pdf_size_t @var{size}, pdf_token_t *@var{token})

Create a comment token containing a copy of the given data.

@table @strong
@item Parameters
@table @var
@item value
A pointer to the binary data that will make up the keyword.
@item size
The amount of data to copy, in octets.
@item token
A pointer to the newly created token.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The operation succeeded.
@item PDF_EBADDATA
The given value is invalid.
@item PDF_ENOMEM
Not enough memory.
@end table
@end table

@end deftypefun

@deftypefun pdf_status_t pdf_token_valueless_new (enum pdf_token_type_e @var{type}, pdf_token_t *@var{token})

Create a token of one of the valueless types (PDF_TOKEN_DICT_START,
PDF_TOKEN_DICT_END, PDF_TOKEN_ARRAY_START, PDF_TOKEN_ARRAY_END,
PDF_TOKEN_PROC_START, or PDF_TOKEN_PROC_END).

@table @strong
@item Parameters
@table @var
@item type
The type of token to create.
@item token
A pointer to the newly created token.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The operation succeeded.
@item PDF_ENOMEM
Not enough memory.
@item PDF_EBADDATA
The given type is not valid for this constructor.
@end table
@end table

@end deftypefun

@deftypefun pdf_status_t pdf_token_dup (const pdf_token_t @var{token}, pdf_token_t *@var{new})

Create a copy of the given token.

@table @strong
@item Parameters
@table @var
@item old
The token to copy.
@item new
A pointer to the newly created token.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The operation succeeded.
@item PDF_ENOMEM
Not enough memory.
@end table
@end table

@end deftypefun

@deftypefun pdf_status_t pdf_token_destroy (pdf_token_t @var{token})

Destroy the given token, freeing any memory it used.

@table @strong
@item Parameters
@table @var
@item old
The token to copy.
@item new
A pointer to the newly created token.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The operation succeeded.
@end table
@end table

@end deftypefun

@node Accessing token attributes
@subsection Accessing token attributes

@deftypefun {enum pdf_token_type_e} pdf_token_get_type (const pdf_token_t @var{token})

Get the type of a given token.

@table @strong
@item Parameters
@table @var
@item token
A token.
@end table
@item Returns
The type of the given token.
@item Usage example
@example
pdf_token_t token;
pdf_token_reader_t reader;

/* ... */

/* Read a name */
if (pdf_token_read (reader, &token) != PDF_OK)
@{
   /* Error */
@}
if (pdf_token_get_type (token) != PDF_TOKEN_NAME)
@{
   /* We were expecting a name */
@}
@end example
@end table
@end deftypefun

@deftypefun pdf_bool_t pdf_token_equal_p (const pdf_token_t @var{token1}, const pdf_token_t @var{token2})

Determines whether the given tokens are equivalent.

@table @strong
@item Parameters
@table @var
@item token1
A token.
@item token2
Another token.
@end table
@item Returns
A boolean value:
@table @code
@item PDF_TRUE
The given tokens are equal.
@item PDF_FALSE
The tokens are not equal.
@end table
@end table

@end deftypefun

@deftypefun pdf_i32_t pdf_token_get_integer_value (const pdf_token_t @var{token})

Returns the value associated with a given integer token.

@table @strong
@item Parameters
@table @var
@item token
A token of type PDF_TOKEN_INTEGER.
@end table
@item Returns
The token's value.
@end table

@end deftypefun

@deftypefun pdf_real_t pdf_token_get_real_value (const pdf_token_t @var{token})

Returns the value associated with a given real token.

@table @strong
@item Parameters
@table @var
@item token
A token of type PDF_TOKEN_REAL.
@end table
@item Returns
The token's value.
@end table

@end deftypefun

@deftypefun const pdf_char_t *pdf_token_get_string_data (const pdf_token_t @var{token})

Returns a pointer to the data associated with a given string token.

@table @strong
@item Parameters
@table @var
@item token
A token of type PDF_TOKEN_STRING.
@end table
@item Returns
A pointer to the data, which will be valid until the token is destroyed.
The data is @strong{not} null-terminated.
@end table

@end deftypefun

@deftypefun pdf_size_t pdf_token_get_string_size (const pdf_token_t @var{token})

Returns the amount of data associated with a given string token.

@table @strong
@item Parameters
@table @var
@item token
A token of type PDF_TOKEN_STRING.
@end table
@item Returns
The string's size, in octets.
@end table

@end deftypefun

@deftypefun const pdf_char_t *pdf_token_get_name_data (const pdf_token_t @var{token})

Returns a pointer to the data associated with a given name token.

@table @strong
@item Parameters
@table @var
@item token
A token of type PDF_TOKEN_NAME.
@end table
@item Returns
A pointer to the name data, which will be valid until the token is destroyed.
The data is null-terminated.
@end table

@end deftypefun

@deftypefun pdf_size_t pdf_token_get_name_size (const pdf_token_t @var{token})

Returns the amount of data associated with a given name token.

@table @strong
@item Parameters
@table @var
@item token
A token of type PDF_TOKEN_NAME.
@end table
@item Returns
The name's size, in octets (excluding the terminating null byte).
@end table

@end deftypefun

@deftypefun const pdf_char_t *pdf_token_get_keyword_data (const pdf_token_t @var{token})

Returns a pointer to the data associated with a given keyword token.

@table @strong
@item Parameters
@table @var
@item token
A token of type PDF_TOKEN_KEYWORD.
@end table
@item Returns
A pointer to the data, which will be valid until the token is destroyed.
The data is null-terminated.
@end table

@end deftypefun

@deftypefun pdf_size_t pdf_token_get_keyword_size (const pdf_token_t @var{token})

Returns the amount of data associated with a given keyword token.

@table @strong
@item Parameters
@table @var
@item token
A token of type PDF_TOKEN_KEYWORD.
@end table
@item Returns
The keyword's size, in octets (excluding the terminating null byte).
@end table

@end deftypefun

@deftypefun const pdf_char_t *pdf_token_get_comment_data (const pdf_token_t @var{token})

Returns a pointer to the data associated with a given comment token.

@table @strong
@item Parameters
@table @var
@item token
A token of type PDF_TOKEN_COMMENT.
@end table
@item Returns
A pointer to the data, which will be valid until the token is destroyed.
The data is @strong{not} null-terminated.
@end table

@end deftypefun

@deftypefun pdf_size_t pdf_token_get_comment_size (const pdf_token_t @var{token})

Returns the amount of data associated with a given comment token.

@table @strong
@item Parameters
@table @var
@item token
A token of type PDF_TOKEN_COMMENT.
@end table
@item Returns
The comment's size, in octets.
@end table

@end deftypefun

@node Encryption
@section Encryption

This section describes related to encryption functions.

@menu
* Creating and destroying Ciphers::
* Encryption and decryption::
* Message digest functions::
* Utilities::
@end menu


@node Creating and destroying Ciphers
@subsection Creating and destroying Ciphers

@deftp {Data Type} {enum pdf_crypt_cipher_algo_e}
An algorithm provided. It contains low level functions of the algorithm
implementation.

@table @code
@item PDF_CRYPT_CIPHER_ALGO_AESV2
Use AES algorithm with a key of 128 bits to encrypt the data.
@item PDF_CRYPT_CIPHER_ALGO_V2
Use ARC4 algorithm.
@end table
@end deftp

@deftp {Data Type} {pdf_crypt_cipher_t}
A cipher. It contains data which is required between several calls to
functions.
@end deftp

@deftypefun pdf_status_t pdf_crypt_cipher_new (enum pdf_crypt_cipher_algo_e @var{algorithm}, pdf_crypt_cipher_t *@var{cipher})

Create a new cipher.

@table @strong
@item Parameters
@table @var
@item algorithm
The algorithm the cipher will use in order to encrypt or decrypt data.
@item cipher
A pointer to @code{pdf_crypt_cipher_t} variable where it will put the cipher.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
Operation successful
@item PDF_ERROR
A error ocurred when trying to create the cipher.
@end table
@item Usage example
@example
pdf_status_t st;
pdf_crypt_cipher_t cipher;

st = pdf_crypt_cipher_new (PDF_CRYPT_CIPHER_ALG_AESV2, &cipher);

if (st != PDF_OK)
@{
   /* Error */
@}
@end example
@end table
@end deftypefun


@deftypefun pdf_status_t pdf_crypt_cipher_destroy (pdf_crypt_cipher_t @var{cipher})

Destroy a cipher.

@table @strong
@item Parameters
@table @var
@item cipher
The cipher you want destroy. It must have been created with
@code{pdf_crypt_cipher_new} functions previously.
@end table
@item Returns
@table @code
A PDF status value:
@item PDF_OK
Operation successful
@item PDF_ERROR
A error ocurred when trying to destroy the cipher.
@end table
@item Usage example
@example
pdf_crypt_cipher_t cipher;
pdf_crypt_cipher_new (PDF_CRYPT_CIPHER_ALG_AESV2, &cipher);
pdf_crypt_cipher_destroy (cipher);
@end example
@end table
@end deftypefun


@node Encryption and decryption
@subsection Encryption and decryption

@deftypefun pdf_status_t pdf_crypt_cipher_setkey (pdf_crypt_cipher_t @var{cipher}, pdf_char_t  *@var{key}, pdf_size_t @var{size})

Set the key which will be used to encrypt and decrypt data.

@table @strong
@item Parameters
@table @var
@item cipher
A pointer to a cipher created previously.
@item key
A pointer to memory where the key is stored.
@item size
The length of the key in octets. Note that some algorithms could require
a fixed length of key.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
Operation successful
@item PDF_EBADDATA
Invalid argument. The @var{size} parameter is not supported by the
cipher.
@item PDF_ERROR
A error ocurred while trying to set the key.
@end table
@item Usage example
@example
pdf_status_t st;
pdf_crypt_cipher_t cipher;
pdf_char_t key[16];

/* ... */
st = pdf_crypt_cipher_setkey (&cipher, key, sizeof(key));

if (st != PDF_OK)
@{
   /* Error */
@}
@end example
@end table
@end deftypefun


@deftypefun pdf_status_t pdf_crypt_cipher_encrypt (pdf_crypt_cipher_t @var{cipher}, pdf_char_t  *@var{out}, pdf_size_t  @var{out_size}, pdf_char_t  *@var{in}, pdf_size_t  @var{in_size}, pdf_size_t *@var{result_size})

Encrypt a buffer. The ciphered text will be put in @var{out}.

@table @strong
@item Parameters
@table @var
@item cipher
A cipher.
@item out
A pointer to the output buffer.
@item out_size
Size reserved for the output buffer in octets. The function will fail if
it is not too large to contain the output.
@item in
A pointer to input buffer.
@item in_size
The length of the input buffer in octets. I must be greater than
zero. Some algorithms requires than IN_SIZE to be multiple of a fixed
integer.
@item result_size
A pointer where it will put the real size of the output buffer. This
size will be lesser or equal than out_size.
@end table
@item Returns
@table @code
@item PDF_OK
Operation successful
@item PDF_ERROR
An error ocurred.
@end table
@item Usage example
@example
pdf_crypt_cipher_t cipher;
pdf_status_t st;
pdf_char_t *out;
pdf_char_t *in;
pdf_size_t out_size;
pdf_size_t in_size;

/* ... */
out_size = pdf_crypt_cipher_encrypt_size (cipher, in, in_size);
out = pdf_alloc (out_size);

st = pdf_crypt_cipher_encrypt (cipher, out, out_size, in, in_size, &out_size);

if (st != PDF_OK)
@{
  /* Error*/
@}
@end example
@end table
@end deftypefun


@deftypefun pdf_status_t pdf_crypt_cipher_decrypt (pdf_crypt_cipher_t @var{cipher}, pdf_char_t  *@var{out}, pdf_size_t  @var{out_size}, pdf_char_t  *@var{in}, pdf_size_t  @var{in_size}, pdf_size_t *@var{result_size})

Decrypt a buffer. The plain text will be put in @var{out}.

@table @strong
@item Parameters
@table @var
@item cipher
A cipher.
@item out
A pointer to the output buffer.
@item out_size
Size reserved for the output buffer in octets. The function will fail if
it is not too large to contain the output.
@item in
A pointer to input buffer.
@item in_size
The length of the input buffer in octets. It must be greater than zero.
@item result_size
A pointer where it will put the real size of the output buffer. This size
will be lesser or equal than out_size.
@end table
@item Returns
@table @code
@item PDF_OK
Operation successful
@item PDF_ERROR
An error ocurred.
@end table
@item Usage example
@example
pdf_crypt_cipher_t cipher;
pdf_status_t st;
pdf_char_t *out;
pdf_char_t *in;
pdf_size_t out_size;
pdf_size_t in_size;

/* ... */
out_size = pdf_crypt_cipher_decrypt_size (cipher, in, in_size);
out = pdf_alloc (out_size);

st = pdf_crypt_crypt_decrypt (cipher, out, out_size, in, in_size, &out_size);

if (st != PDF_OK)
@{
  /* Error*/
@}
@end example
@end table
@end deftypefun

@node Message digest functions
@subsection Message digest functions

@deftp {Data Type} {enum pdf_crypt_md_algo_e}
An algorithm provided. It contains low level functions of the algorithm
implementation.

@table @code
@item PDF_CRYPT_MD_MD5
Use the md5 algorithm.
@end table
@end deftp

@deftp {Data Type} {pdf_crypt_md_t}
A message-digest descriptor.
@end deftp



@deftypefun pdf_status_t pdf_crypt_md_new (enum pdf_crypt_md_algo_e @var{algo}, pdf_crypt_md_t  *@var{md})

Create a message-digest descriptor for an algorithm.

@table @strong
@item Parameters
@table @var
@item md
A pointer to the pdf_crypt_md_t.
@item algo
Algorithm which be used to hashing.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
Operation successful
@item PDF_ERROR
An error ocurred.
@end table
@item Usage example
@example
pdf_status_t st;
pdf_crypt_md_t md;

st = pdf_crypt_md_new (&md, PDF_CRYPT_MD_MD5);

if (st != PDF_OK)
@{
   /* Error /*
@}
@end example
@end table
@end deftypefun



@deftypefun pdf_status_t pdf_crypt_md_write (pdf_crypt_md_t @var{md}, pdf_char_t  *@var{in}, pdf_size_t  @var{in_size})

Pass a buffer to the message-digest handler in order to compute its digest.

@table @strong
@item Parameters
@table @var
@item md
A message-digest descriptor.
@item in
A pointer to the input buffer.
@item in_size
Size of the input buffer in octets.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
Operation successful
@item PDF_EBADDATA
Bad parameter. The size of the output buffer is wrong.
@end table
@item Usage example
@example
pdf_crypt_md_t md;
pdf_char_t *in;
pdf_size_t in_size;
pdf_status_t st;

/* ...Prepare IN and IN_SIZE variables */

pdf_crypt_md_new (&md, PDF_CRYPT_MD_MD5);

st = pdf_crypt_md_hash (md, in, in_size);

if (st != PDF_OK)
@{
   /* Error */
@}

pdf_crypt_md_destroy (md);
@end example
@end table
@end deftypefun



@deftypefun pdf_status_t pdf_crypt_md_read (pdf_crypt_md_t @var{md}, pdf_char_t  *@var{out}, pdf_size_t  @var{out_size})

Read the computed digest value from a message-digest descriptor.

@table @strong
@item Parameters
@table @var
@item md
A message-digest descriptor.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
Operation successful
@item PDF_EBADDATA
Bad parameter. The size of the output buffer is wrong.
@end table
@item Usage example
@example
pdf_crypt_md_t md;
pdf_char_t *out;
pdf_size_t out_size;
pdf_status_t st;

pdf_crypt_md_new (&md, PDF_CRYPT_MD_MD5);

/* ...Write the buffer into descriptor here... */

st = pdf_crypt_md_read (md, out, out_size);

if (st != PDF_OK)
@{
   /* Error */
@}

pdf_crypt_md_destroy (md);
@end example
@end table
@end deftypefun



@deftypefun pdf_status_t pdf_crypt_md_destroy (pdf_crypt_md_t  @var{md})

Destroy a message-digest descriptor.

@table @strong
@item Parameters
@table @var
@item md
An message-digest descriptor.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
Operation successful
@item PDF_ERROR
An error ocurred.
@end table
@item Usage example
@example
pdf_status_t st;
pdf_crypt_md_t md;

st = pdf_crypt_md_new (&md, PDF_CRYPT_MD_MD5);

/* ... /*

pdf_crypt_md_destroy (md);
@end example
@end table
@end deftypefun


@node Utilities
@subsection Utilities

@deftypefun pdf_status_t pdf_crypt_nonce (pdf_char_t *@var{buffer}, pdf_size_t @var{size})

Fill a buffer with random values.

@table @strong
@item Parameters
@table @var
@item buffer
Buffer which be filled.
@item size
Size of the buffer in octets.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
Operation successful
@end table
@item Usage example
@example
pdf_char_t buffer[16];

pdf_crypt_nonce (buffer, sizeof(buffer));
@end example
@end table
@end deftypefun



@node Object Layer
@chapter Object Layer

@menu
* Object Layer Overview::
* PDF Objects::
* Object Documents::
@end menu

@node Object Layer Overview
@section Overview

In its more fundamental structure, a PDF document is conformed by a
collection of PDF objects organized in a certain way.  @dfn{PDF
objects} can be of several data types:

@table @dfn
@item Scalars
Scalar values are integer and real numbers and booleans (true, false).
@item Names
Name objects are atoms made out of a sequence of printable
characters.  They are finished by a null octet.

The characters of the string making up the name do not contribute to
the meaning of the name, but only to make it unique.
@item Strings
Strings are sequences of octets.  Note that the octets contained in
a PDF string are not restricted to the printable ASCII subset.  In
particular the null octet (@code{00H}) can be part of a string and it
is not used to to finalize it like in some programming languages.

The interpretation of the contents of a string depends of the selected
encoding and other factors.   Usually the UTF-8 encoding of ISO-16000
is used.
@item Arrays
Arrays are collections of objects that are arranged sequentially.
Unlike the arrays in most programming languages, PDF arrays do not
need to be homogeneous: the same array can contain objects of several
types including other arrays.
@item Dictionaries
Dictionaries are a set of @dfn{key-value pairs}.  Like arrays, they
are heterogeneous.  Unlike arrays, the objects contained in
dictionaries are usually accessed using the value of a key.  They are
like the associative arrays of some programming languages.

Both arrays and dictionaries are @dfn{containers}, meaning that they
can contain other objects.
@item Streams
Streams are like strings, but they are unrestrained (no limitation on
its size) and are accompanied by a descriptor dictionary.  The
descriptor contains information about the stream, like its size and
how its contents should be filtered when read.
@item Indirect References
An indirect reference is a way to refer to some indirect object (XXX:
xref).
@end table

By using container objects it is possible to build arbitrary
structures made out of objects.  A PDF document is a hierarchy of
objects arranged following some conventions.

@float Figure,fig:object-hierarchy
@image{gnupdf-figures/object-hierarchy}
@caption{Hierarchy of objects in a PDF document.}
@end float

The dictionary at the top of the hierarchy is known as the @dfn{root
dictionary}.  Any other object in the document shall be accessible
from the root dictionary.  The only exception is the optional
@dfn{information dictionary}.  If it exists it contains
meta-information about the document: software that made the document,
author, etc.

@quotation Note
The use of this layer can lead to non-well conformed PDF documents:
not every PDF object document define a document.  The client should be
careful when using this layer. In contrast the @ref{Document Layer}
provides a convenient API to manipulate PDF files while maintaining
its structural integrity.
@end quotation

@node PDF Objects
@section PDF Objects

PDF objects are the fundamental bricks used in PDF documents.  This
section describes data types and functions to create, destroy and
manipulate all kind of PDF objects: numbers, booleans, names, strings,
streams and the @code{null} object.

@menu
* Object Data Types::
* Generic Functions to Manipulate Objects::
* Object Strong References::
* Compressibility of Objects::
* Object Collections::
* Real Objects::
* Integer Objects::
* Boolean Objects::
* Name Objects::
* String Objects::
* Array Objects::
* Dictionary Objects::
* Stream Objects::
* Null Object::
@end menu

@node Object Data Types
@subsection Object Data Types

@deftp {Data Type} pdf_obj_t
Opaque type representing a PDF Object.

Despite being opaque, the user shall be aware that a @code{pdf_obj_t}
variable containing a direct scalar object shall be considered as the
object itself (its value).  Otherwise the variable shall be considered
as a ``reference''.
@end deftp

@deftp {Data Type} {enum pdf_obj_type_e}
Enumeration of the supported types of PDF objects:

@table @code
@item PDF_OBJ_REAL
Real objects denote quantities in the real domain, such as @code{3,14}
and @code{1,00000}.

@xref{Real Objects}.
@item PDF_OBJ_INTEGER
Integer objects denote quantities in the integer domain, such as
@code{3} and @code{1}.

@xref{Integer Objects}.
@item PDF_OBJ_BOOLEAN
Possible values are @dfn{true} and @dfn{false}.

@xref{Boolean Objects}.
@item PDF_OBJ_NAME
A PDF name is an atomic symbol uniquely defined by a sequence of
regular characters.  It does not have internal structure.

@xref{Name Objects}.
@item PDF_OBJ_STRING
A PDF string is a sequence of octets whose values are in the range
@code{0-255}.

@xref{String Objects}.
@item PDF_OBJ_ARRAY
A heterogeneous array of PDF objects.

@xref{Array Objects}.
@item PDF_OBJ_DICT
A dictionary is a collection of key-value pairs.  Unlike the
postscript dictionaries the key should be a Name Object, while the
value is a PDF object of any type.

@xref{Dictionary Objects}.
@item PDF_OBJ_STREAM

@xref{Stream Objects}.
@item PDF_OBJ_NULL
The Null object has a type and a value that are unequal to those of
any other object.

@xref{Null Object}.
@end table
@end deftp

@deftp {Data Type} pdf_obj_id_t
A positive integer representing the identification number of a PDF
object.  An object ID uniquely represents an object into an object
document.
@end deftp

@deftp {Data Type} {pdf_obj_gen_t}
A non-negative number representing the generation number of a PDF object.
@end deftp

@deftp {Data Type} pdf_obj_col_t
Opaque type representing an object collection into an object document.

@xref{Object Collections}.
@end deftp

@deftp {Data Type} {enum pdf_obj_stm_open_mode_e}

Open modes for PDF stream objects.

@table @code
@item PDF_OBJ_STM_OPEN_MODE_RAW
The data will be decrypted but not filtered.
@item PDF_OBJ_STM_OPEN_MODE_UNFILTERED
The data wont be filtered nor decrypted.
@item PDF_OBJ_STM_OPEN_MODE_FILTERED
The data will be both decrypted and filtered.
@end table
@end deftp

@node Generic Functions to Manipulate Objects
@subsection Generic Functions to Manipulate Objects

The following functions can be called on any @code{pdf_obj_t} variable
regardless its type.  But note that the effects of the call may vary
depending on the object type.

@deftypefun pdf_obj_t pdf_obj_dup (pdf_obj_t @var{obj}, pdf_obj_doc_t @var{dest_doc}, pdf_bool_t @var{copy_indirect})

Copy a PDF object from one document to another.
The destination document can be the same than the document associated
with @var{source}.

This operation sets the dirty flag of @var{dest_doc} if the copied
object is not a direct scalar.

@table @strong
@item Parameters
@table @var
@item obj
The PDF object to copy.
@item dest_doc
The object document that will hold the copied object.
@item copy_indirect
A boolean value:
@table @code
@item PDF_TRUE
All indirectly referenced objects in @var{obj} are copied to
@var{dest_doc}.
@item PDF_FALSE
The indirectly referenced objects in @var{obj} are not copied to
@var{dest_doc}.  The corresponding entries in @var{obj} will be
missing in @var{dest}.
@end table
@end table
@item Returns
The copied object, or the null object if not enough memory is
available.
@item Usage example
@example
pdf_obj_doc_t doc;
pdf_obj_t obj1;
pdf_obj_t obj2;

...

/* Make a copy of 'obj1' in 'obj2' in the same object document
   'doc' */
obj2 = pdf_obj_dup (obj1, doc, PDF_TRUE);
if (!obj2)
@{
   /* Error copying the object.  */
@}
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_obj_destroy (pdf_obj_t @var{obj})

Destroy a PDF object @var{obj}.

This function is a nop if @var{obj} is a direct scalar type or the
Null object.

If @var{obj} is a composite object (array, dictionary, stream) then
any directly referenced object is also destroyed. The indirectly
referenced objects are not destroyed.  Note that this is a recursive
rule: a string directly contained in a dictionary that is in turn
directly contained in an array will be destroyed if the top-level
array is destroyed.

The root dictionary of an object document can not be destroyed.

This operation sets the dirty flag of the document containing the
object.

@table @strong
@item Parameters
@table @var
@item obj
The PDF object to destroy.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The object was successfully destroyed.  The value of @var{obj} is now
undefined and shall not be used.
@item PDF_ERROR
An error prevented to complete the operation.  The value of @var{obj}
is now undefined and shall not be used.
@item PDF_EINVOP
The user requested to destroy the root dictionary of the object
document.
@end table
@item Usage example
@example
pdf_obj_doc_t doc;
pdf_obj_t info_dict;

...

/* Destroy the info dictionary of an object document */
info_dict = pdf_obj_doc_get_info_dict (doc);
pdf_obj_destroy (info_dict);
@end example
@end table
@end deftypefun

@deftypefun {pdf_list_t *}pdf_obj_get_objs (pdf_obj_t @var{obj})

Return a list containing all the objects contained in a PDF object.

@table @strong
@item Parameters
@table @var
@item obj
The PDF object whose elements are returned. The specific semantics of
@code{pdf_obj_get_objs} depend on the type of this object:

@table @strong
@item Scalar or a string
The function returns an empty list.
@item Dictionary
Every key-value entry is returned in the list, the value object
following the key object.  The order of the key-value entries is
undefined.
@item Array
Every object contained in the array is returned in the list.  The
order of the objects is ascending with the index of the array.
@item Stream
A list containing the stream dictionary is returned.
@end table
@end table
@item Returns
A pointer to a list list containing the objects, or @code{NULL} if not
enough memory is available.
@item Usage example
@example
pdf_list_t *objects;

/* Get the list of objects contained in some PDF object */
objects = pdf_obj_get_objs (obj);
if (!objects)
@{
   /* Not enough memory to create the list.  */
@}
@end example
@end table
@end deftypefun

@deftypefun pdf_bool_t pdf_obj_equal_p (pdf_obj_t @var{obj1}, pdf_obj_t @var{obj2})

Test whether two PDF objects are equal.

Two PDF objects are equal when all the following conditions are
satisfied:

@itemize @minus
@item They are both direct objects or indirect objects.
@item They have the same type.
@item If they are indirect, they share the same generation number and has the same object number.
@item If they are scalars, they have the same value.
@item If they are non-scalar, they reference the same value.
@end itemize

@table @strong
@item Parameters
@table @var
@item obj1
The first PDF object to compare.
@item obj2
The second PDF object to compare.
@end table
@item Returns
A PDF boolean value:
@table @code
@item PDF_TRUE
The PDF objects are equal.
@item PDF_FALSE
The PDF objects are not equal.
@end table
@item Usage example
@example
pdf_obj_doc_t doc;
pdf_obj_t obj1;
pdf_obj_t obj2;

...

/* Compare integers */
obj1 = pdf_obj_integer_new (doc, PDF_TRUE, 10);
obj2 = pdf_obj_integer_new (doc, PDF_FALSE, 20);
pdf_obj_equal_p (obj1, obj2); /* Returns PDF_FALSE */
pdf_obj_destroy (obj1);
pdf_obj_destroy (obj2);
@end example
@end table
@end deftypefun

@deftypefun {pdf_obj_doc_t *}pdf_obj_get_doc (pdf_obj_t @var{obj})

Gets the object document associated with a given PDF object.

This is a nop for direct scalar objects, since they are not associated
with an object document.

@table @strong
@item Parameters
@table @var
@item obj
A PDF object.
@end table
@item Returns
A pointer to a pdf object document, or @code{NULL} if the object is a
direct object.
@item Usage example
@example
pdf_obj_doc_t doc;
pdf_obj_t obj;

...

doc = pdf_obj_get_doc (obj);

if (doc)
@{
   /* 'doc' contains a reference to the object document containing
      'obj'. */
@}
@end example
@end table
@end deftypefun

@deftypefun pdf_obj_gen_t pdf_obj_get_generation (pdf_obj_t @var{obj})

Get the generation number of a given indirect PDF object @var{obj}.

@table @strong
@item Parameters
@table @var
@item obj
An indirect PDF object.
@end table
@item Returns
The generation number of @var{obj}, or @code{0} if the object is not
indirect.  @code{pdf_obj_indirect_p} can be used to distinguish
between those cases.
@item Usage example
@example
pdf_obj_t obj;
pdf_obj_gen_t gen_number;

...

if (pdf_obj_indirect_p (obj))
@{
   gen_number = pdf_obj_get_generation (obj, &gen_number);
   /* 'gen_number' contains the generation number of 'obj'. */
@}
@end example
@end table
@end deftypefun

@deftypefun pdf_obj_id_t pdf_obj_get_id (pdf_obj_t @var{obj})

Get the identification number of a given indirect PDF object @var{obj}.

@table @strong
@item Parameters
@table @var
@item obj
An indirect PDF object.
@end table
@item Returns
The object id of @var{obj}, or @code{0} if it is not indirect.  Note
that @code{0} is not a valid object id.
@item Usage example
@example
pdf_obj_t obj;
pdf_obj_id_t id_number;

...

id_number = pdf_obj_get_id (obj);
if (id_number != 0)
@{
   /* 'id_number' contains the identification
      number of 'obj'. */
@}
@end example
@end table
@end deftypefun

@deftypefun enum pdf_obj_type_e pdf_obj_get_type (pdf_obj_t @var{obj})

Get the type of a given PDF object @var{obj}.

@table @strong
@item Parameters
@table @var
@item obj
A PDF object.
@end table
@item Returns
The type of @var{obj}.
@item Usage example
@example
pdf_obj_doc_t doc;
pdf_obj_t obj;

...

/* Create an integer object */
obj = pdf_obj_integer_new (doc, PDF_FALSE, 10);

/* Get its type */
pdf_obj_get_type (obj);  /* Returns PDF_OBJ_INTEGER */
@end example
@end table
@end deftypefun

@deftypefun pdf_bool_t pdf_obj_compressed_p (pdf_obj_t @var{obj})

Determine if a given PDF object @var{obj} is compressed (i.e. it is
contained in an object collection).

@xref{Object Collections}.
@table @strong
@item Parameters
@table @var
@item obj
A PDF object.
@end table
@item Returns
A boolean value:
@table @code
@item PDF_TRUE
The object @var{obj} is compressed.
@item PDF_FALSE
The object @var{obj} is not compressed.
@end table
@item Usage example
@example
pdf_obj_t obj;
pdf_obj_col_t objcol;

...

/* Add 'obj' to an object collection. */
pdf_obj_col_add_obj (objcol, obj);

/* The following call returns PDF_TRUE */
pdf_obj_compressed_p (obj);
@end example
@end table
@end deftypefun

@deftypefun pdf_bool_t pdf_obj_indirect_p (pdf_obj_t @var{obj})

Determine if a given PDF object @var{obj} is indirect.

@table @strong
@item Parameters
@table @var
@item obj
A PDF object.
@end table
@item Returns
A boolean value:
@table @code
@item PDF_TRUE
The object @var{obj} is indirect.
@item PDF_FALSE
The object @var{obj} is direct.
@end table
@item Usage example
@example
pdf_obj_doc_t doc;
pdf_obj_t obj_direct;
pdf_obj_t obj_indirect;

...

/* Create an indirect object */
obj_indirect = pdf_obj_integer_new (doc, PDF_TRUE, 10);
pdf_obj_indirect_p (obj_indirect); /* Returns PDF_TRUE */

/* Create a direct object */
obj_direct = pdf_obj_integer_new (doc, PDF_FALSE, 10);
pdf_obj_indirect_p (obj_direct); /* Returns PDF_FALSE */
@end example
@end table
@end deftypefun

@deftypefun pdf_size_t pdf_obj_size (pdf_obj_t @var{obj})

Get the ``size'' of a given PDF object.  The semantics of the returned
value depends on the type of the object.

For names and strings, return the size of the name/string in octets.

For arrays and dictionaries, the number of entries is returned.

For any other type of object, the function returns @code{0} (use
@code{pdf_obj_stream_size} for querying the size of a stream).

@table @strong
@item Parameters
@table @var
@item obj
A PDF object.
@end table
@item Returns
The size of @var{obj}.
@item Usage example
@example
pdf_obj_t obj;
pdf_size_t size;

...

size = pdf_obj_size (obj);
@end example
@end table
@end deftypefun

@defun PDF_OBJ_IS_NULL(@var{obj})

Macro that determines whether the passed object is the null object.

@table @strong
@item Parameters
@table @var
@item obj
A PDF object.
@end table
@item Returns
The macro expands to a boolean value.
@item Usage example
@example
pdf_obj_t obj;

if (PDF_OBJ_IS_NULL(obj))
@{
    /* 'obj' is the null object.  */
@}
@end example
@end table
@end defun

@node Object Strong References
@subsection Object Strong References

Every indirect PDF object contained in an object document features an
@dfn{acquire counter} whose value is initially @code{0}.  The garbage
collector (@pxref{Garbage collection in object documents}) never
destroys unmarked objects with an acquire counter of 1 or more.

@deftypefun pdf_status_t pdf_obj_acquire (pdf_obj_t @var{obj})

Create a strong reference for @var{obj} in its container document by
incrementing its acquire counter by one.  For direct scalars this
operation is a nop.

@float Figure,fig:acquire-counters
@image{gnupdf-figures/acquire-counters}
@caption{Acquire counters in PDF objects.}
@end float

The above figure shows a container object @code{A} containing two
indirect objects @code{B} and @code{C}.  The acquire counter of
@code{B} is @code{1}, meaning that someone acquired the object via the
@code{pdf_obj_t} variable.  If the object @code{A} is garbage
collected then @code{C} will be also collected, but @code{B} won't.

@table @strong
@item Parameters
@table @var
@item obj
A PDF object.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The strong reference was created or the request was ignored.
@end table
@item Usage example
@example
pdf_obj_doc_t doc;
pdf_obj_t obj;

/* Get an object from a document */
obj = pdf_obj_doc_get_obj (doc, 10, 0);

/* Create a strong reference for the object in `doc' */
pdf_obj_acquire (obj);
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_obj_release (pdf_obj_t @var{obj})

Remove a strong reference from the PDF object @var{obj} by decreasing
its acquire counter by one.

For direct objects this operation is a nop.

@table @strong
@item Parameters
@table @var
@item obj
A PDF object.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The strong reference was destroyed or the operation was ignored.
@end table
@item Usage example
@example
pdf_obj_doc_t doc;
pdf_obj_t obj;

/* Get an object from a document */
obj = pdf_obj_doc_get_obj (doc, 10, 0);

/* Create a strong reference for the object in `doc'.  Its acquire
counter is increased to 1.  */
pdf_obj_acquire (obj);

/* Remove a strong reference for the object in `doc'.  Its acquire
   counter is decreased to 0.  */
pdf_obj_release (obj);
@end example
@end table
@end deftypefun

@node Compressibility of Objects
@subsection Compressibility of Objects

A PDF object is compressible if any of the following conditions are
true:

@itemize @minus
@item It is an indirect object.
@item It has a generation number of zero.
@item It is not a stream.
@item It has not been explicitly marked as incompressible with @code{pdf_obj_set_compressibility}.
@end itemize

A compressible object is suitable to be contained in an object
collection.  @xref{Object Collections}.

@deftypefun pdf_bool_t pdf_obj_get_compressibility (pdf_obj_t @var{obj})

Test if a given PDF object @var{obj} is compressible. Only
compressible objects can be added to an object collection.

@table @strong
@item Parameters
@table @var
@item obj
A PDF object.
@end table
@item Returns
A PDF boolean value:
@table @code
@item PDF_TRUE
The object is compressible.
@item PDF_FALSE
The object is not compressible.
@end table
@item Usage example
@example
pdf_obj_t obj;

...

/* Check the compressibility of a PDF object */
if (pdf_obj_get_compressibility (obj))
@{
   /* The object 'obj' is compressible. */
@}
@end example
@end table
@end deftypefun

@deftypefun pdf_bool_t pdf_obj_set_compressibility (pdf_obj_t @var{obj}, pdf_bool_t @var{compressible_p})

Set the compressibility attribute of the PDF object @var{obj}.

@table @strong
@item Parameters
@table @var
@item obj
A PDF object.
@item compressible_p
A boolean value.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The compressibility of @var{obj} was set according to
@var{compressible_p}.
@item PDF_EINVOBJ
@var{obj} cannot be compressed.
@item PDF_ERROR
Some error prevented the operation to complete.
@end table
@item Usage example
@example
pdf_obj_t obj;

...

/* Set the compressibility of 'obj' to true */
pdf_obj_set_compressibility (obj, PDF_TRUE);

/* Set it back to false */
pdf_obj_set_compressibility (obj, PDF_FALSE);
@end example
@end table
@end deftypefun

@node Object Collections
@subsection Object Collections

Sometimes a group of objects are related in a way they acquire
``locality'', meaning that if one of those objects is accessed it is
very likely that the other objects will be accessed as well.  An
example of tightly related objects is the collection of objects
containing the contents of a page: you need to read them all to render
the page.

A common practice in PDF files is to pack tightly related PDF objects
in a compressed stream in the object document.  That greatly reduces
the space occupied by the objects, since it is possible to use
compression filter in the object stream.

An @dfn{object collection} is automatically translated into one or
several of such compressed streams by the library.  It follows that an
object can be declared as part of one (and just one) object
collection.

Only compressible objects can be added to a collection.
@xref{Compressibility of Objects}.

@deftypefun {pdf_obj_col_t *}pdf_obj_col_new (pdf_obj_doc_t *@var{doc})

Create a new object collection in an object document.

The returned pointer is internally stored in @var{doc}, so the caller
does not need to save it.  If the document is destroyed the pointers
to its stored collections become invalid.

@table @strong
@item Parameters
@table @var
@item doc
A pointer to an object document.
@end table
@item Returns
A pointer to a newly created object collection, or @code{NULL} if
there is not enough memory to perform the operation.
@item Usage example
@example
pdf_obj_doc_t *doc;
pdf_obj_col_t *col1;
pdf_obj_col_t *col2;

...

/* Create some object collections */
col1 = pdf_obj_col_new (doc);
col2 = pdf_obj_col_new (doc);
@end example
@end table
@end deftypefun

@deftypefun {pdf_list_t *}pdf_obj_col_get_objs (pdf_obj_col_t @var{col})

Return a list containing the PDF objects contained in a given object
collection.

Note that the returned list can be empty if the object collection does
not contain objects.

@table @strong
@item Parameters
@table @var
@item col
An object collection.
@end table
@item Returns
A pointer to a list containing the contained objects, or @code{NULL}
if there is not enough memory to perform the operation.
@item Usage example
@example
pdf_list_t *objects;

/* Get the objects contained in the object collection 'col'. */
objects = pdf_obj_col_get_objs (col);
if (object)
@{
   /* The list contains the objects contained in 'col' */
@}
@end example
@end table
@end deftypefun

@deftypefun pdf_bool_t pdf_obj_col_equal_p (pdf_obj_col_t *@var{col1}, pdf_obj_col_t *@var{col2})

Test whether two PDF object collections are the same collection.

@table @strong
@item Parameters
@table @var
@item col1
The first collection to compare.
@item col2
The second collection to compare.
@end table
@item Returns
A boolean value:
@table @code
@item PDF_TRUE
The collections are the same.
@item PDF_FALSE
The collections are not the same.
@end table
@item Usage example
@example
pdf_obj_doc_t doc;
pdf_obj_col_t *col1;
pdf_obj_col_t *col2;

...

/* Create two object collections and compare them */
col1 = pdf_obj_col_new (doc);
col2 = pdf_obj_col_new (doc);

pdf_obj_col_equal_p (col1, col2); /* Returns PDF_FALSE */
pdf_obj_col_equal_p (col1, col1); /* Returns PDF_TRUE */
@end example
@end table
@end deftypefun

@deftypefun pdf_u32_t pdf_obj_col_size (pdf_obj_col_t *@var{col})

Get the number of PDF objects contained in the object collection
@var{col}.

@table @strong
@item Parameters
@table @var
@item col
A pointer to an object collection.
@end table
@item Returns
The number of objects contained in @var{col}.
@item Usage example
@example
pdf_obj_doc_t doc;
pdf_obj_col_t *col;
pdf_obj_t obj1;
pdf_obj_t obj2;

...

/* Create an object collection and put some objects in it. */
col = pdf_obj_col_new (doc);
pdf_obj_col_add_obj (objcol, obj1);
pdf_obj_col_add_obj (objcol, obj2);

/* Get the number of objects */
pdf_obj_col_size (objcol);  /* Should return 2 */
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_obj_col_add_obj (pdf_obj_col_t *@var{col}, pdf_obj_t @var{obj})

Add an object @var{obj} to a collection @var{col}. The given object
should be compressible.

This operation sets the dirty flag of the document containing the
object collection.

@table @strong
@item Parameters
@table @var
@item col
An object collection.
@item obj
A PDF object.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The object @var{obj} was successfully added into the object collection
@var{col}.
@item PDF_EINVOBJ
The object @var{obj} is not compressible.
@item PDF_ERROR
An error prevented the operation to complete.
@end table
@item Usage example
@example
pdf_obj_col_t *col;
pdf_obj_t obj;

...

/* Add an object into an object collection */
pdf_obj_col_add_obj (col, obj);
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_obj_col_remove_obj (pdf_obj_t @var{obj})

Remove a given PDF object @var{obj} from its containing object
collection. If the object is not contained in an object collection
then this operation is a nop.

This operation sets the dirty flag of the document containing the
object collection.

@table @strong
@item Parameters
@table @var
@item obj
A PDF object.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The object was successfully dissociated from any containing object
collection.
@item PDF_ERROR
An error prevented the operation to complete.
@end table
@item Usage example
@example
pdf_obj_t obj;
pdf_obj_col_t *col;

...

pdf_obj_col_add_obj (col, obj);

/* After the next sentence 'obj' won't be associated with 'col'
   anymore */
pdf_obj_col_remove_obj (obj);
@end example
@end table
@end deftypefun

@deftypefun {pdf_obj_col_t *}pdf_obj_get_col (pdf_obj_t @var{obj})

Get the containing object collection containing a PDF object.

@table @strong
@item Parameters
@table @var
@item obj
A PDF object.
@end table
@item Returns
A pointer to the object collection containing @var{obj}, or
@code{NULL} if the object is not contained in any collection.
@item Usage example
@example
pdf_obj_doc_t *doc;
pdf_obj_col_t *col;
pdf_obj_t obj;

...

col = pdf_obj_col_new (doc);
pdf_obj_col_add_obj (col, obj);

pdf_obj_get_col (obj); /* Returns 'col' */
pdf_obj_col_remove_obj (obj);
pdf_obj_get_col (obj); /* Returns NULL */
@end example
@end table
@end deftypefun

@node Real Objects
@subsection Real Objects

PDF real objects are quantities in the real domain.  They are defined by
range and precision.  Usually represented in fixed point rather than
floating point.

@deftypefun pdf_obj_t pdf_obj_real_new (pdf_obj_doc_t *@var{doc}, pdf_bool_t @var{indirect_p}, pdf_real_t @var{value})

Create a new Real object in an object document.

@table @strong
@item Parameters
@table @var
@item doc
A document object.
@item indirect_p
A boolean value indicating whether to create an indirect object.
@item value
The initial value for the object.
@end table
@item Returns
The newly created object, or the null object if there is not enough
memory.
@item Usage example
@example
pdf_obj_doc_t *doc;
pdf_obj_t real_obj_1;
pdf_obj_t real_obj_2;

/* Create some real objects */
real_obj_1 = pdf_obj_real_new (doc, PDF_FALSE, 3.14);
if (PDF_OBJ_IS_NULL (real_obj_1))
@{
   /* Error creating real object */
@}

reak_obj_2 = pdf_obj_real_new (doc, PDF_FALSE, 2.7182);
if (PDF_OBJ_IS_NULL (real_obj_2))
@{
   /* Error creating real object */
@}
@end example
@end table
@end deftypefun

@deftypefun pdf_real_t pdf_obj_real_value (pdf_obj_t @var{obj})

Get the value of a PDF Real object.

@table @strong
@item Parameters
@table @var
@item obj
A PDF object.
@end table
@item Returns
The value of the real object, or an undefined value if @var{obj} is
not an object of type real.
@item Usage example
@example
pdf_obj_doc_t *doc;
pdf_obj_t real_obj;
pdf_real_t result;

real_obj = pdf_obj_real_new (doc, PDF_FALSE, 3.14);
if (!PDF_OBJ_IS_NULL (real_obj))
@{
   result = pdf_obj_real_value (real_obj);
   /* result equals to 3.14 */
@}
@end example
@end table
@end deftypefun

@node Integer Objects
@subsection Integer Objects

The PDF integer objects are quantities in the integer domain.  They
are limited by an implementation limit (@pxref{Implementation
Limits}).

@deftypefun pdf_obj_t pdf_obj_integer_new (pdf_obj_doc_t *@var{doc}, pdf_bool_t @var{indirect_p}, pdf_i32_t @var{value})

Create a new Integer object in an object document.

@table @strong
@item Parameters
@table @var
@item doc
A document object.
@item indirect_p
A boolean value indicating whether to create an indirect object.
@item value
The initial value for the object.
@end table
@item Returns
The newly created object, or the null object if there is not enough memory.
@item Usage example
@example
pdf_obj_doc_t *doc;
pdf_obj_t integer_obj_1;
pdf_obj_t integer_obj_2;

/* Create some integer objects */
integer_obj_1 = pdf_obj_integer_new (doc, PDF_FALSE, 10);
if (PDF_OBJ_IS_NULL (integer_obj_1))
@{
   /* Error creating integer object */
@}

integer_obj_2 = pdf_obj_integer_new (doc, PDF_FALSE, -10);
if (PDF_OBJ_IS_NULL (integer_obj_2))
@{
   /* Error creating integer object */
@}
@end example
@end table
@end deftypefun

@deftypefun pdf_i32_t pdf_obj_integer_value (pdf_obj_t @var{obj})

Get the value of a PDF Integer object.

@table @strong
@item Parameters
@table @var
@item obj
A PDF object.
@end table
@item Returns
The value of the integer object, or @code{0} if @var{obj} is not an
integer object.
@item Usage example
@example
pdf_obj_doc_t *doc;
pdf_obj_t integer_obj;
pdf_i32_t result;

integer_obj = pdf_obj_integer_new (doc, PDF_FALSE, 10);
if (!PDF_OBJ_IS_NULL (integer_obj))
@{
   result = pdf_obj_integer_value (integer_obj);
   /* result equals to 10 */
@}
@end example
@end table
@end deftypefun

@node Boolean Objects
@subsection Boolean Objects

Boolean objects can hold just two values:

@itemize @minus
@item @code{true}
@item @code{false}
@end itemize

Can be used as values of array elements, values of dictionary entries
and as operators in the postscript calculator functions (type 4
functions).

@deftypefun pdf_obj_t pdf_obj_boolean_new (pdf_obj_doc_t *@var{doc}, pdf_bool_t @var{indirect_p}, pdf_bool_t @var{value})

Create a new Boolean object in an object document.

@table @strong
@item Parameters
@table @var
@item doc
A document object.
@item indirect_p
A boolean value indicating whether to create an indirect object.
@item value
The initial value for the object.
@end table
@item Returns
The newly created object, or the null object if there is not enough
memory.
@item Usage example
@example
pdf_obj_doc_t *doc;
pdf_obj_t boolean_obj_1;
pdf_obj_t boolean_obj_2;

/* Create some Boolean objects */
boolean_obj_1 = pdf_obj_boolean_new (doc, PDF_FALSE, PDF_TRUE);
if (PDF_OBJ_IS_NULL (boolean_obj_1))
@{
   /* Error creating boolean object */
@}

boolean_obj_2 = pdf_obj_boolean_new (doc, PDF_FALSE, PDF_FALSE);
if (PDF_OBJ_IS_NULL (boolean_obj_2))
@{
   /* Error creating boolean object */
@}
@end example
@end table
@end deftypefun

@deftypefun pdf_bool_t pdf_obj_boolean_value (pdf_obj_t @var{obj})

Get the value of a PDF boolean object.

@table @strong
@item Parameters
@table @var
@item obj
A PDF object.
@end table
@item Returns
The value of the object, or @code{PDF_FALSE} if the object is not of
type boolean.
@item Usage example
@example
pdf_obj_doc_t *doc;
pdf_obj_t boolean_obj;
pdf_bool_t result;

boolean_obj = pdf_obj_boolean_new (doc, PDF_FALSE, PDF_TRUE);
if (!PDF_OBJ_IS_NULL (boolean_obj))
@{
   result = pdf_obj_boolean_value (boolean_obj);
   /* result equals to PDF_TRUE */
@}
@end example
@end table
@end deftypefun

@node Name Objects
@subsection Name Objects

A PDF name object is an atomic symbol uniquely defined by a sequence
of regular characters.  It does not have internal structure.

@deftypefun pdf_obj_t pdf_obj_name_new (pdf_obj_doc_t *@var{doc}, pdf_bool_t @var{indirect_p}, pdf_char_t *@var{value})

Create a new Name object in an object document.

@table @strong
@item Parameters
@table @var
@item doc
A document object.
@item indirect_p
A boolean value indicating whether to create an indirect object.
@item value
The null-terminated string value for the object.
@end table
@item Returns
The newly created object, or @code{PDF_OBJ_NULL} if there is not
enough memory to perform the operation, or the data in @var{value} is
not correct.
@item Usage example
@example
pdf_obj_doc_t *doc;
pdf_obj_t name_obj_1;
pdf_obj_t name_obj_2;

/* Create some Name objects */
name_obj_1 = pdf_obj_name_new (doc, PDF_FALSE, "FooBar");
if (PDF_OBJ_IS_NULL (name_obj_1))
@{
   /* Error creating name object */
@}

name_obj_2 = pdf_obj_name_new (doc, PDF_FALSE, "BazFoo");
if (PDF_OBJ_IS_NULL (name_obj_2))
@{
   /* Error creating name object */
@}
@end example
@end table
@end deftypefun

@deftypefun {const pdf_char_t *}pdf_obj_name (pdf_obj_t @var{obj})

Get the value of a PDF Name object.

The value of the name object does not include the ``/'' prefix.

@table @strong
@item Parameters
@table @var
@item obj
A PDF name object.
@end table
@item Returns
A pointer to a @code{NULL}-terminated string containing the printable
characters composing the PDF name, or @code{NULL} if the object is not
a name object.

The user shall not modify nor free the returned memory.
@item Usage example
@example
pdf_obj_doc_t *doc;
pdf_obj_t name_obj;
const pdf_char_t *name;

name_obj = pdf_obj_name_new (doc, PDF_FALSE, "FooBar");
if (!PDF_OBJ_IS_NULL (name_obj))
@{
   name = pdf_obj_name (name_obj);
   /* 'name' points to "FooBar" */
@}
@end example
@end table
@end deftypefun

@node String Objects
@subsection String Objects

A PDF string object is a sequence of octets in the range @code{0-255}.
They are not @code{NULL}-terminated.

@deftypefun pdf_obj_t pdf_obj_string_new (pdf_obj_doc_t *@var{doc}, pdf_bool_t @var{indirect_p}, pdf_char_t *@var{str}, pdf_size_t @var{str_size})

Create a new String object in an object document.

@table @strong
@item Parameters
@table @var
@item doc
A document object.
@item indirect_p
A boolean value indicating whether to create an indirect object.
@item str
The string value. Note that this is not a @code{NULL}-terminated
string, since PDF strings can held arbitrary binary data. The data
pointed by @var{str} is copied internally.
@item str_size
The size of @var{str}, in octets.
@end table
@item Returns
A pointer to the newly created object, or @code{PDF_OBJ_NULL} if there
is not enough memory to perform the operation, @var{str} contains bad
data or @var{str_size} equals to @code{0}.
@item Usage example
@example
pdf_obj_doc_t *doc;
pdf_obj_t str;

/* Create a new String PDF object */
str = pdf-obj_string_new (doc, PDF_FALSE, "f\233o", 3);
if (PDF_OBJ_IS_NULL (str))
@{
   /* Error creating the String object */
@}
@end example
@end table
@end deftypefun

@deftypefun {const char *}pdf_obj_string (pdf_obj_t @var{obj}, pdf_size_t *@var{size})

Get the value of a PDF String object.

@table @strong
@item Parameters
@table @var
@item obj
A PDF string object.
@item size
A pointer to a @code{pdf_size_t} variable.
@item
@end table
@item Returns
A pointer to a constant buffer containing the contents of the string
object, or @code{NULL} if the object is not a string.

The user shall not modify nor free the returned memory.
@item Usage example
@example
pdf_obj_doc_t *doc;
pdf_obj_t str_obj;
const pdf_char_t *str;
pdf_size_t size;

str_obj = pdf_obj_string_new (doc, PDF_FALSE, "foo bar baz", 11);
if (!PDF_OBJ_IS_NULL (str_obj))
@{
   str = pdf_obj_string_value (str_obj, &size);
   /* 'str' points to "foo bar baz" */
@}
@end example
@end table
@end deftypefun

@deftypefun pdf_bool_t pdf_obj_string_hex_p (pdf_obj_t @var{obj})

Return the hex flag of the String object @var{obj}. A String object
with the hex flag set to true is saved in an hexadecimal form.

If @var{obj} is not a string object then @code{PDF_FALSE} is
returned.

@table @strong
@item Parameters
@table @var
@item obj
A PDF String object.
@end table
@item Returns
A PDF boolean value:
@table @code
@item PDF_TRUE
The string will be saved in hexadecimal form.
@item PDF_FALSE
The string won't be saved in hexadecimal form.
@end table
@item Usage example
@example
pdf_obj_t str;

if (pdf_obj_string_hex_p (str))
@{
   /* The hex flag of 'str' is set */
@}
else
@{
   /* The hex flag of 'str' is not set */
@}
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_obj_string_hex_set (pdf_obj_t @var{obj}, pdf_bool_t @var{hex_p})

Set the hex flag of the String object @var{obj}. A String object
with the hex flag set to true is saved in an hexadecimal form.

@table @strong
@item Parameters
@table @var
@item obj
A PDF String object.
@item hex_p
The new value of the hex flag for @var{obj}.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The hex flag of @var{obj} was set to @var{hex_p}.
@item PDF_EINVOBJ
@var{obj} is not a string object.
@item PDF_ERROR
An error prevented the operation to complete.  The hex flag of the
document shall be considered unchanged.
@end table
@item Usage example
@example
pdf_obj_t str;

/* Reverse the hex flag of 'str' */
pdf_obj_string_hex_set (!pdf_obj_string_hex_p (str));
@end example
@end table
@end deftypefun

@node Array Objects
@subsection Array Objects

A PDF array is a one-dimensional collection of objects arranged
sequentially.  The objects can be of any type.

@deftypefun pdf_obj_t pdf_obj_array_new (pdf_obj_doc_t @var{doc}, pdf_bool_t @var{indirect_p}, pdf_size_t @var{array_size})

Create a new Array object in an object document.

@table @strong
@item Parameters
@table @var
@item doc
A document object.
@item indirect_p
A boolean value indicating whether to create an indirect object.
@item array_size
The number of elements of the new array.
@end table
@item Returns
The newly created object, or @code{PDF_OBJ_NULL} if there is not
enough memory to perform the operation.
@item Usage example
@example
pdf_obj_doc_t *doc;
pdf_obj_t array;

...

/* Create an indirect array object to initially
   held 10 elements */
array = pdf_obj_array_new (doc, PDF_TRUE, 10);
if (PDF_OBJ_IS_NULL (array))
@{
   /* Error creating the object.  */
@}
@end example
@end table
@end deftypefun

@deftypefun pdf_obj_t pdf_obj_array_get (pdf_obj_t @var{array}, pdf_size_t @var{index})

Get the @var{index}th element of the given array.

@table @strong
@item Parameters
@table @var
@item array
A PDF array.
@item index
An index into the array.
@end table
@item Returns
The object at the @var{index}th position in @var{array}, or
@var{PDF_OBJ_NULL} if the index it out of bounds.
@item Usage example
@example
pdf_obj_t array;
pdf_obj_t elem;
pdf_size_t index;

...

/* Iterate through the first 5 objects of 'array' */
for (index = 0; index < 5; index++)
@{
   elem = pdf_obj_array_get (array, index);
   /* Use 'elem' */
@}
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_obj_array_set (pdf_obj_t @var{array}, pdf_size_t @var{index}, pdf_obj_t @var{obj})

Set the @var{index}th element of the array to the given object
@var{obj}.  The object @var{obj} and the array @var{array} should be
associated with the same object document.  A non-scalar direct object
cannot be inserted in more than one container.

If @var{index} equals to the array size then the object is appended at
the end.

If the object previously contained in the @var{index}th position is a
direct object then it is destroyed.  Otherwise it is no longer
referenced.

@table @strong
@item Parameters
@table @var
@item array
A PDF array.
@item index
An index into the array.
@item obj
A PDF object.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The element was inserted at the specified position.
@item PDF_EINVOBJ
The object @var{obj} is a non-scalar direct object already contained
in another object or the object belongs to other document.
@item PDF_EBADDATA
The specified @var{index} is invalid.
@item PDF_ERROR
@end table
@item Usage example
@example
pdf_obj_doc_t *doc;
pdf_obj_t array;
pdf_obj_t elem;
pdf_size_t index;

...

/* Insert numbers as the first 10 elements of the array */
for (index = 0; index < 10; index++)
@{
   elem =  pdf_obj_integer_new (doc,
                                PDF_FALSE,
                                (pdf_u32_t) index);

   if (pdf_obj_array_set (array, index, elem) == PDF_OK)
   @{
      /* Element inserted into the array. */
   @}
@}
@end example
@end table
@end deftypefun

@deftypefun pdf_bool_t pdf_obj_array_weak_p (pdf_obj_t @var{array}, pdf_size_t @var{index})

Determine if the @var{index}th element of @var{array} is a weak
reference.

A weak reference changes the way the garbage collection works.
@xref{Garbage collection in object documents}.

This function returns @code{PDF_FALSE} if @var{array} is not an array
object and if @var{index} is out of bounds.

@table @strong
@item Parameters
@table @var
@item array
A PDF array.
@item index
An index into @var{array}.
@end table
@item Returns
A boolean value:
@table @code
@item PDF_TRUE
The element at @var{index} is a weak reference.
@item PDF_FALSE
The element at @var{index} is not a weak reference.
@end table
@item Usage example
@example
pdf_obj_t array;
pdf_size_t index;
pdf_size_t array_size;

...

/* Determine if some element of array has a weak reference */
array_size = pdf_obj_size (array);
for (index = 0; index < array_size; index++)
@{
   if (pdf_obj_array_weak_p (array, index))
   @{
      /* The index-th element has a weak reference */
   @}
@}
@end example
@end table
@end deftypefun

@deftypefun void pdf_obj_array_weak_set (pdf_obj_t @var{array}, pdf_size_t @var{index}, pdf_bool_t @var{weak_p})

Set if the @var{index}th element of @var{array} is a weak reference.

The effect of this call when @var{weak_p} is @code{PDF_FALSE} is to
remove the effect of a previous call with @var{weak_p} set to
@code{PDF_TRUE}.  In particular it does not set a strong reference to
the object occupying the @var{index}th position in the array.

This function is a no-operation if either @var{array} is not an
array object or @var{index} is not found in the array.

@table @strong
@item Parameters
@table @var
@item array
A PDF array.
@item index
An index into @var{array}.
@item weak_p
A boolean value.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The weak reference was (un)set in the element occupying the
@var{index}th position into @var{array}.
@item PDF_EINVOBJ
@var{array} is not an array object.
@item PDF_EBADDATA
The specified @var{index} is out of bounds.
@item PDF_ERROR
An error prevented the operation to complete.
@end table
@item Usage example
@example
pdf_obj_t array;
pdf_size_t index;
pdf_size_t array_size;

...

/* Remove any weak reference in 'array' */
array_size = pdf_obj_size (array);
for (index = 0; index < array_size; index++)
@{
   pdf_obj_array_weak_set (array, index, PDF_FALSE);
@}
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_obj_array_remove (pdf_obj_t @var{array}, pdf_obj_t @var{obj})

Find the first element equal to @var{obj} and remove it from the
array.

@table @strong
@item Parameters
@table @var
@item array
A PDF array.
@item obj
The PDF object to remove from the array.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
@var{obj} was found and removed from the array.
@item PDF_EINVOBJ
@var{array} is not an array object.
@item PDF_EBADDATA
@var{obj} was not contained in the array.
@item PDF_ERROR
Some error prevented to complete the operation.
@end table
@item Usage example
@example
pdf_obj_t array;
pdf_obj_t elem;

...

/* Remove the third element of the array */
elem = pdf_obj_array_get (array, 2);
if (pdf_obj_array_remove (array, elem) == PDF_OK)
@{
   /* The element was removed from the array */
@}
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_obj_array_remove_at (pdf_obj_t @var{array}, pdf_size_t @var{index})

Find the @var{index}th element and remove it from the array.

@table @strong
@item Parameters
@table @var
@item array
A PDF array.
@item index
The index of the element to remove from the array.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The requested element was found and removed from the array.
@item PDF_EINVOBJ
@var{array} is not an array object.
@item PDF_EBADDATA
The specified @var{index} is invalid.
@item PDF_ERROR
Some error prevented to complete the operation.
@end table
@item Usage example
@example
pdf_obj_t array;

...

/* Remove the third element of the array */
if (pdf_obj_array_remove_at (array, 3) == PDF_OK)
@{
   /* The element was removed */
@}
@end example
@end table
@end deftypefun

@node Dictionary Objects
@subsection Dictionary Objects

A PDF dictionary is an associative table containing pairs of objects.
The first object of each pair is a name object.  The type of the
second object in the pair is unrestricted.

A dictionary entry whose value is null is equivalent to an absent
entry.

@deftypefun pdf_obj_t pdf_obj_dict_new (pdf_obj_doc_t *@var{doc}, pdf_bool_t @var{indirect_p})

Create a  PDF Dictionary object in an object document.

@table @strong
@table @var
@item doc
An object document.
@item indirect_p
A boolean value indicating whether to create an indirect object.
@end table
@item Returns
The newly created object, or @code{PDF_OBJ_NULL} if there is no enough
memory to perform the operation.
@item Usage example
@example
pdf_obj_doc_t *doc;
pdf_obj_t dict;

...

/* Create an empty dictionary object */
dict = pdf_obj_dict_new (doc, PDF_TRUE);
if (PDF_OBJ_IS_NULL (dict))
@{
   /* Not enough memory to create the object */
@}
@end example
@end table
@end deftypefun

@deftypefun pdf_obj_t pdf_obj_dict_get (pdf_obj_t @var{dict}, pdf_obj_t @var{key})

Get an object stored in a PDF dictionary.

@table @strong
@item Parameters
@table @var
@item dict
A PDF dictionary object.
@item key
A PDF name object.
@end table
@item Returns
The object associated with @var{key} in @var{dict}, or
@var{PDF_OBJ_NULL} if there is not an entry in the dictionary with
@var{key}.

If @var{dict} is not a dictionary or @var{key} is not a name object,
this function returns @var{PDF_OBJ_NULL}.
@item Usage example
@example
pdf_obj_doc_t *doc;
pdf_obj_t dict;
pdf_obj_t key;
pdf_obj_t value;

...

/* Get the value associated with "/Foo" */
key = pdf_obj_name_new (doc, PDF_FALSE, "Foo");
value = pdf_obj_dict_get (dict, key);

if (!PDF_OBJ_IS_NULL (value))
@{
   /* The object associated with "/Foo" in the dictionary is
      now in 'value'. */
@}
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_obj_dict_get_str (pdf_obj_t @var{dict}, pdf_char_t *@var{key}, pdf_obj_t *@var{obj})

Get an object stored in a PDF dictionary given a string.

@table @strong
@item Parameters
@table @var
@item dict
A PDF dictionary object.
@item key
A string containing the name of the key, without the preceding slash
character.
@end table
@item Returns
The object associated with @var{str} in @var{dict}, or
@var{PDF_OBJ_NULL} if there is not an entry in the dictionary with
a key having that value.

If @var{dict} is not a dictionary this function returns
@var{PDF_OBJ_NULL}.
@item Usage example
@example
pdf_obj_doc_t *doc;
pdf_obj_t dict;
pdf_obj_t value;

...

/* Get the value associated with "/Foo" */
value = pdf_obj_dict_get (dict, "Foo");
if (!PDF_OBJ_IS_NULL (value))
@{
   /* The object associated with "/Foo" in the dictionary is
      now in 'value'. */
@}
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_obj_dict_set (pdf_obj_t @var{dict}, pdf_obj_t @var{key}, pdf_obj_t @var{val})

Insert an entry in a PDF dictionary, or replace an existing entry.

@table @strong
@item Parameters
@table @var
@item dict
A PDF dictionary object.
@item key
A PDF name object.
@item val
A PDF object.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The value associated with @var{key} in @var{dict} was set to
@var{val}.
@item PDF_EINVOBJ
@var{key} is not a name object or @var{dict} is not a
dictionary object.
@item PDF_ERROR
Some error prevented the operation to complete.  The value in
@var{val} is undefined.
@end table
@item Usage example
@example
pdf_obj_doc_t *doc;
pdf_obj_t dict;
pdf_obj_t key;
pdf_obj_t value;

...

/* Create a dictionary and insert a key-value pair
   into it: /Age -> 29. */
dict = pdf_obj_dict_new (doc, PDF_TRUE);

key = pdf_obj_name_new (doc, PDF_FALSE, "Age");
value = pdf_obj_integer_new (doc, PDF_FALSE, 29);

if (pdf_obj_dict_set (dict, key, value) == PDF_OK)
@{
   /* The pair key-value was inserted in 'dict'. */
@}
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_obj_dict_set_str (pdf_obj_t @var{dict}, pdf_char_t *@var{key}, pdf_obj_t @var{val})

Insert an entry in a PDF dictionary using a string, or replace an
existing entry.

@table @strong
@item Parameters
@table @var
@item dict
A PDF dictionary object.
@item key
A string containing the name of the key, without the preceding slash
character.
@item val
A PDF object.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The value associated with @var{key} in @var{dict} was set to
@item PDF_EINVOBJ
@var{dict} is not a dictionary object.
@item PDF_ERROR
Some error prevented the operation to complete.  The value in
@var{val} is undefined.
@end table
@item Usage example
@example
pdf_obj_doc_t *doc;
pdf_obj_t root_dict;
pdf_obj_t pages_dict;

...

/* Create a /Pages entry in the root dictionary, as an indirect
   object, containing an empty dictionary. */

root_dict = pdf_obj_doc_get_root (doc);
pages_dict = pdf_obj_dict_new (doc, PDF_TRUE);

if (pdf_obj_dict_set_str (root_dir, "/Pages", pages_dict)
    != PDF_ERROR)
@{
   /* The root dictionary now contains a /Pages entry
      whose value is an object reference pointing to the
      indirect dictionary 'pages'. */
@}
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_obj_dict_remove (pdf_obj_t @var{dict}, pdf_obj_t @var{key})

Remove a key-value pair from a dictionary. If the key does not exist
in the dictionary then this is a no-op.

@table @strong
@item Parameters
@table @var
@item dict
A PDF dictionary object.
@item key
A PDF name object.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
@var{key} was found in the dictionary and the pair was removed.
@item PDF_EINVOBJ
Either @var{dict} is not a dictionary object or @var{key} is not a
name object.
@item PDF_ERROR
An error prevented the operation to complete.
@end table
@item Usage example
@example
pdf_obj_doc_t *doc;
pdf_obj_t dict;
pdf_obj_t key;

...

/* Remove the "/Foo" entry from 'dict', if it exists */
key = pdf_obj_name_new (doc, PDF_FALSE, "Foo");

if (pdf_obj_dict_remove (dict, key) == PDF_OK)
@{
   /* The entry, provided it was present, was removed from
      the dictionary. */
@}
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_obj_dict_remove_str (pdf_obj_t @var{dict}, pdf_char_t *@var{key})

Remove a key-value pair from a dictionary.  If the key does nto exist
in the dictionary then this is a no-op.

@table @strong
@item Parameters
@table @var
@item dict
A PDF dictionary object.
@item key
A string containing the textual representation of a PDF Name.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
@var{key} was found in the dictionary and the pair was removed.
@item PDF_EINVOBJ
@var{dict} is not a dictionary object.
@item PDF_ERROR
An error prevented the operation to complete.
@end table
@item Usage example
@example
pdf_obj_doc_t *doc;
pdf_obj_t dict;

...

/* Remove the "/Foo" entry from 'dict', if it exists */
if (pdf_obj_dict_remove (dict, "Foo") == PDF_OK)
@{
   /* The entry, provided it was present, was removed from
      the dictionary. */
@}
@end example
@end table
@end deftypefun

@deftypefun pdf_bool_t pdf_obj_dict_key_p (pdf_obj_t @var{dict}, pdf_obj_t @var{key})

Determine whether an entry exists in a PDF dictionary.

@table @strong
@item Parameters
@table @var
@item dict
A PDF Dictionary object.
@item key
A PDF Name object.
@end table
@item Returns
A PDF boolean value:
@table @code
@item PDF_TRUE
@var{key} is in a key-value pair into @var{dict}.
@item PDF_FALSE
@var{key} is not in a key-value pair into @var{dict}, or @var{dict}
is not a dictionary object, or @var{key} is not a name object.
@end table
@item Usage example
@example
pdf_obj_doc_t *doc;
pdf_obj_t dict;
pdf_obj_t key;
pdf_obj_t value;

...

value = pdf_obj_integer_new (doc, PDF_FALSE, 10);
pdf_obj_dict_set_str (dict, "Foo", value);

pdf_obj_dict_key_str_p (dict, "Foo", value); /* Returns PDF_TRUE */
@end example
@end table
@end deftypefun

@deftypefun pdf_bool_t pdf_obj_dict_key_str_p (pdf_obj_t @var{dict}, pdf_char_t *@var{key})

Determine whether an entry exists in a PDF dictionary.

@table @strong
@item Parameters
@table @var
@item dict
A PDF Dictionary object.
@item key
A string containing the string representation of a PDF Name.
@end table
@item Returns
A PDF boolean value:
@table @code
@item PDF_TRUE
@var{key} is in a key-value pair into @var{dict}.
@item PDF_FALSE
@var{key} is not in a key-value pair into @var{dict}, or @var{dict} is
not a dictionary object.
@end table
@item Usage example
@example
pdf_obj_doc_t *doc;
pdf_obj_t dict;
pdf_obj_t value;

...

value = pdf_obj_integer_new (doc, PDF_FALSE, 10);

pdf_obj_dict_set_str (dict, "Foo", value);

pdf_obj_dict_key_p (dict, key, value); /* Returns PDF_TRUE */
pdf_obj_dict_key_p (dict, value, key); /* Returns PDF_FALSE */
@end example
@end table
@end deftypefun

@deftypefun pdf_bool_t pdf_obj_dict_weak_p (pdf_obj_t @var{dict}, pdf_obj_t @var{key})

Determine whether an entry in a PDF dictionary is a weak entry.

@table @strong
@item Parameters
@table @var
@item dict
A PDF Dictionary object.
@item key
A PDF Name object.
@end table
@item Returns
A PDF boolean value:
@table @code
@item PDF_TRUE
@var{key} is in a weak reference into @var{dict}.
@item PDF_FALSE
@var{key} is not a weak reference into @var{dict}, or @var{key} does
not exist in the dictionary, or @var{dict} is not a dictionary object,
or @var{key} is not a name object.
@end table
@item Usage example
@example
pdf_obj_doc_t *doc;
pdf_obj_t dict;
pdf_obj_t key;

...

/* Determine if the entry "/Foo" has a weak reference in 'dict' */
key = pdf_obj_name_new (doc, PDF_FALSE, "Foo");

pdf_obj_dict_weak_p (dict, key);
@end example
@end table
@end deftypefun

@deftypefun pdf_bool_t pdf_obj_dict_weak_str_p (pdf_obj_t @var{dict}, pdf_char_t *@var{key})

Determine whether an entry in a PDF dictionary is a weak entry.

@table @strong
@item Parameters
@table @var
@item dict
A PDF Dictionary object.
@item key
A string containing the string representation of a PDF Name.
@end table
@item Returns
A PDF boolean value:
@table @code
@item PDF_TRUE
@var{key} is in a weak reference into @var{dict}.
@item PDF_FALSE
@var{key} is not a weak reference into @var{dict}, or @var{key} does
not exist in the dictionary, or @var{dict} is not a dictionary object.
@end table
@item Usage example
@example
pdf_obj_doc_t *doc;
pdf_obj_t dict;
pdf_obj_t key;

...

/* Determine if the entry "/Foo" has a weak reference in 'dict' */
pdf_obj_dict_weak_p (dict, "Foo");
@end example
@end table
@end deftypefun

@deftypefun void pdf_obj_dict_weak_set (pdf_obj_t @var{dict}, pdf_obj_t @var{key}, pdf_bool_t @var{weak_p})

Set an entry in a PDF dictionary as a weak entry.
@xref{Garbage collection in object documents}.

This function is a no-operation if either @var{dict} is not a
dictionary object or @var{key} is not found in the dictionary.

@table @strong
@item Parameters
@table @var
@item dict
A PDF dictionary object.
@item key
A PDF name object.
@item weak_p
The new value for the weak attribute of the key-value pair.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The weak attribute for the pair was set to @var{weak_p}.
@item PDF_EINVOBJ
Either @var{dict} is not a PDF dictionary object or @var{key} is not a
PDF name object.
@item PDF_ERROR
Some error prevented the operation to complete.
@end table
@item Usage example
@example
pdf_obj_doc_t *doc;
pdf_obj_t dict;
pdf_obj_t key;

...

/* Set the weak attribute of the key-value pair in
   'dict' with key "/Foo". */
key = pdf_obj_name_new (doc, PDF_FALSE, "Foo");
pdf_obj_dict_weak_set (dict, key, PDF_TRUE);
@end example
@end table
@end deftypefun

@deftypefun void pdf_obj_dict_weak_set_str (pdf_obj_t @var{dict}, pdf_char_t *@var{key}, pdf_bool_t @var{weak_p})

Set an entry in a PDF dictionary as a weak entry.
@xref{Garbage collection in object documents}.

This function is a no-operation if either @var{dict} is not a
dictionary object or @var{key} is not found in the dictionary.

@table @strong
@item Parameters
@table @var
@item dict
A PDF Dictionary object.
@item key
A string containing the string representation of a PDF name.
@item weak_p
The new value for the weak attribute of the key.
@end table
@item Returns
A PDF status value:
@table @code
@item PDF_OK
The weak attribute for the pair was set to @var{weak_p}.
@item PDF_EINVOBJ
@var{dict} is not a PDF dictionary object.
@item PDF_ERROR
An error prevented the operation to complete.
@end table
@item Usage example
@example
pdf_obj_doc_t *doc;
pdf_obj_t dict;

...

/* Set the weak attribute of the key-value pair in
   'dict' with key "/Foo". */
pdf_obj_dict_weak_set (dict, "Foo", PDF_TRUE);
@end example
@end table
@end deftypefun

@node Stream Objects
@subsection Stream Objects

A PDF stream object is an arbitrary long sequence of octets
characterized by a set of properties.  The properties of a stream
object are specified by a dictionary that appears just before the
stream in the PDF file.

Unlike strings, a stream can be read incrementally and can be of
unlimited length.

All streams must be indirect objects.  Dictionaries describing streams
must be direct objects.

@deftypefun pdf_obj_t pdf_obj_stream_new (pdf_obj_doc_t *@var{doc}, pdf_stm_t @var{stm}, pdf_off_t @var{size}, pdf_obj_t @var{attrs_dict})

Create a PDF Stream object in an object document.

@table @strong
@item Parameters
@table @var
@item doc
An object document.
@item stm
A base layer stream that will be used to retrieve the data for the
stream object. @xref{Filtered Streams}.  The contents of this stream
will be copied to an internal storage by this call.
@item size
The number of octets to read from @var{stm}.  If this parameter is
zero then read from the stream until it gets exhausted.
@item attrs_dict
Dictionary containing keys that will be copied to the dictionary
describing the newly created stream. If this dictionary
contains a list of filters then those filters are applied in inverse
order to the data read from @var{stm}.

Note that any @code{/Length} key present in @var{stm} will be ignored
and replaced by a recalculated entry.

If this parameter is @code{PDF_OBJ_NULL} then it is interpreted as an
empty dictionary.

See the PDF specification for the expected content of the stream
dictionary.
@end table
@item Returns
The newly created object, or @var{PDF_OBJ_NULL} if there is not enough
memory to perform the operation, or if @var{attrs_dict} is not a
dictionary or the null object.
@item Usage example
@example
pdf_obj_doc_t *doc;
pdf_obj_t dict;
pdf_obj_t stream;
pdf_obj_t filter_array;
pdf_string_t data_file_path;
pdf_fsys_file_t data_file;
pdf_stm_t stm;

...

/* Create an arry of filters.  */
filter_array = pdf_obj_array_new (doc, PDF_FALSE, 2);
pdf_obj_array_set (filter_array, 0,
                   pdf_obj_string_new (doc, PDF_FALSE, "ASCII85Decode"));
pdf_obj_array_set (filter_array, 1,
                   pdf_obj_string_new (doc, PDF_FALSE, "LZWDecode"););

/* Create the dictionary */
dict = pdf_obj_dict_new (doc, PDF_FALSE);
pdf_obj_dict_set_str (dict, "Filter", filter_array);

/* Open a filtered stream to a file containing the data to be
   stored in the object stream */
pdf_text_new_from_unicode ("/path/to/data",
                           14, PDF_TEXT_UTF8,
                           &data_file_path);
pdf_fsys_file_open (NULL, data_file_path, PDF_FSYS_OPEN_MODE_READ, &data_file);
pdf_stm_file_new (data_file,
                  0,
                  0, /* Use the default cache size */
                  PDF_STM_READ,
                  &stm);

/* Create the stream object */
stream = pdf_obj_stream_new (doc,
                             stm,
                             0, /* Exhaust the stream */
                             dict);
if (PDF_OBJ_IS_NULL (stream))
@{
   /* Some error prevented the creation of the stream */
@}
@end example
@end table
@end deftypefun

@deftypefun pdf_obj_t pdf_obj_stream_dict (pdf_obj_t @var{stream})

Get the stream dictionary associated with a PDF stream.

@table @strong
@item Parameters
@table @var
@item stream
A stream object.
@end table
@item Returns
The stream dictionary, or @var{PDF_OBJ_NULL} if @var{stream} is not a
stream object.
@item Usage example
@example
pdf_obj_t stream;
pdf_obj_t dict;

/* Create a stream object... */

dict = pdf_obj_stream_dict (stream);
@end example
@end table
@end deftypefun

@deftypefun pdf_off_t pdf_obj_stream_pos (pdf_obj_t @var{stream})

Get the offset of the beginning of @var{stream}'s data in the PDF
file.

You can use this call only after saving the object in a PDF file.

@table @strong
@item Parameters
@table @var
@item stream
A Stream object.
@end table
@item Returns
The offset (in octets) of the beginning of the stream data: the
position just after the @code{stream} keyword.  If the returned number
is @code{0} then an error occurred.
@item Usage example
@example
pdf_obj_doc_t *doc;
pdf_obj_t stream;
pdf_off_t stream_offset;

...

/* Try to get the offset without previously
   saving the object document */
if (stream_offset (stream) == 0)
@{
   /* Error: document was not saved before to
      call pdf_obj_stream_pos */
@}

/* Save the object document */
pdf_obj_doc_save (doc, NULL, PDF_OBJ_DOC_SAVE_FULL, save_params);

/* Get the offset where the data of the stream was
   stored */
if (stream_offset (stream) == 0)
@{
   /* Error obtaining the offset of the stream */
@}
@end example
@end table
@end deftypefun

@deftypefun pdf_obj_t pdf_obj_stream_open (pdf_obj_t @var{stream}, enum pdf_obj_stm_open_mode_e @var{mode})

Create a base layer stream to read the contents of
@var{stream}. The base layer stream @var{stm} is positioning at the
beginning of the data contained in @var{stream}.

The configuration of the filter chain in @var{stm} depends on the
opening mode in @var{mode}.

The client is responsible to close the stream @var{stm}.
@table @strong
@item Parameters
@table @var
@item stream
A Stream object.
@item mode
Mode used to open the stream. @xref{Object Data Types}.
@end table
@item Returns
A newly created base layer stream from which the decoded data stored
in the stream can be read, or @var{PDF_OBJ_NULL} if there is not
enough memory to perform the operation, or @var{stream} is not a
stream object.
@item Usage example
@example
pdf_obj_t stream;
pdf_stm_t stm;

...

/* Get a filtered stream to read the contents
   of 'stream' */
stm = pdf_obj_stream_opn (stream,
                          PDF_OBJ_STM_OPEN_MODE_FILTERED);
if (PDF_OBJ_IS_NULL (stm))
@{
   /* Error opening the stream */
@}
@end example
@end table
@end deftypefun

@node Null Object
@subsection Null Object

A PDF null object has a type and a value that are unequal to those of
any other object.  There is only one possible value for this object
type: the @code{PDF_OBJ_NULL} constant.

@deftp {Constant} PDF_OBJ_NULL
The null object.
@end deftp

It is possible to assign this constant to a @code{pdf_obj_t}, provided
the object previously contained in the variable is disposed if needed.

@node Object Documents
@section Object Documents

At the syntactic level any PDF document can be viewed as a collection
of objects organized in a certain way.

An object document can be associated with a file system file
(@pxref{The Filesystem Module}).

@menu
* Object Document Data Types::
* Opening and Closing Object Documents::
* Managing Object Document Properties::
* Retrieving and Storing Objects::
* Garbage collection in object documents::
@end menu

@node Object Document Data Types
@subsection Object Document Data Types

@deftp {Data Type} pdf_obj_doc_t
Opaque type representing an object level document.
@end deftp

@deftp {Data Type} {struct pdf_obj_doc_save_params_s}

Parameters used when saving an object document.

@table @code
@item pdf_char_t *header
A complete header string, like
@example
%FOO-1.0
@end example
@item pdf_char_t *crypt_key
An encryption key if the security of the document is activated.
@item pdf_size_t crypt_key_size
Size of @code{crypt_key}.
@item struct pdf_pm_s *progress_monitor
A pointer to a progress monitor, or @code{NULL}.
@item void *monitor_client_data
Client-specific data for the progress monitor callbacks.
@end table
@end deftp

@deftp {Data Type} {struct pdf_obj_doc_ctx_s}

Structure used to store a syntactic error in the contents of an object
document.

@table @code
@item pdf_off_t line
Line number containing the error.
@item pdf_char_t *message
Description of the error.
@end table
@end deftp

@node Opening and Closing Object Documents
@subsection Opening and Closing Object Documents

@deftypefun {pdf_obj_doc_t *}pdf_obj_doc_new (pdf_u32_t @var{flags})

Create and return an empty object document.

The newly created object document contains an empty root dictionary
and an optional empty Document Information Dictionary.

@table @strong
@item Parameters
@table @var
@item flags
An integer value containing the ORed value of zero or more
flags. Allowed flags are:
@table @code
@item PDF_OBJ_DOC_CREATE_INFO_DIR
Create an empty @dfn{Document Information Dictionary} in the object
document as an indirect dictionary.  The Info dictionary will be
referenced in the document trailer.
@end table
@end table
@item Returns
A pointer to the newly created object document, or @code{NULL} if
there is not enough memory to perform the operation.
@item Usage example
@example
pdf_obj_doc_t *doc;

doc = pdf_obj_doc_new (0);
if (doc == NULL)
@{
   /* Error creating the object document */
@}
@end example
@end table
@end deftypefun

@deftypefun {pdf_obj_t *}pdf_obj_doc_open (pdf_fsys_t @var{filesystem}, pdf_text_t @var{path}, pdf_char_t *@var{header_string}, pdf_obj_doc_ctx_s **@var{ctx}, pdf_error_t *@var{error})

Open a document object from a file and return it.

@table @strong
@item Parameters
@table @var
@item filesystem
A filesystem implementation. If this parameter is @code{NULL} then the
default disk filesystem is used.  @xref{The Filesystem Module}.
@item path
The path to the file containing the object document.
@item header_string
A string of the form @code{"%PDF-"}.  The string should appear as the
first content of the specified file.  If this parameter is either an
empty string or @code{NULL} then no check is performed.
@item ctx
Pointer to a @code{pdf_obj_doc_ctx_s} structure that will contain the
localization of an error in the document if some arises.  If it is
@code{NULL} then errors won't be recorded.
@item error
A @code{pdf_error_t} to report errors or @code{NULL}.
@table @code
@item PDF_ENOMEM
Not enough memory to perform the operation.
@item PDF_EBADNAME
The path specified in @var{path} is not correct.
@item PDF_EBADPERMS
The file in @var{path} could not be read due to a lack of permissions.
@item PDF_EBADFILE
Parser error while interpreting the contents of the file in
@var{path}.  Information about the location of the error can be found
in @var{ctx} if it was specified.
@end table
@end table
@item Returns
A pointer to the open document, or @code{NULL} if an error arised
opening the document.
@item Usage example
@example
pdf_text_t file_path;
pdf_obj_doc_t *doc;
pdf_error_t *error = NULL;

/* Open a PDF object document from /foo/bar.pdf */
pdf_text_new_from_unicode ("/foo/bar.pdf",
                           12,
                           PDF_TEXT_UTF8,
                           &file_path);

doc = pdf_obj_doc_open (NULL, /* Use the default filesystem */
                        file_path,
                        "%PDF-",
                        &error);
if (doc == NULL)
@{
   /* manage the error... */
   pdf_error_destroy (error);
@}
@end example
@end table
@end deftypefun

@deftypefun pdf_bool_t pdf_obj_doc_close (pdf_obj_doc_t *@var{doc}, pdf_error_t **@var{error})

Close an object document.

If the dirty flag of the object document is set then the contents are
saved before closing.  The performed saving operation is equivalent to
a call to @code{pdf_obj_doc_save} with @code{NULL} flags.

@table @strong
@item Parameters
@table @var
@item doc
A pointer to an object document.
@item error
A @code{pdf_error_t} to report errors or @code{NULL}.
@table @code
@item PDF_ENOMEM
Not enough memory to perform the operation.
@item PDF_ENOSPACE
Not enough disk space to save the document.
@end table
@end table
@item Returns
A boolean value:
@table @code
@item PDF_TRUE
The document was successfully closed.
@item PDF_FALSE
There was an error closing the document.
@end table
@item Usage example
@example
pdf_obj_doc_t *doc;
pdf_error_t   *error;

/* Close an object document... */

if (!pdf_obj_doc_close (mydoc, &error))
@{
   /* Process the error */
   pdf_error_destroy (error);
@}
@end example
@end table
@end deftypefun

@deftypefun pdf_bool_t pdf_obj_doc_save (pdf_obj_doc_t *@var{doc}, pdf_fsys_file_t @var{file}, pdf_u32_t @var{flags}, struct pdf_obj_doc_save_params_s @var{params}, pdf_error_t **@var{error})

Save a document to a file.

@table @strong
@item Parameters
@table @var
@item doc
A pointer to an object document.
@item file
A fsys open file (opened for write) used to write the document data
into.

If this parameter is @code{NULL} then the file associated with
@var{doc} is used for the save operation.
@end table
@item flags
An ORed value of the following defined flags:
@table @code
@item PDF_OBJ_DOC_SAVE_DONT_CREATE_CR
Do not create a cross reference table (or stream) when saving the document.
@item PDF_OBJ_DOC_SAVE_FULL
Do a ``full save'', writing all the objects instead of just the
modified ones.  This option recreates the whole file with all the
objects with a generation number of 0.
@item params
A @code{pdf_obj_doc_save_params_s} structure containing the parameters
of the save operation.
@item error
A @code{pdf_error_t} to report errors or @code{NULL}.
@table @code
@item PDF_ENOMEM
Not enough memory to perform the operation.
@item PDF_ENOSPACE
Not enough disk space to save the document.
@end table
@end table
@item Returns
A boolean value:
@table @code
@item PDF_TRUE
The object document was saved properly.
@item PDF_FALSE
An error prevented the document to be saved.  The value of @var{doc}
is still valid.
@end table
@item Usage example
@example
struct pdf_obj_doc_save_params_s  save_params;
pdf_obj_doc_t                    *doc;
pdf_error_t                     **error;

/* Open an object document 'doc'... */

/* Fill in the save parameters */
save_params.header = "%PDF-1.6";
/* No encryption */
save_params.crypt_key = NULL;
save_params.crypt_key_size = 0;
/* Do not use a progress monitor */
save_params.progress_monitor = NULL;
save_params.monitor_client_data = NULL;

/* Save the document in its associated file */
if (!pdf_obj_doc_save (doc,
                       NULL, /* Use the associated file */
                       PDF_OBJ_DOC_SAVE_FULL,
                       save_params,
                       &error))
@{
   /* Process the error.  */
   pdf_error_destroy (error);
@}
@end example
@end table
@end deftypefun

@node Managing Object Document Properties
@subsection Managing Object Document Properties

@deftypefun void pdf_obj_doc_id (pdf_obj_doc_t *@var{doc}, pdf_obj_t *@var{instance_id}, pdf_obj_t *@var{permanent_id})

Return two ID byte arrays identifying the object document.

@table @strong
@item Parameters
@table @var
@item doc
A pointer to an object document.
@item instance_id
A pointer to a string object to hold the returned instance id. If the
document does not have a instance id then the null object is returned.
@item permanent_id
A pointer to a string object to hold the returned permanent id. If the
document does not have a instance id then the null object is returned.
@end table
@item Usage example
@example
pdf_obj_doc_t *doc;
pdf_obj_t instance_id;
pdf_obj_t permanent_id;

/* Create an object document ... */

pdf_obj_doc_get_id (doc,
                    &instance_id,
                    &permanent_id);

if (!PDF_OBJ_IS_NULL (instance_id))
@{
   /* 'instance_id' is a PDF string object containing the
      instance ID of the document */
@}

if (!PDF_OBJ_IS_NULL (permanent_id))
@{
   /* 'permanent_id' is a PDF string object containing the
      permanent ID of the document */
@}
@end example
@end table
@end deftypefun

@deftypefun void pdf_obj_doc_set_id (pdf_obj_doc_t *@var{doc}, pdf_obj_t @var{instance_id}, pdf_obj_t @var{permanent_id})

Set the two ID byte arrays identifying an object document.

@table @strong
@item Parameters
@table @var
@item doc
A pointer to an object document.
@item instance_id
A string object with the new instance id.
@item permanent_id
A string object with the new permanent id.
@end table
@item Usage example
@example
pdf_obj_doc_t *doc;
pdf_obj_t      instance_id;
pdf_obj_t      permanent_id;

/* Create an object document and instance_id, permanent_id... */

pdf_obj_doc_set_id (doc, instance_id, permanent_id);
@end example
@end table
@end deftypefun

@deftypefun pdf_bool_t pdf_obj_doc_dirty (pdf_obj_doc_t *@var{doc})

Determine whether an object document has the dirty flag set.

@table @strong
@item Parameters
@table @var
@item doc
A pointer to an object document.
@end table
@item Returns
A boolean value indicating the presence of the dirty flag.
@item Usage example
@example
pdf_obj_doc_t *doc;

if (pdf_obj_doc_dirty (doc))
@{
   /* The document needs to be saved. */
@}
@end example
@end table
@end deftypefun

@deftypefun void pdf_obj_doc_set_dirty (pdf_obj_doc_t *@var{doc}, pdf_bool_t @var{dirty_p})

Explicitly set the dirty flag of the object document @var{doc} to
@var{dirty_p}.

If the dirty flag of a document is set then its contents are saved
before the document is closed.  Note that if the dirty flag of the
document is cleared using this function then any modified data will be
lost upon closing.

@table @strong
@item Parameters
@table @var
@item doc
A pointer to an object document.
@item dirty_p
Boolean value.
@end table
@item Usage example
@example
pdf_obj_doc_t *doc;
pdf_text_t     file_path;
pdf_obj_t      catalog;
pdf_obj_t      foo_value;

/* Open an object document */
pdf_text_new_from_unicode ("/foo/bar.pdf",
                           12,
                           PDF_TEXT_UTF8,
                           &file_path);

doc = pdf_obj_doc_open (NULL, /* Use the default filesystem */
                        file_path,
                        "%PDF-",
                        NULL);

/* Modify the object document by adding a /Foo entry to
   the catalog. This operation will set the dirty flag of
   the document. */
catalog = pdf_obj_doc_get_root (doc);
foo_value = pdf_obj_integer_new (doc, PDF_FALSE, 10);
pdf_obj_dict_put_str (catalog, "Foo", foo_value);

/* Clear the dirty flag of the document. */
pdf_obj_doc_set_dirty (doc, PDF_FALSE);

/* Close the document.  The /Foo entry in the catalog dictionary is
   lost, since the document is not saved. */
pdf_obj_doc_close (doc, NULL);
@end example
@end table
@end deftypefun

@node Retrieving and Storing Objects
@subsection Retrieving and Storing Objects

A PDF object document contains two special objects that can be
accessed using specific-purpose functions:

@itemize @minus
@item The @dfn{Document Information Dictionary}.  It is optional.
@item The @dfn{root object}, that is the catalog dictionary in a well-formed PDF document.  It is mandatory.
@end itemize

Any other indirect object contained in the object document can be
accessed using an object identifier.

@deftypefun pdf_obj_t pdf_obj_doc_info_dict (pdf_obj_doc_t *@var{doc})

Return the Document Information Dictionary of an object document.

@table @strong
@item Parameters
@table @var
@item doc
A pointer to an object document.
@end table
@item Returns
The info dictionary of @var{doc}, or @code{PDF_OBJ_NULL} if the
document does not contain an info fictionary.
@item Usage example
@example
pdf_obj_doc_t *doc;
pdf_obj_t      info_dict;

/* Get the Document Information Dictionary of the
   object document. */
info_dict = pdf_obj_doc_info_dict (doc);

if (PDF_OBJ_IS_NULL (info_dict))
@{
   /* The object document does not feature an info
      dictionary. */
@}
@end example
@end table
@end deftypefun

@deftypefun pdf_bool_t pdf_obj_doc_set_info_dict (pdf_obj_doc_t *@var{doc}, pdf_obj_t @var{info_dict})

Set the info dictionary of a object document.

@var{info_dict} should be an indirect dictionary object.  If it is
associated with a different document then a deep copy is performed
before to set it as the Document Information Dictionary of
@var{doc}.

If the document already contains an info dictionary, it is destroyed.

@table @strong
@item Parameters
@table @var
@item doc
An object document.
@item info_dict
An indirect dictionary object.
@end table
@item Returns
A boolean value:
@table @code
@item PDF_TRUE
The dictionary @var{info_dict} was set as the new Document Information
Dictionary of @var{doc}.
@item PDF_FALSE
The specified object @var{info_dict} is not of the proper type.
@end table
@item Usage example
@example
pdf_obj_doc_t *doc;
pdf_obj_t      info_dict;

/* Create an object document without an info dictionary */
doc = pdf_obj_doc_new (0);

/* Create an info dictionary */
info_dict = pdf_obj_dict_new (doc, PDF_TRUE);

/* Set it as the new info dictionary in 'doc' */
pdf_obj_doc_set_info_dict (doc, info_dict);
@end example
@end table
@end deftypefun

@deftypefun pdf_obj_t pdf_obj_doc_root (pdf_obj_doc_t *@var{doc})

Get the root object (maybe the catalog of a well-formed PDF document)
of an object document.

@table @strong
@item Parameters
@table @code
@item doc
A pointer to an object document.
@end table
@item Returns
The root dictionary of @var{doc}.
@item Usage example
@example
pdf_obj_doc_t *doc;
pdf_obj_t      root_dict;

/* Get the root object of an object document */
root_dict = pdf_obj_doc_root (doc);
@end example
@end table
@end deftypefun

@deftypefun pdf_obj_t pdf_obj_doc_get (pdf_obj_doc_t *@var{doc}, pdf_obj_id_t @var{obj_id})

Get an object from an object document given its object id.  The object
returned has the latest generation number.

@table @strong
@item Parameters
@table @var
@item doc
A pointer to an object document.
@item obj_id
The object identifier of the desired object.
@end table
@item Returns
The indirect object, or @code{PDF_OBJ_NULL} if an object with the
specified id does not exit in the document.
@item Usage example
@example
pdf_obj_doc_t *doc;
pdf_obj_t      pages_dir;

/* Get the pages dictionary of 'doc' using its object id */
pages_dir = pdf_obj_doc_get (doc, 5);
@end example
@end table
@end deftypefun

@node Garbage collection in object documents
@subsection Garbage collection in object documents

A garbage collector is provided by the library to remove non-reachable
objects from an object document.

A @dfn{non-reachable object} is an indirect object that cannot be
reached starting from the root dictionary of the object document. A
special case is the Document Information Dictionary.  If it is present
it is never collected even if it is not reachable.

The algorithm implemented by the collector is:

@enumerate
@item
Mark the Document Information Dictionary if it exists.
@item
Starting from the root dictionary, inclusive, mark any reachable
object that is not a weak reference.
@item
For every non-marked object...
@enumerate
@item
If its acquire counter is @code{1}, destroy it freeing any used
memory.  Any @code{pdf_obj_t} referencing the object becomes invalid.
@end enumerate
@end enumerate

Note that the garbage collector is never called implicitly.

@deftypefun void pdf_obj_doc_gc (pdf_obj_doc_t *@var{doc})

Garbage collect non-reachable indirect objects in an object document.

@table @strong
@item Parameters
@table @var
@item doc
A pointer to an object document.
@end table
@item Usage example
@example
pdf_obj_doc_t *doc;
pdf_obj_t      unreachable_obj;

doc = pdf_obj_new (0);
unreachable_obj = pdf_obj_integer_new (doc, PDF_TRUE, 10);

/* Garbage-collect the document and save its
   content. */
pdf_obj_doc_gc (doc);
/* 'unreachable_obj' has been collected and its value is now
   undefined. */
@end example
@end table
@end deftypefun

@node Document Layer
@chapter Document Layer

@node Page Contents Layer
@chapter Page Contents Layer

@node Implementation Limits
@chapter Implementation Limits

The limits documented in this chapter are not imposed by neither of
the supported PDF specifications, but by this specific
implementation.

In no case the implementation limits are violating the PDF
specifications.

@menu
* Architectural limits::
* Memory limits::
@end menu

@node Architectural limits
@section Architectural limits

@multitable @columnfractions .20 .15 .65
@headitem Quantity @tab Limit @tab Description
@item Size of a PDF file
@tab 10^10 bytes
@tab Largest supported PDF file using a cross-reference table.
@item integer
@tab 2147483647
@tab Largest integer value.
@item integer
@tab -2147483647-1
@tab Smallest integer value.
@item real
@tab FLT_MAX
@tab Largest real value.
@item real
@tab FLT_MIN
@tab Smallest real value.
@item string in content stream
@tab SIZE_MAX/2
@tab Maximum length of a string contained in a content stream, in
bytes.
@item name
@tab 32768
@tab Maximum length of a name, in octets.
@item indirect object
@tab ??
@tab Maximum number of indirect objects in a PDF file.
@item content stream objects
@tab 2^32
Maximum number of objects in a content stream.
@item linked content stream objects
@tab 2^32
Maximum number of objects in linked content streams.
@end multitable

@node Memory limits
@section Memory limits

TBC.


@c FDL
@c ===

@node GNU Free Documentation License
@appendix GNU Free Documentation License

@include fdl.texi


@c The indexes
@c ===========

@node Global variable index
@unnumbered Global variable index

@printindex vr

@node Data type index
@unnumbered Data type index

@printindex tp

@node Function index
@unnumbered Function index

@printindex fn


@bye
