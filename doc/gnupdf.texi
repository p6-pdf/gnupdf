\input texinfo
@comment $Id: gnupdf.texi,v 1.11 2007/12/21 19:23:28 jemarch Exp $
@comment %**start of header
@setfilename gnupdf.info
@settitle GNU PDF Library Reference
@comment %**end of header

@set EDITION first
@set VERSION 0.1

@copying 
This is the @strong{@value{EDITION}} edition of the @cite{GNU PDF Library
Reference}, updated for @strong{libgnupdf} version @strong{@value{VERSION}}.

Copyright @copyright{} 2007 Free Software Foundation, Inc.

@quotation
Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.2 or
any later version published by the Free Software Foundation; with no
Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts. A
copy of the license is included in the section entitled ``GNU Free
Documentation License''.
@end quotation
@end copying

@dircategory Software libraries
@direntry
* gnupdf: (gnupdf).             The GNU PDF Library reference.
@end direntry

@titlepage
@sp 6
@center @titlefont{GNU PDF Library Reference}
@sp 4
@center @value{EDITION} Edition, Updated for version @value{VERSION}.
@sp 5
@center Jos@'e E. Marchesi
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@contents

@ifnottex
@node Top
@top GNU PDF Library Reference

GNU PDF Library Reference

@insertcopying
@end ifnottex

@menu
* Overview::            The GNU PDF library in brief.
* Base Layer::          Base library facilities.
* Object Layer::        Editing the object structure of a PDF file.
* Document Layer::      Editing the document-level structure of a PDF
                          file.
* Page Contents Layer::  Editing the contents of pages.
* GNU Free Documentation License::  Distribution terms of this manual.

Indices

* Global variable index::       
* Data type index::             
* Function index::              
@end menu

@node Overview
@chapter Overview

@node Base Layer
@chapter Base Layer

@menu
* Base Layer Overview::
* Error Management::
* Memory Allocation::
* Basic Types::
* Hash Tables::
* Lists::
* Filtered Streams::
* Floating Point Arithmetic::
* Text Encoding::
* Time Management::
* Accessing the File System::
@end menu

@node Base Layer Overview
@section Overview

The base layer of the GNU PDF Library provide system-independent
access to several facilities.

The implemented facilities are organized into modules. Each module
export an API to be used by the client application or other layers of
the library. Some modules make use of the facilities implemented in
other modules (such as allocation or error functions).

@node Error Management
@section Error Management



@node Memory Allocation
@section Memory Allocation

The memory allocation module provides system-independent heap memory
allocation and deallocation. The usual malloc/free/realloc schema is
used to provide this service.

@deftypefun char* pdf_alloc (int size)

Allocates heap memory.

@table @strong
@item Parameters

@table @var
@item size
The requested number of octects to allocate.

If there is not enough available memory to satisfy the petition a
fatal error is signaled killing the current process. An error status
is returned to the operating system.
@end table

@item Returns
A pointer to the newly allocated memory. 

@item Usage example
@example
int *p;

p = (int *) pdf_alloc (sizeof(int));
p = 666;
@end example
@end table
@end deftypefun

@deftypefun void pdf_dealloc (char *pointer)

Deallocates heap memory.

@table @strong
@item Parameters

@table @var
@item pointer
A pointer pointing to the memory we want to deallocate. The memory to
deallocate should have been previously allocated using
@code{pdf_alloc}.
@end table

@item Returns
None.

@item Usage Example

@example
char *p;

p = (char *) pdf_alloc (21);
pdf_dealloc (p);
@end example
@end table
@end deftypefun

@deftypefun char* pdf_realloc (char *pointer, int size)

Reallocates memory.

@table @strong
@item Parameters

@table @var
@item pointer
A pointer to previously allocated memory. 

The memory to reallocate should have been allocated using
@code{pdf_alloc} or @code{pdf_realloc}.
@item size
The new size of the allocated memory chunk. 

If the requested size is shorter than the original size of the
allocated memory then it is truncated. Any previous contents in the
memory will be lost.

If the requested size is larger or equal than the original size of the
allocated memory then the previous contents of the allocated memory
remains. The contents of newly allocated memory are undetermined.

If there is not enough available memory to satisfy the petition a
fatal error is signaled killing the current process. An error status
is returned to the operating system.
@end table

@item Returns
A pointer to the reallocated memory.

@item Usage Example
@example
char *p;

p = (char *) pdf_alloc (4);
strncpy (p, "abcd", 4);

/* p now points to "abcd" */

p = (char *) pdf_realloc (5);
p[4] = 'e';

/* p now points to "abcde" */

p = (char *) pdf_realloc (4);

/* p now points to "abcd" */

pdf_dealloc (p);
@end example
@end table
@end deftypefun

@node Basic Types
@section Basic Types

@node Hash Tables
@section Hash Tables

@node Lists
@section Lists

@node Filtered Streams
@section Filtered Streams

@node Floating Point Arithmetic
@section Floating Point Arithmetic

@menu
* Floating Point Types::
* Point Manipulation Functions::
* Rectangle Manipulation Functions::
* Quadrilateral Manipulation Functions::
* Matrix Manipulation Functions::
* Interpolation Functions::
@end menu

@node Floating Point Types
@subsection Floating Point Types

@deftp {Data Type} pdf_real_t
A floating-point number.
@end deftp

@deftp {Data Type} struct pdf_point_s

This structure represents a single point. The coordinates of the point
are made using floating point numbers.

@table @code
@item pdf_real_t h
Horizontal coordinate.
@item pdf_real_t v
Vertical coordinate.
@end table
@end deftp

@deftp {Data Type} struct pdf_rect_s

This structure represents a rectangle. It is composed by the
coordinates for its four sides.

The rectangle sides should be horizontal and vertical and opposite
sides should be parallel.

@table @code
@item pdf_real_t left
@code{x} coordinate for the left points.
@item pdf_real_t top
@code{y} coordinate for the upper points.
@item pdf_real_t right
@code{x} coordinate for the right points.
@item pdf_real_t bottom
@code{y} coordinate for the bottom points.
@end table
@end deftp

@deftp {Data Type} struct pdf_quad_s
This structure represents a quadrilateral. It is composed by four
corners (floating-point points).
@table @code
@item pdf_point_t tl
Top-left point.
@item pdf_point_t tr
Top-right point.
@item pdf_point_t bl
Bottom-left point.
@item pdf_point_t br
Bottom-right point.
@end table
@end deftp

@deftp {Data Type} struct pdf_matrix_s
This structure represents a 3x3 matrix.

@table @code
@item pdf_real_t a11
@item pdf_real_t a12
@item pdf_real_t a13
First row.
@item pdf_real_t a21
@item pdf_real_t a22
@item pdf_real_t a23
Second row.
@item pdf_real_t a31
@item pdf_real_t a32
@item pdf_real_t a33
Third row.
@end table
@end deftp

@node Point Manipulation Functions
@subsection Point Manipulation Functions

@node Quadrilateral Manipulation Functions
@subsection Quadrilateral Manipulation Functions

@node Rectangle Manipulation Functions
@subsection Rectangle Manipulation Functions

@node Matrix Manipulation Functions
@subsection Matrix Manipulation Functions

@deftypefun pdf_status_t pdf_fp_matrix_concat (pdf_matrix_t result, pdf_matrix_t m1, pdf_matrix_t m2)

@end deftypefun

@deftypefun pdf_status_t pdf_fp_matrix_invert (pdf_matrix_t result, pdf_matrix_t m)

@end deftypefun

@deftypefun pdf_status_t pdf_fp_matrix_transform (pdf_point_t result, pdf_matrix_t m, pdf_point_t p)

@end deftypefun

@deftypefun pdf_status_t pdf_fp_matrix_transform_rect (pdf_rect_t result, pdf_matrix_t m, pdf_rect_t rect)

@end deftypefun

@node Interpolation Functions
@subsection Interpolation Functions

@node Text Encoding
@section Text Encoding

@node Time Management
@section Time Management

@menu
* Time Related Data Types::
* Time Creation and Destruction::
* Managing Time Values::
* Getting Time Intervals::
* Time Comparison::
* Time Printing and Parsing::
* Getting the Current Time::
* Time Span Creation and Destruction::
* Managing Time Span Values::
* Time Span Comparison::
* Calendar Spans Management::
@end menu

@node Time Related Data Types
@subsection Time Related Data Types

@deftp {Data Type} pdf_time_t
A variable of type @code{pdf_time_t} contain information about a
particular date and time.

Note that leap seconds are not considered.
@end deftp

@deftp {Data Type} pdf_time_span_t
A variable of type @code{pdf_time_span_t} represent a span of time.

@end deftp

@deftp {Data Type} struct pdf_time_cal_s
This structure holds information about a specific time represented in
calendar items: years, months, days, day of week, hours, minutes, seconds,
milliseconds and the relative offset with GMT.

@table @code
@item pdf_i32_t year
A year number. Negative values may be supported in some systems.
@item pdf_u32_t month
A month number. The valid range is @code{1..12}.
@item pdf_u32_t day
A day number. The valid range is @code{1..31}.
@item pdf_u32_t dow
Day of the week. The valid range is @code{1..7} (Monday to Sunday).
@item pdf_u32_t hour
An hour. The valid range is @code{0..23}.
@item pdf_u32_t minute
A minute. The valid range is @code{0..59}.
@item pdf_u32_t sec
A second. The valid range is @code{0..59}.
@item pdf_u32_t usec
A microsecond. The valid range is @code{0..999999}.
@item pdf_i32_t gmt_offset
A GMT offset.
@end table
@end deftp

@deftp {Data Type} struct pdf_time_cal_span_s
This structure holds information about a time span represented in
calendar items: years, months, days, hours, minutes and seconds.

@table @code
@item pdf_u32_t year
@item pdf_u32_t month
@item pdf_u32_t day
@item pdf_u32_t hour
@item pdf_u32_t minute
@item pdf_u32_t second
@end table
@end deftp

@deftp {Data Type} enum pdf_time_format_e
Enumeration containing the several supported time formats used to
convert a time to a string representation or to parse a time from a
string representation.

@table @code
@item PDF_TIME_FORMAT_PDF
@item PDF_TIME_FORMAT_UNIVERSAL
@item PDF_TIME_FORMAT_UNIVERSAL_H
@item PDF_TIME_FORMAT_ASN1
@item PDF_TIME_FORMAT_GENERALIZED_ASN1
@end table
@end deftp

@node Time Creation and Destruction
@subsection Time Creation and Destruction

@deftypefun pdf_time_t pdf_time_new (void)
Create a new time and set it to the Epoch: Jan 1 1970-01-01 00:00:00 UTC

@table @strong
@item Parameters
None.

@item Returns
The newly created time object.
If an error occurs then @code{NULL} is returned.

@item Usage example
@example
pdf_time_t mytime;

mytime = pdf_time_new ();
if (mytime == NULL)
@{
  /* Error */
@}
@end example
@end table
@end deftypefun

@deftypefun pdf_time_t pdf_time_dup (pdf_time_t orig)
Dup a new time variable from a given one, allocating memory.

@table @strong
@item Parameters

@table @var
@item orig
The time variable to be dupped. Should be a properly created time
variable.
@end table
@item Returns
@itemize @bullet
@item
A new time variable containing a copy of @var{orig} values.
@item
@code{NULL} if there is an error.
@end itemize
@item Usage example
@example
pdf_time_t orig;
pdf_time_t new_time;

orig = pdf_time_new ();
new_time = pdf_time_dup (orig);

if (new_time == NULL)
@{
  /* Error */
@}
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_time_destroy (pdf_time_t time)
Destroy @var{mytime} and free all used memory.

@table @strong
@item Parameters
@table @var
@item time
The time variable to be destroyed. Should be a properly created time
variable.
@end table
@item Returns
@code{PDF_OK}.
@item Usage example
@example
pdf_time_t mytime;

mytime = pdf_time_new ();
pdf_time_destroy (mytime);
@end example
@end table
@end deftypefun

@node Managing Time Values
@subsection Managing Time Values

@deftypefun pdf_status_t pdf_time_copy (pdf_time_t orig, pdf_time_t copy)
Copies the data from @var{orig} to @var{copy}.

@table @strong
@item Parameters
@table @var
@item orig
The time whose data is to be copied. Should be a properly created time variable.
@item copy
The time to receive the data from @var{orig}. Should be a properly
created time variable.

Note that any previous data is destroyed.
@end table
@item Returns
@itemize @bullet
@item
@code{PDF_OK} if the copy succeeded.
@end itemize
@item Usage example
@example
pdf_time_t orig;
pdf_time_t copy;

orig = pdf_time_new ();
copy = pdf_time_new ();

if (!pdf_time_copy (orig, copy))
@{
  /* Error */
@}
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_time_clear (pdf_time_t time)
Reset @var{time} to the newly created state. After this call
@var{time} will contain the same date as if returned by
@code{pdf_time_new}.

@table @strong
@item Parameters
@table @var
@item time
The time variable to clear. Should be a properly create time variable.
@end table
@item Returns
@code{PDF_OK}.
@item Usage example
@example
pdf_time_t mytime;

mytime = pdf_time_new ();

/* ...manipulate `mytime'... */

pdf_time_clear (mytime);
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_time_add_cal_span (pdf_time_t time, struct pdf_time_cal_span_s cal_span)
Add the time span represented by @var{cal_span} to @var{time}.

@table @strong
@item Parameters

@table @var
@item time
A properly created time variable.
@item cal_span
A calendar span with valid values.
@end table

@item Returns

@table @code
@item PDF_OK
The operation successfully finished.
@item PDF_E_BADDATA
The data in @var{cal_span} is invalid.
@end table

@item Usage example
@example
pdf_time_t mytime;
struct pdf_time_cal_span_s cal_span;

mytime = pdf_time_new (); /* Initialized to Jan 1 1970-01-01 00:00:00 */

cal_span.year = 30;
cal_span.month = 7;
cal_span.day = 20;
cal_span.hour = 21;
cal_span.minute = 0;
cal_span.second = 0;

if (pdf_time_add_cal_span (mytime, cal_span) == PDF_E_BADDATA)
@{
  /* Bad data in `cal_span' */
@}
else
@{
  /* `time' now contains Aug 21 2000-08-21 21:00:00 */
@}
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_time_sub_cal_span (pdf_time_t time, struct pdf_time_cal_span_s cal_span)
Subtract the time span represented by @var{cal_span} to @var{time}.

@table @strong
@item Parameters

@table @var
@item time
A properly created time variable.
@item cal_span
A calendar span with valid values.
@end table

@item Returns

@table @code
@item PDF_OK
The operation successfully finished.
@item PDF_E_BADDATA
The data in @var{cal_span} is invalid.
@end table

@item Usage example
@example
pdf_time_t mytime;
struct pdf_time_cal_span_s cal_span;

mytime = pdf_time_new (); /* Initialized to Jan 1 1970-01-01 00:00:00 */

cal_span.year = 30;
cal_span.month = 7;
cal_span.day = 20;
cal_span.hour = 21;
cal_span.minute = 0;
cal_span.second = 0;

if (pdf_time_add_cal_span (mytime, cal_span) == PDF_E_BADDATA)
@{
  /* Bad data in `cal_span' */
@}
else
@{
  /* `time' now contains Aug 21 2000-08-21 21:00:00 */
@}

if (pdf_time_sub_cal_span (mytime, cal_span) == PDF_E_BADDATA)
@{
  /* Bad data in `cal_span' */
@}
else
@{
  /* `time' now contains Jan 1 1970-01-01 00:00:00 */
@}
@end example
@end table
@end deftypefun


@deftypefun pdf_status_t pdf_time_add_span (pdf_time_t time, pdf_time_span_t time_span)
Add the time span contained in @var{time_span} to @var{time}.

@table @strong
@item Parameters

@table @var
@item time
A properly created time variable.
@item time_span
A properly created time span.
@end table

@item Returns

@table @code
@item PDF_OK
The operation successfully finished.
@end table

@item Usage example
@example
pdf_time_t mytime;
pdf_time_span_t myspan;

mytime = pdf_time_new ();

/* ...create and initialize `myspan'... */

pdf_time_add_span (mytime, myspan);
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_time_sub_span (pdf_time_t time, pdf_time_span_t time_span)
Subtract the time span contained in @var{time_span} to @var{time}.

@table @strong
@item Parameters

@table @var
@item time
A properly created time variable.
@item time_span
A properly created time span.
@end table

@item Returns

@table @code
@item PDF_OK
The operation successfully finished.
@end table

@item Usage example
@example
pdf_time_t mytime;
pdf_time_span_t myspan;

mytime = pdf_time_new ();

/* ...create and initialize `myspan'... */

pdf_time_sub_span (mytime, myspan);
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_time_get_local_cal (pdf_time_t time, struct pdf_time_cal_s local_cal)
Fill @var{local_cal} with the local calendar time of @var{time}.

@table @strong
@item Parameters

@table @var
@item time
A properly created time variable.
@item local_cal
A time calendar structure that will hold the local time of @var{time}.
@end table

@item Returns

@table @code
@item PDF_OK
The operation successfully finished.
@end table

@item Usage example
@example
pdf_time_t mytime;
struct pdf_time_cal_s cal;

/* ...create and manipulate `mytime'... */

pdf_time_get_local_cal (mytime, cal);
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_time_get_utc_cal (pdf_time_t time, struct pdf_time_cal_s cal_time)
Get the UTC calendar time of a given time variable.

@table @strong
@item Parameters

@table @var
@item time
A properly created time variable.
@item cal_time
A calendar time structure that will hold the UTC time of @var{time}.
@end table

@item Returns

@table @code
@item PDF_OK
The operation successfully finished.
@end table

@item Usage example
@example
pdf_time_t mytime;
sruct pdf_time_cal_s cal_time;

/* ...create and manipulate `mytime'... */

pdf_time_get_utc_cal (mytime, cal_time);
@end example
@end table
@end deftypefun

@deftypefun pdf_time_from_cal (pdf_time_t time, struct pdf_time_cal_s cal_time)
Set the value of a time variable to a given calendar time.

@table @strong
@item Parameters

@table @var
@item time
A properly created time variable.
@item cal_time
A calendar time structure.
@end table

@item Returns

@table @code
@item PDF_OK
The operation successfully finished.
@item PDF_E_BADDATA
There is invalid data in the calendar structure @var{cal_time}.
@end table

@item Usage example
@example
pdf_time_t mytime;
struct pdf_time_cal_s mycaltime;

mytime = pdf_time_new ();

mycaltime.year = 2000;
mycaltime.month = 8;
mycaltime.day = 10;
mycaltime.dow = 0; /* This field is ignored by `pdf_time_from_cal' */
mycaltime.hour = 0;
mycaltime.minute = 0;
mycaltime.sec = 0;
mycaltime.usec = 0;
mycaltime.gmt_offset = 1;

if (pdf_time_from_cal (mytime, mycaltime) == PDF_E_BADDATA)
@{
  /* Bad data in `mycaltime' */
@}
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_time_set_local_offset (pdf_time_t time)
Set the local time offset of @var{time} to the one used by the
operating system.

@table @strong
@item Parameters

@table @var
@item time
A properly created time variable.
@end table

@item Returns

@table @code
@item PDF_OK
The operation successfully finished.
@end table

@item Usage example
@example
pdf_time_t mytime;

mytime = pdf_time_new ();
pdf_time_set_local_offset (time);
@end example
@end table
@end deftypefun

@node Getting Time Intervals
@subsection Getting Time Intervals

@deftypefun pdf_status_t pdf_time_diff (pdf_time_t time1, pdf_time_t time2, struct pdf_time_cal_span_s cal_span)
Calculate the time span that goes from @var{time1} to @var{time2} and
store it in @var{cal_span}.

Note that the highest possible distribution inside @var{cal_span} is used.
@table @strong
@item Parameters

@table @var
@item time1
The beginning of the time interval (inclusive).
@item time2
The end of the time interval (exclusive).
@item cal_span
The calendar time span structure that will hold the time span that
goes between @var{time1} and @var{time2}.
@end table

@item Returns

@table @code
@item PDF_OK
The operation successfully finished.
@end table

@item Usage example
@example
pdf_time_t time_begin;
pdf_time_t time_end;
struct pdf_time_cal_span_s cal_span;

/* ...create and manipulate `time_begin' and `time_end' */

pdf_time_diff (time_begin, time_end, cal_span);
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_time_diff (pdf_time_t time1, pdf_time_t time2, pdf_time_span_t time_span)
Calculate the time span between two dates.

@table @strong
@item Parameters

@table @var
@item time1
The beginning time. Should be a properly created time.
@item time2
The ending time. Should be a properly created time.
@item time_span
The time span variable that will hold the difference between
@var{time1} and @var{time2}. Should be a properly created time
span. Any previous content of @var{time_span} will be destroyed.
@end table

@item Returns

@table @code
@item PDF_OK
The operation successfully finished.
@end table

@item Usage example
@example
pdf_time_t time1;
pdf_time_t time2;
pdf_time_span_t time_span;

/* ...create and manipulate `time1', `time2' and `time_span'... */

pdf_time_diff (time1, time2, time_span);
@end example
@end table
@end deftypefun

@node Time Comparison
@subsection Time Comparison

@deftypefun pdf_i32_t pdf_time_cmp (pdf_time_t time1, pdf_time_t time2)
Compares two times.

@table @strong
@item Parameters

@table @var
@item time1
The first time to compare.
Should be a properly created time variable.
@item time2
The second time to compare.
Should be a properly created time variable.
@end table

@item Returns

@table @code
@item -1
If @var{time1} precedes @var{time2}.
@item 0
If @var{time1} and @var{time2} contain the same time.
@item 1
If @var{time2} precedes @var{time1}.
@end table

@item Usage example
@example
pdf_time_t time1;
pdf_time_t time2;

time1 = pdf_time_new ();
time2 = pdf_time_new ();

/* ...manipulate `time1' and `time2'... */

switch (pdf_time_cmp (time1, time2))
@{
  case -1:
  @{
    /* `time1' precedes `time2' */
    break;
  @}
  case 0:
  @{
    /* `time1' contain the same time than `time2' */
    break;
  @}
  case 1:
  @{
    /* `time2' precedes `time1' */
    break;
  @}
@}
@end example
@end table
@end deftypefun

@node Time Printing and Parsing
@subsection Time Printing and Parsing

@deftypefun char* pdf_time_to_string (pdf_time_t time, enum pdf_time_format_e time_format)
Create a string representation of a given time.

@table @strong
@item Parameters

@table @var
@item time
A properly created time variable.
@item time_format
The format to use when creating the string representation of @var{time}. 
@end table

@item Returns
The string representation of @var{time}.

@table @code
@item NULL
If there is an error.
@end table

@item Usage example
@example
pdf_time_t mytime;
char *mytime_str;

/* ...create and manipulate `mytime'... */

mytime_str = pdf_time_to_string (mytime, PDF_TIME_FORMAT_PDF);
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_time_from_string (pdf_time_t mytime, char *time_str, enum pdf_time_format_e time_format)
Get a string containing a time specification in some format and fill a
time variable with the parsed values.

@table @strong
@item Parameters

@table @var
@item mytime
A properly created time variable.

@item time_str
A null-terminated string representation of a time.
@item time_format
The format indicating how to parse @var{time_str}.
@end table

@item Returns

@table @code
@item PDF_OK

@item PDF_E_BADDATA
Error while parsing @var{time_str} according to @var{time_format}.
@end table

@item Usage example
@example
pdf_time_t mytime;
char time_str[] = "FIXME: put a correct PDF time there";

mytime = pdf_time_new ();
if (pdf_time_from_string (mytime, 
                          time_str,
                          PDF_TIME_FORMAT_PDF) == PDF_E_BADDATA)
@{
  /* Error while parsing `time_str' according to `PDF_TIME_FORMAT_PDF' */
@}
@end example
@end table
@end deftypefun

@node Getting the Current Time
@subsection Getting the Current Time

@deftypefun pdf_status_t pdf_time_set_to_current_local_time (pdf_time_t time)
Set the value of @var{time} to the current local time used by the
operating system.

@table @strong
@item Parameters

@table @var
@item time
A properly created time variable.
@end table

@item Returns

@table @code
@item PDF_OK
The operation successfully finished.
@end table

@item Usage example
@example
pdf_time_t mytime;

mytime = pdf_time_new ();

pdf_time_set_to_current_local_time (mytime);
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_time_set_to_current_utc_time (pdf_time_t time)
Set the value of @var{time} to the current UTC time used by the operating system.

@table @strong
@item Parameters

@table @var
@item time
A properly created time variable.
@end table

@item Returns

@table @code
@item PDF_OK
The operation successfully finished.
@end table

@item Usage example
@example
pdf_time_t mytime;

mytime = pdf_time_new ();

pdf_time_set_to_current_utc_time (mytime);
@end example
@end table
@end deftypefun

@node Time Span Creation and Destruction
@subsection Time Span Creation and Destruction

@deftypefun pdf_time_span_t pdf_time_span_new (void)

Allocate and return a new time span variable. The time span is
initialized with a zero value (zero seconds).

@table @strong
@item Parameters

None.

@item Returns

The newly created time span variable or @code{NULL} if there is an
error. 

@item Usage example
@example
pdf_time_span_t span;

span = pdf_time_span_new ();
@end example
@end table
@end deftypefun

@deftypefun pdf_time_span_t pdf_time_span_dup (pdf_time_span_t span)

Allocate and dup a new time span from an existing one. The new time
span has the same value as the base time span.

@table @strong
@item Parameters

@table @var
@item span
A properly created time span variable.
@end table

@item Returns

The newly created time span variable.

@item Usage example
@example
pdf_time_span_t span;
pdf_time_span_t new_span;

/* ...create and manipulate `span'... */

new_span = pdf_time_span_dup (span);
@end example
@end table
@end deftypefun


@deftypefun pdf_status_t pdf_time_span_destroy (pdf_time_span_t span)

Destroy a time span variable freeing all used memory.

@table @strong
@item Parameters

@table @var
@item span
The time span variable to be destroyed.
@end table

@item Returns

@table @code
@item PDF_OK
The operation successfully finished.
@end table

@item Usage example
@example
pdf_time_span_t span;

/* ...create and manipulate `span'... */

pdf_time_span_destroy (span);
@end example
@end table
@end deftypefun

@node Managing Time Span Values
@subsection Managing Time Span Values

@deftypefun pdf_status_t pdf_time_span_set (pdf_time_span_t span, pdf_i32_t high_value, pdf_u32_t low_value)

Set the value of a time span. The internal representation of the time
span is 64 bits long (signed).

@table @strong
@item Parameters

@table @var
@item span
A properly created time span variable.
@item high_value
The high (signed) part of the time span value.
@item low_value
The low (unsigned) part of the time span value.
@end table

@item Returns

A pdf status value.

@table @code
@item PDF_OK
The operation successfully finished.
@end table

@item Usage exaple
@example
pdf_time_span_t span;

span = pdf_time_span_new ();
pdf_time_span_set (span, (32 << 1), 10); /* The span is -10 seconds long */
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_time_span_set_from_i32 (pdf_time_span_t span, pdf_i32_t seconds)

Set the value of a time span from a 32 bits signed number.

@table @strong
@item Parameters

@table @var
@item span
A properly created time span variable.
@item seconds
A signed 32 bits number.
@end table

@item Returns

A pdf status value.

@table @code
@item PDF_OK
The operation successfully finished.
@end table

@item Usage example
@example
pdf_time_span_t span;

span = pdf_time_span_create ();
pdf_time_span_set_from_i32 (span, -10); /* The span is -10 seconds long */
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_time_span_negate (pdf_time_span_t span)

Make a positive time span into a negative one or make a negative time
span into a positive one.

@table @strong
@item Parameters

@table @var
@item span
A properly created time span variable.
@end table

@item Returns

A pdf status value.

@table @code
@item PDF_OK
The operation successfully finished.
@end table

@item Usage example
@example
pdf_time_span_t span;

/* ...create and manipulate `span'... */

pdf_time_span_negate (span);
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_time_span_add (pdf_time_span_t span1, pdf_time_span_t span2, pdf_time_span_t result)

Add two time spans and store the result in another time span.

@table @strong
@item Parameters

@table @var
@item span1
The first time span to add.
@item span2
The second time span to add.
@item result
The time span holding the result of the add operation. Any previous
content is lost.
@end table

@item Returns

@table @code
@item PDF_OK
The operation successfully finished.
@end table

@item Usage example
@example
pdf_time_span_t span1;
pdf_time_span_t span2;
pdf_time_span_t result;

/* ...create and manipulate `span1', `span2' and `result'... */
pdf_time_span_add (span1, span2, result);
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_time_span_copy (pdf_time_span_t orig, pdf_time_span_t dest)

Copy the value of a time span into another time span.

@table @strong
@item Parameters

@table @var
@item orig
The origin time span.
@item dest
The time span variable that will hold the value of @var{orig}. Any
previous value is lost.
@end table

@item Returns

@table @code
@item PDF_OK
The operation successfully finished.
@end table

@item Usage example
@example
pdf_time_span_t span_orig;
pdf_time_span_t span_dest;

/* ...create and manipulate `span_orig' and `span_dest'... */

pdf_time_span_copy (span_orig, span_dest);
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_time_span_diff (pdf_time_span_t span1, pdf_time_span_t span2, pdf_time_span_t result)

Difference two time spans and store the result (maybe negative) into
another time span.

@table @strong
@item Parameters

@table @var
@item span1
The first time span to diff.
@item span2
The second time span to diff.
@item result
The result of the diff operation. Any previous value of the time span
is lost.
@end table

@item Returns

@table @code
@item PDF_OK
The operation successfully finished.
@end table

@item Usage example
@example
pdf_time_span_t span1;
pdf_time_span_t span2;
pdf_time_span_t span_diff;

/* ...create and manipulate `span1', `span2' and `span3' */

pdf_time_span_diff (span1, span2, span_diff);
@end example
@end table
@end deftypefun

@deftypefun pdf_i32_t pdf_time_span_to_secs (pdf_time_span_t span)

Get the value of a time span in seconds. 

@table @strong
@item Parameters

@table @var
@item span
A properly created time span variable.
@end table

@item Returns

The value of the time span in seconds.
A negative value is returned if the time span is negative.

@item Usage example
@example
pdf_time_span_t span;
pdf_i32_t num_seconds;

/* ...create and manipulate `span'... */

num_seconds = pdf_time_span_to_secs (span);
@end example
@end table
@end deftypefun

@node Time Span Comparison
@subsection Time Span Comparison

@deftypefun pdf_i32_t pdf_time_span_cmp (pdf_time_span_t span1, pdf_time_span_t span2)

Compare the length two time spans.

@table @strong
@item Parameters

@table @var
@item span1
The first time span to compare.
@item span2
The second time span to compare.
@end table

@item Returns

@table @code
@item -1
The length of @var{span1} is shorter than the length of @var{span2}.
@item 0
The lengts of @var{span1} and @var{span2} are equal.
@item +1
The length of @var{span1} is greater than the length of @var{span2}.
@end table

@item Usage example
@example
pdf_time_span_t span1;
pdf_time_span_t span2;

/* ...create and manipulate `span1' and `span2'... */
switch (pdf_time_span_cmp (span1, span2))
@{
  case -1:
  @{
    /* The length of `span1' is shorter than the length of `span2' */
    break;
  @}
  case 0:
  @{
    /* The length of `span1' is equal to the length of `span2' */
    break;
  @}
  case 1:
  @{
    /* The length of `span1' is greater than the length of `span2' */
    break;
  @}
@}
@end example
@end table
@end deftypefun

@node Calendar Spans Management
@subsection  Calendar Spans Management

@deftypefun pdf_status_t pdf_time_add_cal_span_with_base (struct pdf_time_cal_span_s span1, struct pdf_time_cal_span_s span2, pdf_time_t base_time, struct pdf_time_cal_span_s result)

Add two calendar spans. Since the calendar spans are relative (some
years has more days than another) the calendar spans are first
resolved from a base time.

@table @strong
@item Parameters

@table @var
@item span1
The first calendar span to add.
@item span2
The second calendar span to add.
@item base_time
The base time to use.
@item result
The calendar span to store the result of the add operation.
@end table

@item Returns

@table @code
@item PDF_OK
The operation successfully finished.
@item PDF_E_BADDATA
There is invalid data in @var{span1} or @var{span2}.
@end table

@item Usage example
@example
pdf_time_t mytime;
struct pdf_time_cal_span_s cal_span1;
struct pdf_time_cal_span_s cal_span2;
struct pdf_time_cal_span_s cal_result;

/* ...create and initialize `mytime', `cal_span1'
 *    and `cal_span2'...
 */

if (pdf_time_add_cal_span_with_base (cal_span1,
                                     cal_span2,
                                     mytime,
                                     cal_result) == PDF_E_BADDATA)
@{
  /* Invalid data in `cal_span1' or `cal_span2' */
@}      
@end example
@end table
@end deftypefun


@deftypefun pdf_i32_t pdf_time_cal_span_cmp (struct pdf_time_cal_span_s span1, struct pdf_time_cal_span_s span2, pdf_time_t base_time)

Compare two calendar spans previously resolved with a given base time.

@table @strong
@item Parameters

@table @var
@item span1
The first calendar span to be compared.
@item span2
The second calendar span to be compared.
@item base_time
The used base time. Should be a correctly created time variable.
@end table

@item Returns

@table @code
@item -1
Given the base time, the time interval defined by @var{span1} is
greater in length than the time interval defined by @var{span2}.
@item 0
Given the base time, the time inveral defined by @var{span1} is equal
in length than the time interval defined by @var{span2}.
@item +1
Given the base time, the time interval defined by @var{span2} is
greater in length than the time interval defined by @var{span1}.
@end table

@item Usage example
@example
pdf_time_t mytime;
struct pdf_time_cal_span_s span1;
struct pdf_time_cal_span_s span2;

/* ...create and manipulate `mytime', `span1' and `span2'... */

switch (pdf_time_cal_span_cmp (span1, span2, mytime))
@{
  case -1:
  @{
    /* The length of `span1' is shorter than the length of `span2' */
    break;
  @}
  case 0:
  @{
    /* The length of `span1' is equal than the length of `span2' */
    break;
  @}
  case 1:
  @{
    /* The length of `span1' is greater than the length of `span2' */
    break;
  @}
@}
@end example
@end table
@end deftypefun

@deftypefun pdf_status_t pdf_time_cal_span_diff (struct pdf_time_cal_span_s span1, struct pdf_time_cal_span_s span2, pdf_time_t base_time, struct pdf_time_cal_span_s result)

Compute the difference between two calendar spans relative to a given
base time and store it in a given calendar span.

@table @strong
@item Parameters

@table @var
@item span1
The first calendar span to diff.
@item span2
The second calendar span to diff.
@item base_time
The base time. Should be a correctly created time variable.
@item result
The calendar structure holding the result of the difference.
@end table

@item Returns

@table @code
@item PDF_OK
The operation successfully finished.
@item PDF_E_BADDATA
There is invalid data in @var{span1} or @var{span2}.
@end table

@item Usage example
@example
pdf_time_t mytime;
struct pdf_time_cal_span_s span1;
struct pdf_time_cal_span_s span2;
struct pdf_time_cal_span_s result;

/* ...create and manipulate `span1', `span2' and 
 *    `result'... 
 */

if (pdf_time_cal_span_diff (span1,
                            span2,
                            mytime,
                            result) == PDF_E_BADDATA)
@{
  /* Invalid data in `span1' or `span2' */
@}
@end example
@end table
@end deftypefun


@node Accessing the File System
@section Accessing the File System

@node Object Layer
@chapter Object Layer

@menu
* Object Layer Overview::
* PDF Objects::
* Object Collections::
* Memory Management::
* Object Level Documents::
* Real Objects::
* Integer Objects::
* Boolean Objects::
* Name Objects::
* String Objects::
* Array Objects::
* Dictionary Objects::
* Stream Objects::
* Indirect Objects::
* Null Object::
@end menu

@node Object Layer Overview
@section Overview

The Object Layer of the library provides access to manipulate PDF
documents as a collection of PDF objects (@pxref{PDF Objects}).

Note that the use of this layer can lead to non-well conformed PDF
documents: not every PDF object collection define a document. So the
client should be careful when using this layer. In contrast the
@ref{Document Layer} provides a convenient API to manipulate PDF files
while maintaining its structural integrity.

All the names for constants, data types and functions defined in this
layer are prefixed with @code{pdfo_} or @code{PDFO_}.

@node PDF Objects
@section PDF Objects

@node Object Collections
@section Object Collections

@node Memory Management
@section Memory Management

@node Object Level Documents
@section Object Level Documents

@node Real Objects
@section Real Objects

A real object represent a fixed-point real number.

@menu
* Real Object Creation::
* Managing Real Object Attributes::
@end menu

@node Real Object Creation
@subsection Real Object Creation

@deftypefun pdfo_obj_t pdfo_create_real (pdfo_doc_t @var{doc}, pdf_bool_t @var{indirect}, pdf_real_t @var{value})

Creates a new real object.

@table @strong
@item Parameters

@table @var
@item doc
Document that contain this object.
@item indirect
Boolean value specifying if we want to create an indirect object.
@item value
Initialization value.
@end table

@item Returns

The newly created object.

@item Usage example

@example
pdfo_doc_t doc;
pdfo_obj_t new_obj;

/* Initialize `doc' ... */

new_obj = pdfo_create_real (doc, PDF_FALSE, 2.12);
@end example 
@end table
@end deftypefun 

@node Managing Real Object Attributes
@subsection Managing Real Object Attributes

@deftypefun pdf_real_t pdfo_get_real (pdfo_obj_t @var{object})

Gets the real value of a real object.

@table @strong
@item Parameters

None.

@item Returns

The real value of the given object.

@item Usage example

@example
pdfo_obj_t real_obj;
pdf_real_t value;

/* Initialize `real_obj' as a Real object ... */

value = pdfo_get_real (new_obj);
@end example
@end table
@end deftypefun

@deftypefun void pdfo_set_real (pdfo_obj_t @var{object}, pdf_real_t @var{value})

Set a new real value in a real object.

@table @strong
@item Parameters
@table @var
@item object
Real object.
@item value
New real value.
@end table

@item Returns

None.

@item Usage example
@example
pdfo_obj_t real_obj;
pdf_real_t value;

/* Initialize `real_obj' as a Real object ... */

pdfo_set_real (new_obj, 3.14);
@end example
@end table
@end deftypefun

@node Integer Objects
@section Integer Objects

@node Boolean Objects
@section Boolean Objects

@node Name Objects
@section Name Objects

@node String Objects
@section String Objects

@node Array Objects
@section Array Objects

@node Dictionary Objects
@section Dictionary Objects

@node Stream Objects
@section Stream Objects

@node Indirect Objects
@section Indirect Objects

@node Null Object
@section Null Object


@node Document Layer
@chapter Document Layer

@node Page Contents Layer
@chapter Page Contents Layer


@c FDL
@c ===

@node GNU Free Documentation License
@appendix GNU Free Documentation License

@include fdl.texi


@c The indexes
@c ===========

@node Global variable index
@unnumbered Global variable index

@printindex vr

@node Data type index
@unnumbered Data type index

@printindex tp

@node Function index
@unnumbered Function index

@printindex fn


@bye
